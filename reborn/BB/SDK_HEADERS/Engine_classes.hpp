/*
#############################################################################################
# BattleBorn (1.0.0.0) SDK
# Generated with the CodeRedGenerator v1.0.3
# ========================================================================================= #
# File: Engine_classes.hpp
# ========================================================================================= #
# Credits: TheFeckless, ItsBranK
# Links: www.github.com/CodeRedModding/CodeRed-Generator, www.twitter.com/ItsBranK
#############################################################################################
*/
#pragma once

#ifdef _MSC_VER
	#pragma pack(push, 0x8)
#endif

/*
# ========================================================================================= #
# Constants
# ========================================================================================= #
*/

#define CONST_RB_Sleeping                                       0
#define CONST_RB_NeedsUpdate                                    0
#define CONST_RB_None                                           0
#define CONST_RBSTATE_ANGVELSCALE                               1
#define CONST_RBSTATE_LINVELSCALE                               1
#define CONST_ACTORMAXSTEPHEIGHT                                3
#define CONST_MINFLOORZ                                         0
#define CONST_REP_RBLOCATION_ERROR_TOLERANCE_SQ                 1
#define CONST_TRACEFLAG_LagCompensation                         4
#define CONST_TRACEFLAG_Shield                                  2
#define CONST_TRACEFLAG_IgnoreBlockingMesh                      1
#define CONST_TRACEFLAG_BlockingMesh                            5
#define CONST_TRACEFLAG_Water                                   2
#define CONST_TRACEFLAG_Listener                                1
#define CONST_TRACEFLAG_Projectiles                             6
#define CONST_TRACEFLAG_FieldVolumes                            3
#define CONST_TRACEFLAG_IgnoreNonBlockingTriggers               1
#define CONST_TRACEFLAG_LightProjectile                         8
#define CONST_TRACEFLAG_Blocking                                8
#define CONST_TRACEFLAG_SkipMovers                              4
#define CONST_TRACEFLAG_PhysicsVolumes                          2
#define CONST_TRACEFLAG_Bullet                                  1
#define CONST_MAXCLIENTUPDATEINTERVAL                           0
#define CONST_CLIENTADJUSTUPDATECOST                            1
#define CONST_MAXVEHICLEPOSITIONERRORSQUARED                    9
#define CONST_MAXNEARZEROVELOCITYSQUARED                        9
#define CONST_MAXPOSITIONERRORSQUARED                           3
#define CONST_MAX_ACTIVE_CAMERA_ANIMS                           8
#define CONST_TARGETABLEFLAG_TargetDead                         1
#define CONST_LINK_ID_RESERVED_FOR_DEFAULT_BEHAVIOR_OUTPUT      2
#define CONST_MAX_TEXT_MESSAGE_LENGTH                           1
#define CONST_VOICE_CHANNEL_GLOBAL                              2
#define CONST_DEFAULT_SIZE_Y                                    7
#define CONST_DEFAULT_SIZE_X                                    1
#define CONST_MaxHistory                                        1
#define CONST_MAX_SKILL_EVENT_TRIGGERS                          8
#define CONST_NULLCHARACTER                                     1
#define CONST_SCENEFILTER_Any                                   0
#define CONST_SCENEFILTER_ReceivesFocus                         0
#define CONST_SCENEFILTER_UsesPostProcessing                    0
#define CONST_SCENEFILTER_PrimitiveUsersOnly                    0
#define CONST_SCENEFILTER_PausersOnly                           0
#define CONST_SCENEFILTER_InputProcessorOnly                    0
#define CONST_SCENEFILTER_IncludeTransient                      0
#define CONST_SCENEFILTER_None                                  0
#define CONST_MAX_POLY_POINT_CHECKS                             1
#define CONST_MAX_POLY_OBSTACLE_BYTES                           1
#define CONST_MAX_POLY_OBSTACLES                                6
#define CONST_DESIRED_NAVMESH_LOOKUP_NODE_SIZE                  1
#define CONST_NUM_EDGE_BYTES                                    6
#define CONST_WORDSIZE                                          2
#define CONST_NUM_EDGES                                         3
#define CONST_MAX_REPLICATED_ACTOR_STATES                       2
#define CONST_MAX_AIGROUP_NUMBER                                1
#define CONST_MAX_RESOURCE_POOLS                                1
#define CONST_UnknownCellDataFieldName                          '\''
#define CONST_CRC_BITS                                          1
#define CONST_CRC_BYTE_OFFSET                                   5
#define CONST_UNIQUE_INVENTORY_ID_BYTE_OFFSET                   1
#define CONST_ENCODED_WEAPON_TYPE                               1
#define CONST_ENCODED_ITEM_TYPE                                 0
#define CONST_STORED_AMMO_BITS                                  1
#define CONST_UNIQUE_INVENTORY_ID_BITS                          3
#define CONST_GAME_STAGE_BITS                                   7
#define CONST_GRADE_BITS                                        7
#define CONST_REVISION_BITS                                     7
#define CONST_INVENTORY_SERIAL_NUMBER_SIZE                      4
#define CONST_MAX_INVENTORY_ATTRIBUTE_SLOTS                     1
#define CONST_InventoryNetUpdateLow                             1
#define CONST_InventoryNetUpdateHigh                            1
#define CONST_USE_FAILURE_DLC                                   2
#define CONST_USE_FAILURE_CONSTRAINTS                           1
#define CONST_USE_FAILURE_LEVEL                                 0
#define CONST_MAX_UI_STATS                                      7
#define CONST_MAX_FLASHLOCATIONS                                1
#define CONST_MAX_ADDITIONAL_GESTALT_MODE_MESHES                2

/*
# ========================================================================================= #
# Enums
# ========================================================================================= #
*/

// Enum Engine.Actor.ESkelThrottleType
enum class ESkelThrottleType : uint8_t
{
	SkelThrottle_None                                  = 0,
	SkelThrottle_Half                                  = 1,
	SkelThrottle_Full                                  = 2,
	SkelThrottle_END                                   = 3
};

// Enum Engine.Actor.EDoubleClickDir
enum class EDoubleClickDir : uint8_t
{
	DCLICK_None                                        = 0,
	DCLICK_Left                                        = 1,
	DCLICK_Right                                       = 2,
	DCLICK_Forward                                     = 3,
	DCLICK_Back                                        = 4,
	DCLICK_Active                                      = 5,
	DCLICK_Done                                        = 6,
	DCLICK_END                                         = 7
};

// Enum Engine.Actor.ETravelType
enum class ETravelType : uint8_t
{
	TRAVEL_Absolute                                    = 0,
	TRAVEL_Partial                                     = 1,
	TRAVEL_Relative                                    = 2,
	TRAVEL_END                                         = 3
};

// Enum Engine.Actor.ECollisionType
enum class ECollisionType : uint8_t
{
	COLLIDE_CustomDefault                              = 0,
	COLLIDE_NoCollision                                = 1,
	COLLIDE_BlockAll                                   = 2,
	COLLIDE_BlockWeapons                               = 3,
	COLLIDE_TouchAll                                   = 4,
	COLLIDE_TouchWeapons                               = 5,
	COLLIDE_BlockAllButWeapons                         = 6,
	COLLIDE_TouchAllButWeapons                         = 7,
	COLLIDE_BlockWeaponsKickable                       = 8,
	COLLIDE_BlockAllButVehicles                        = 9,
	COLLIDE_BlockLineTraces                            = 10,
	COLLIDE_TouchLineTraces                            = 11,
	COLLIDE_BlockActors                                = 12,
	COLLIDE_TouchActors                                = 13,
	COLLIDE_BlockLineTracesAndPhysics                  = 14,
	COLLIDE_BlockAllButPawns                           = 15,
	COLLIDE_END                                        = 16
};

// Enum Engine.Actor.ENetRole
enum class ENetRole : uint8_t
{
	ROLE_None                                          = 0,
	ROLE_SimulatedProxy                                = 1,
	ROLE_AutonomousProxy                               = 2,
	ROLE_Authority                                     = 3,
	ROLE_END                                           = 4
};

// Enum Engine.Actor.EActorMetricsType
enum class EActorMetricsType : uint8_t
{
	METRICS_VERTS                                      = 0,
	METRICS_TRIS                                       = 1,
	METRICS_SECTIONS                                   = 2,
	METRICS_END                                        = 3
};

// Enum Engine.Actor.EMoveDir
enum class EMoveDir : uint8_t
{
	MD_Stationary                                      = 0,
	MD_Forward                                         = 1,
	MD_Backward                                        = 2,
	MD_Left                                            = 3,
	MD_Right                                           = 4,
	MD_Up                                              = 5,
	MD_Down                                            = 6,
	MD_END                                             = 7
};

// Enum Engine.Actor.EPhysics
enum class EPhysics : uint8_t
{
	PHYS_None                                          = 0,
	PHYS_Walking                                       = 1,
	PHYS_Falling                                       = 2,
	PHYS_Swimming                                      = 3,
	PHYS_Flying                                        = 4,
	PHYS_Rotating                                      = 5,
	PHYS_Projectile                                    = 6,
	PHYS_Interpolating                                 = 7,
	PHYS_Spider                                        = 8,
	PHYS_Ladder                                        = 9,
	PHYS_RigidBody                                     = 10,
	PHYS_SoftBody                                      = 11,
	PHYS_NavMeshWalking                                = 12,
	PHYS_Unused                                        = 13,
	PHYS_Custom                                        = 14,
	PHYS_END                                           = 15
};

// Enum Engine.Scene.ESceneViewHideViewportType
enum class ESceneViewHideViewportType : uint8_t
{
	SVHVT_None                                         = 0,
	SVHVT_Viewport1                                    = 1,
	SVHVT_Viewport2                                    = 2,
	SVHVT_END                                          = 3
};

// Enum Engine.Scene.ESceneViewSeeType
enum class ESceneViewSeeType : uint8_t
{
	SVST_None                                          = 0,
	SVST_OnlyOwnerSee                                  = 1,
	SVST_OwnerNoSee                                    = 2,
	SVST_OnlyViewerSee                                 = 3,
	SVST_ViewerNoSee                                   = 4,
	SVST_END                                           = 5
};

// Enum Engine.Scene.EDetailMode
enum class EDetailMode : uint8_t
{
	DM_Low                                             = 0,
	DM_Medium                                          = 1,
	DM_High                                            = 2,
	DM_END                                             = 3
};

// Enum Engine.Scene.ESceneDepthPriorityGroup
enum class ESceneDepthPriorityGroup : uint8_t
{
	SDPG_UnrealEdBackground                            = 0,
	SDPG_World                                         = 1,
	SDPG_WorldDepthFail                                = 2,
	SDPG_Foreground                                    = 3,
	SDPG_UnrealEdForeground                            = 4,
	SDPG_PostProcess                                   = 5,
	SDPG_WorldPreAlphaPostProcess                      = 6,
	SDPG_AfterPostProcess                              = 7,
	SDPG_END                                           = 8
};

// Enum Engine.Scene.EGameDepthPriorityGroup
enum class EGameDepthPriorityGroup : uint8_t
{
	GDPG_World                                         = 0,
	GDPG_Foreground                                    = 1,
	GDPG_END                                           = 2
};

// Enum Engine.Scene.EGameRenderPhase
enum class EGameRenderPhase : uint8_t
{
	GRP_GameScene                                      = 0,
	GRP_BackMenuScene                                  = 1,
	GRP_ItemCards                                      = 2,
	GRP_Preview                                        = 3,
	GRP_LoadingGear                                    = 4,
	GRP_PostProcessOnly                                = 5,
	GRP_END                                            = 6
};

// Enum Engine.PawnAllegiance.EOpinion
enum class EOpinion : uint8_t
{
	OPINION_Enemy                                      = 0,
	OPINION_Neutral                                    = 1,
	OPINION_Friendly                                   = 2,
	OPINION_END                                        = 3
};

// Enum Engine.OnlineSubsystem.EOnlineLogType
enum class EOnlineLogType : uint8_t
{
	OLT_Message                                        = 0,
	OLT_Error                                          = 1,
	OLT_Debug                                          = 2,
	OLT_END                                            = 3
};

// Enum Engine.OnlineSubsystem.EMatchmakingResult
enum class EMatchmakingResult : uint8_t
{
	MR_Found                                           = 0,
	MR_Expired                                         = 1,
	MR_Canceled                                        = 2,
	MR_InitializationFailed                            = 3,
	MR_InvalidTicketSession                            = 4,
	MR_END                                             = 5
};

// Enum Engine.OnlineSubsystem.EOnlineSubsystemResult
enum class EOnlineSubsystemResult : uint8_t
{
	OSR_Success                                        = 0,
	OSR_Failed                                         = 1,
	OSR_FailedFullSession                              = 2,
	OSR_FailedRateLimit                                = 3,
	OSR_FailedInSession                                = 4,
	OSR_FailedExpired                                  = 5,
	OSR_FailedAlreadyUsed                              = 6,
	OSR_FailedSessionNoLongerExists                    = 7,
	OSR_FailedAgeRestriction                           = 8,
	OSR_FailedNetworkError                             = 9,
	OSR_FailedNoPrivilege                              = 10,
	OSR_END                                            = 11
};

// Enum Engine.OnlineSubsystem.EOnlinePlayerStorageAsyncState
enum class EOnlinePlayerStorageAsyncState : uint8_t
{
	OPAS_NotStarted                                    = 0,
	OPAS_Read                                          = 1,
	OPAS_Write                                         = 2,
	OPAS_Finished                                      = 3,
	OPAS_END                                           = 4
};

// Enum Engine.OnlineSubsystem.EShowKeyboardType
enum class EShowKeyboardType : uint8_t
{
	SKT_Standard                                       = 0,
	SKT_Password                                       = 1,
	SKT_Email                                          = 2,
	SKT_END                                            = 3
};

// Enum Engine.OnlineSubsystem.EFeedActionType
enum class EFeedActionType : uint8_t
{
	FAT_Url                                            = 0,
	FAT_Store                                          = 1,
	FAT_StartGame                                      = 2,
	FAT_Invalid                                        = 3,
	FAT_END                                            = 4
};

// Enum Engine.OnlineSubsystem.FeedEntityType
enum class EFeedEntityType : uint8_t
{
	FET_OnlineId                                       = 0,
	FET_TitleId                                        = 1,
	FET_SmallImageUrl                                  = 2,
	FET_LargeImageUrl                                  = 3,
	FET_VideoUrl                                       = 4,
	FET_PlayedDescription                              = 5,
	FET_Invalid                                        = 6,
	FET_END                                            = 7
};

// Enum Engine.OnlineSubsystem.ELanBeaconState
enum class ELanBeaconState : uint8_t
{
	LANB_NotUsingLanBeacon                             = 0,
	LANB_Hosting                                       = 1,
	LANB_Searching                                     = 2,
	LANB_END                                           = 3
};

// Enum Engine.OnlineSubsystem.ENATType
enum class ENATType : uint8_t
{
	NAT_Unknown                                        = 0,
	NAT_Open                                           = 1,
	NAT_Moderate                                       = 2,
	NAT_Strict                                         = 3,
	NAT_END                                            = 4
};

// Enum Engine.OnlineSubsystem.EVoiceVolumeType
enum class EVoiceVolumeType : uint8_t
{
	VVT_Capture                                        = 0,
	VVT_Playback                                       = 1,
	VVT_CaptureAndPlayback                             = 2,
	VVT_END                                            = 3
};

// Enum Engine.OnlineSubsystem.EOnlineFriendState
enum class EOnlineFriendState : uint8_t
{
	OFS_Offline                                        = 0,
	OFS_Online                                         = 1,
	OFS_Away                                           = 2,
	OFS_Busy                                           = 3,
	OFS_END                                            = 4
};

// Enum Engine.OnlineSubsystem.EOnlineEnumerationReadState
enum class EOnlineEnumerationReadState : uint8_t
{
	OERS_NotStarted                                    = 0,
	OERS_InProgress                                    = 1,
	OERS_Done                                          = 2,
	OERS_Failed                                        = 3,
	OERS_END                                           = 4
};

// Enum Engine.OnlineSubsystem.EOnlineGameState
enum class EOnlineGameState : uint8_t
{
	OGS_NoSession                                      = 0,
	OGS_Pending                                        = 1,
	OGS_Starting                                       = 2,
	OGS_InProgress                                     = 3,
	OGS_Ending                                         = 4,
	OGS_Ended                                          = 5,
	OGS_Destroying                                     = 6,
	OGS_END                                            = 7
};

// Enum Engine.OnlineSubsystem.ENetworkNotificationPosition
enum class ENetworkNotificationPosition : uint8_t
{
	NNP_TopLeft                                        = 0,
	NNP_TopCenter                                      = 1,
	NNP_TopRight                                       = 2,
	NNP_CenterLeft                                     = 3,
	NNP_Center                                         = 4,
	NNP_CenterRight                                    = 5,
	NNP_BottomLeft                                     = 6,
	NNP_BottomCenter                                   = 7,
	NNP_BottomRight                                    = 8,
	NNP_END                                            = 9
};

// Enum Engine.OnlineSubsystem.EOnlineFeature
enum class EOnlineFeature : uint8_t
{
	EOF_PlayOnline                                     = 0,
	EOF_PlayOnlineCloud                                = 1,
	EOF_Communicate                                    = 2,
	EOF_DownloadUserContent                            = 3,
	EOF_PurchaseContent                                = 4,
	EOF_ViewPlayerProfiles                             = 5,
	EOF_ShowPresence                                   = 6,
	EOF_END                                            = 7
};

// Enum Engine.OnlineSubsystem.EFeaturePrivilegeLevel
enum class EFeaturePrivilegeLevel : uint8_t
{
	FPL_Disabled                                       = 0,
	FPL_Enabled                                        = 1,
	FPL_END                                            = 2
};

// Enum Engine.OnlineSubsystem.EUserAgeGroup
enum class EUserAgeGroup : uint8_t
{
	UAG_Unknown                                        = 0,
	UAG_Child                                          = 1,
	UAG_Teen                                           = 2,
	UAG_Adult                                          = 3,
	UAG_END                                            = 4
};

// Enum Engine.OnlineSubsystem.ELoginStatus
enum class ELoginStatus : uint8_t
{
	LS_NotLoggedIn                                     = 0,
	LS_UsingLocalProfile                               = 1,
	LS_LoggedIn                                        = 2,
	LS_END                                             = 3
};

// Enum Engine.OnlineSubsystem.ENamedOnlineContentType
enum class ENamedOnlineContentType : uint8_t
{
	NOCT_Content                                       = 0,
	NOCT_SeasonPass                                    = 1,
	NOCT_PreorderBonus                                 = 2,
	NOCT_CompatibilityPack                             = 3,
	NOCT_END                                           = 4
};

// Enum Engine.PrimitiveComponent.ERadialImpulseFalloff
enum class ERadialImpulseFalloff : uint8_t
{
	RIF_Constant                                       = 0,
	RIF_Linear                                         = 1,
	RIF_END                                            = 2
};

// Enum Engine.PrimitiveComponent.GJKResult
enum class EGJKResult : uint8_t
{
	GJK_Intersect                                      = 0,
	GJK_NoIntersection                                 = 1,
	GJK_Fail                                           = 2,
	GJK_END                                            = 3
};

// Enum Engine.PrimitiveComponent.EOverrideStaticShadow
enum class EOverrideStaticShadow : uint8_t
{
	OSS_NoOverride                                     = 0,
	OSS_CastButDontReceiveStatic                       = 1,
	OSS_CastAndReceiveStatic                           = 2,
	OSS_END                                            = 3
};

// Enum Engine.PrimitiveComponent.EWeaponCollisionType
enum class EWeaponCollisionType : uint8_t
{
	WCT_BlockWeapons                                   = 0,
	WCT_DontBlockWeapons                               = 1,
	WCT_OnlyBlockWeapons                               = 2,
	WCT_END                                            = 3
};

// Enum Engine.PrimitiveComponent.ERBCollisionChannel
enum class ERBCollisionChannel : uint8_t
{
	RBCC_Default                                       = 0,
	RBCC_Nothing                                       = 1,
	RBCC_Pawn                                          = 2,
	RBCC_Vehicle                                       = 3,
	RBCC_Water                                         = 4,
	RBCC_GameplayPhysics                               = 5,
	RBCC_EffectPhysics                                 = 6,
	RBCC_Untitled1                                     = 7,
	RBCC_Untitled2                                     = 8,
	RBCC_TossedItems                                   = 9,
	RBCC_TossedItemsPlayerVehicle                      = 10,
	RBCC_Cloth                                         = 11,
	RBCC_FluidDrain                                    = 12,
	RBCC_SoftBody                                      = 13,
	RBCC_FracturedMeshPart                             = 14,
	RBCC_BlockingVolume                                = 15,
	RBCC_DeadPawn                                      = 16,
	RBCC_Clothing                                      = 17,
	RBCC_ClothingCollision                             = 18,
	RBCC_TossedItemsEnemyVehicle                       = 19,
	RBCC_PlayerVehicle                                 = 20,
	RBCC_EnemyVehicle                                  = 21,
	RBCC_PlayerVehicleEnemyVehicle                     = 22,
	RBCC_TossedItemsPlayerVehicleEnemyVehicle          = 23,
	RBCC_WillowPickup                                  = 24,
	RBCC_END                                           = 25
};

// Enum Engine.LightComponent.ELightAffectsClassification
enum class ELightAffectsClassification : uint8_t
{
	LAC_USER_SELECTED                                  = 0,
	LAC_DYNAMIC_AFFECTING                              = 1,
	LAC_STATIC_AFFECTING                               = 2,
	LAC_DYNAMIC_AND_STATIC_AFFECTING                   = 3,
	LAC_END                                            = 4
};

// Enum Engine.Controller.EDamageModifierType
enum class EDamageModifierType : uint8_t
{
	DAMAGEMODIFIER_Bullet                              = 0,
	DAMAGEMODIFIER_Grenade                             = 1,
	DAMAGEMODIFIER_Rocket                              = 2,
	DAMAGEMODIFIER_Melee                               = 3,
	DAMAGEMODIFIER_Skill                               = 4,
	DAMAGEMODIFIER_Amplify                             = 5,
	DAMAGEMODIFIER_END                                 = 6
};

// Enum Engine.IInstanceData.EInstanceDataType2
enum class EInstanceDataType2 : uint8_t
{
	IDT2_Bool                                          = 0,
	IDT2_Int                                           = 1,
	IDT2_Float                                         = 2,
	IDT2_Vector                                        = 3,
	IDT2_Object                                        = 4,
	IDT2_SkelControl                                   = 5,
	IDT2_ActorComponent                                = 6,
	IDT2_Actor                                         = 7,
	IDT2_Switch                                        = 8,
	IDT2_Slot                                          = 9,
	IDT2_Hide                                          = 10,
	IDT2_Material                                      = 11,
	IDT2_ActorFromDef                                  = 12,
	IDT2_String                                        = 13,
	IDT2_BehaviorEvent                                 = 14,
	IDT2_CustomHead                                    = 15,
	IDT2_END                                           = 16
};

// Enum Engine.IInstanceData.EReplicationType
enum class EReplicationType : uint8_t
{
	IDR_Server                                         = 0,
	IDR_Client                                         = 1,
	IDR_Local                                          = 2,
	IDR_END                                            = 3
};

// Enum Engine.IInstanceData.EInstanceDataType
enum class EInstanceDataType : uint8_t
{
	IDT_Bool                                           = 0,
	IDT_Int                                            = 1,
	IDT_Float                                          = 2,
	IDT_Vector                                         = 3,
	IDT_Object                                         = 4,
	IDT_ActorComponent                                 = 5,
	IDT_Actor                                          = 6,
	IDT_ActorTemplate                                  = 7,
	IDT_String                                         = 8,
	IDT_Switch                                         = 9,
	IDT_PickupTemplate                                 = 10,
	IDT_CustomHead                                     = 11,
	IDT_CustomSkin                                     = 12,
	IDT_END                                            = 13
};

// Enum Engine.PlayerController.ETeamRelativeColorCategory
enum class ETeamRelativeColorCategory : uint8_t
{
	TEAMRELATIVE_UI                                    = 0,
	TEAMRELATIVE_Text                                  = 1,
	TEAMRELATIVE_InWorld                               = 2,
	TEAMRELATIVE_END                                   = 3
};

// Enum Engine.PlayerController.EProgressMessageType
enum class EProgressMessageType : uint8_t
{
	PMT_Clear                                          = 0,
	PMT_Information                                    = 1,
	PMT_AdminMessage                                   = 2,
	PMT_DownloadProgress                               = 3,
	PMT_ConnectionFailure                              = 4,
	PMT_SocketFailure                                  = 5,
	PMT_END                                            = 6
};

// Enum Engine.PlayerController.EInputMatchAction
enum class EInputMatchAction : uint8_t
{
	IMA_GreaterThan                                    = 0,
	IMA_LessThan                                       = 1,
	IMA_END                                            = 2
};

// Enum Engine.PlayerController.EInputTypes
enum class EInputTypes : uint8_t
{
	IT_XAxis                                           = 0,
	IT_YAxis                                           = 1,
	IT_END                                             = 2
};

// Enum Engine.EngineTypes.ECinematicModeApplication
enum class ECinematicModeApplication : uint8_t
{
	ECMA_PushMode                                      = 0,
	ECMA_SetMode                                       = 1,
	ECMA_END                                           = 2
};

// Enum Engine.EngineTypes.ELightingBuildQuality
enum class ELightingBuildQuality : uint8_t
{
	Quality_Preview                                    = 0,
	Quality_Medium                                     = 1,
	Quality_High                                       = 2,
	Quality_Production                                 = 3,
	Quality_NoGlobalIllumination                       = 4,
	Quality_END                                        = 5
};

// Enum Engine.EngineTypes.EMeshNormalGenerationMethod
enum class EMeshNormalGenerationMethod : uint8_t
{
	EMNGM_BuiltIn                                      = 0,
	EMNGM_MikkTSpace                                   = 1,
	EMNGM_END                                          = 2
};

// Enum Engine.EngineTypes.EMeshNormalImportMethod
enum class EMeshNormalImportMethod : uint8_t
{
	EMNIM_ImportNormalsAndTangents                     = 0,
	EMNIM_ImportNormals                                = 1,
	EMNIM_ComputeNormals                               = 2,
	EMNIM_END                                          = 3
};

// Enum Engine.EngineTypes.EMaterialLightingModel
enum class EMaterialLightingModel : uint8_t
{
	MLM_Phong                                          = 0,
	MLM_NonDirectional                                 = 1,
	MLM_Unlit                                          = 2,
	MLM_SHPRT                                          = 3,
	MLM_Custom                                         = 4,
	MLM_Anisotropic                                    = 5,
	MLM_END                                            = 6
};

// Enum Engine.EngineTypes.EDecalMode
enum class EDecalMode : uint8_t
{
	DECAL_LegacyMeshAttached                           = 0,
	DECAL_ImageSpaceSceneColor                         = 1,
	DECAL_END                                          = 2
};

// Enum Engine.EngineTypes.EBlendMode
enum class EBlendMode : uint8_t
{
	BLEND_Opaque                                       = 0,
	BLEND_Masked                                       = 1,
	BLEND_Translucent                                  = 2,
	BLEND_Additive                                     = 3,
	BLEND_Modulate                                     = 4,
	BLEND_AlphaComposite                               = 5,
	BLEND_END                                          = 6
};

// Enum Engine.LocalMessage.ELocalMessageType
enum class ELocalMessageType : uint8_t
{
	LMT_Training                                       = 0,
	LMT_ContextHint                                    = 1,
	LMT_XP                                             = 2,
	LMT_Player                                         = 3,
	LMT_System                                         = 4,
	LMT_ReceivedLoot                                   = 5,
	LMT_OpenedChest                                    = 6,
	LMT_Chat                                           = 7,
	LMT_CriticalText                                   = 8,
	LMT_MatchEvent                                     = 9,
	LMT_END                                            = 10
};

// Enum Engine.Camera.EViewTargetBlendFunction
enum class EViewTargetBlendFunction : uint8_t
{
	VTBlend_Linear                                     = 0,
	VTBlend_Cubic                                      = 1,
	VTBlend_EaseIn                                     = 2,
	VTBlend_EaseOut                                    = 3,
	VTBlend_EaseInOut                                  = 4,
	VTBlend_END                                        = 5
};

// Enum Engine.DOFEffect.EFocusType
enum class EFocusType : uint8_t
{
	FOCUS_Distance                                     = 0,
	FOCUS_Position                                     = 1,
	FOCUS_END                                          = 2
};

// Enum Engine.SeqAct_ControlMovieTexture.EMovieControlType
enum class EMovieControlType : uint8_t
{
	MCT_Play                                           = 0,
	MCT_Stop                                           = 1,
	MCT_Pause                                          = 2,
	MCT_END                                            = 3
};

// Enum Engine.Camera.ECameraAnimPlaySpace
enum class ECameraAnimPlaySpace : uint8_t
{
	CAPS_CameraLocal                                   = 0,
	CAPS_World                                         = 1,
	CAPS_UserDefined                                   = 2,
	CAPS_END                                           = 3
};

// Enum Engine.AkBank.EBankLoadState
enum class EBankLoadState : uint8_t
{
	BLS_Unloaded                                       = 0,
	BLS_AsyncLoading                                   = 1,
	BLS_Loaded                                         = 2,
	BLS_END                                            = 3
};

// Enum Engine.AkComponent.EAkComponentType
enum class EAkComponentType : uint8_t
{
	AKCT_Standard                                      = 0,
	AKCT_Default                                       = 1,
	AKCT_Pooled                                        = 2,
	AKCT_END                                           = 3
};

// Enum Engine.AkDialogueEvent.EDynamicDialogueArgument
enum class EDynamicDialogueArgument : uint8_t
{
	DYNAMICDIALOGUEARGUMENT_None                       = 0,
	DYNAMICDIALOGUEARGUMENT_SpeakerName                = 1,
	DYNAMICDIALOGUEARGUMENT_Stance                     = 2,
	DYNAMICDIALOGUEARGUMENT_TargetName                 = 3,
	DYNAMICDIALOGUEARGUMENT_END                        = 4
};

// Enum Engine.AmbientOcclusionEffect.EComputeAmbientOcclusionQuality
enum class EComputeAmbientOcclusionQuality : uint8_t
{
	AOCS_VeryLow                                       = 0,
	AOCS_Low                                           = 1,
	AOCS_Medium                                        = 2,
	AOCS_High                                          = 3,
	AOCS_VeryHigh                                      = 4,
	AOCS_END                                           = 5
};

// Enum Engine.AmbientOcclusionEffect.EAmbientOcclusionType
enum class EAmbientOcclusionType : uint8_t
{
	AOType_SSAO                                        = 0,
	AOType_SSAO_ANGLE_BASED                            = 1,
	AOType_HDAO                                        = 2,
	AOType_Compute                                     = 3,
	AOType_END                                         = 4
};

// Enum Engine.AmbientOcclusionEffect.EAmbientOcclusionQuality
enum class EAmbientOcclusionQuality : uint8_t
{
	AO_High                                            = 0,
	AO_Medium                                          = 1,
	AO_Low                                             = 2,
	AO_END                                             = 3
};

// Enum Engine.AnimationCompressionAlgorithm.ValidRotationCompressionFormats
enum class EValidRotationCompressionFormats : uint8_t
{
	PolarEncoded32                                     = 0,
	PolarEncoded48                                     = 1,
	ValidRotationCompressionFormats_END                = 2
};

// Enum Engine.AnimationCompressionAlgorithm.ValidTranslationCompressionFormats
enum class EValidTranslationCompressionFormats : uint8_t
{
	IntervalFixed32NoW                                 = 0,
	ValidTranslationCompressionFormats_END             = 1
};

// Enum Engine.AnimSequence.AnimationKeyFormat
enum class EAnimationKeyFormat : uint8_t
{
	AKF_ConstantKeyLerp                                = 0,
	AKF_VariableKeyLerp                                = 1,
	AKF_PerTrackCompression                            = 2,
	AKF_END                                            = 3
};

// Enum Engine.AnimSequence.AnimationCompressionFormat
enum class EAnimationCompressionFormat : uint8_t
{
	ACF_None                                           = 0,
	ACF_Float96NoW                                     = 1,
	ACF_Fixed48NoW                                     = 2,
	ACF_IntervalFixed32NoW                             = 3,
	ACF_Fixed32NoW                                     = 4,
	ACF_Float32NoW                                     = 5,
	ACF_Delta40NoW                                     = 6,
	ACF_Delta48NoW                                     = 7,
	ACF_Identity                                       = 8,
	ACF_PolarEncoded32                                 = 9,
	ACF_PolarEncoded48                                 = 10,
	ACF_END                                            = 11
};

// Enum Engine.AnimNode.ESliderType
enum class ESliderType : uint8_t
{
	ST_1D                                              = 0,
	ST_2D                                              = 1,
	ST_END                                             = 2
};

// Enum Engine.AnimNodeBlendBase.EBoneBlockRule
enum class EBoneBlockRule : uint8_t
{
	eBoneBlockRule_Include                             = 0,
	eBoneBlockRule_Exclude                             = 1,
	eBoneBlockRule_END                                 = 2
};

// Enum Engine.AnimNodeBlendBase.EBoneBlockLineage
enum class EBoneBlockLineage : uint8_t
{
	eBoneBlockLineage_None                             = 0,
	eBoneBlockLineage_Ancestors                        = 1,
	eBoneBlockLineage_Descendants                      = 2,
	eBoneBlockLineage_END                              = 3
};

// Enum Engine.AnimNodeBlendBase.EAnimBlendMode
enum class EAnimBlendMode : uint8_t
{
	eAnimBlendMode_Local                               = 0,
	eAnimBlendMode_MeshFull                            = 1,
	eAnimBlendMode_InheritFromTree                     = 2,
	eAnimBlendMode_Custom                              = 3,
	eAnimBlendMode_END                                 = 4
};

// Enum Engine.AnimNode_MultiBlendPerBone.EBlendType
enum class EBlendType : uint8_t
{
	EBT_ParentBoneSpace                                = 0,
	EBT_MeshSpace                                      = 1,
	EBT_END                                            = 2
};

// Enum Engine.AnimNode_MultiBlendPerBone.EWeightCheck
enum class EWeightCheck : uint8_t
{
	EWC_AnimNodeSlotNotPlaying                         = 0,
	EWC_END                                            = 1
};

// Enum Engine.AnimNodeAimOffset.EAnimAimDir
enum class EAnimAimDir : uint8_t
{
	ANIMAIM_LEFTUP                                     = 0,
	ANIMAIM_CENTERUP                                   = 1,
	ANIMAIM_RIGHTUP                                    = 2,
	ANIMAIM_LEFTCENTER                                 = 3,
	ANIMAIM_CENTERCENTER                               = 4,
	ANIMAIM_RIGHTCENTER                                = 5,
	ANIMAIM_LEFTDOWN                                   = 6,
	ANIMAIM_CENTERDOWN                                 = 7,
	ANIMAIM_RIGHTDOWN                                  = 8,
	ANIMAIM_END                                        = 9
};

// Enum Engine.AnimNodeAimOffset.EAimID
enum class EAimID : uint8_t
{
	EAID_LeftUp                                        = 0,
	EAID_LeftDown                                      = 1,
	EAID_RightUp                                       = 2,
	EAID_RightDown                                     = 3,
	EAID_ZeroUp                                        = 4,
	EAID_ZeroDown                                      = 5,
	EAID_ZeroLeft                                      = 6,
	EAID_ZeroRight                                     = 7,
	EAID_CellLU                                        = 8,
	EAID_CellCU                                        = 9,
	EAID_CellRU                                        = 10,
	EAID_CellLC                                        = 11,
	EAID_CellCC                                        = 12,
	EAID_CellRC                                        = 13,
	EAID_CellLD                                        = 14,
	EAID_CellCD                                        = 15,
	EAID_CellRD                                        = 16,
	EAID_END                                           = 17
};

// Enum Engine.AnimNodeBlendByBase.EBaseBlendType
enum class EBaseBlendType : uint8_t
{
	BBT_ByActorTag                                     = 0,
	BBT_ByActorClass                                   = 1,
	BBT_END                                            = 2
};

// Enum Engine.AnimNodeSequence.ERootRotationOption
enum class ERootRotationOption : uint8_t
{
	RRO_Default                                        = 0,
	RRO_Discard                                        = 1,
	RRO_Extract                                        = 2,
	RRO_END                                            = 3
};

// Enum Engine.AnimNodeSequence.ERootBoneAxis
enum class ERootBoneAxis : uint8_t
{
	RBA_Default                                        = 0,
	RBA_Discard                                        = 1,
	RBA_Translate                                      = 2,
	RBA_END                                            = 3
};

// Enum Engine.AnimNodeSlot.EFAnimNodeSlot_OnAnimationEnded_Result
enum class EFAnimNodeSlot_OnAnimationEnded_Result : uint8_t
{
	eResult_Stop                                       = 0,
	eResult_Hold                                       = 1,
	eResult_PlayData                                   = 2,
	eResult_END                                        = 3
};

// Enum Engine.MeshComponent.EOutlineStyle
enum class EOutlineStyle : uint8_t
{
	OutlineStyle_None                                  = 0,
	OutlineStyle_Faded                                 = 1,
	OutlineStyle_END                                   = 2
};

// Enum Engine.SkeletalMeshComponent.EPhysBodyOp
enum class EPhysBodyOp : uint8_t
{
	PBO_None                                           = 0,
	PBO_Term                                           = 1,
	PBO_Disable                                        = 2,
	PBO_END                                            = 3
};

// Enum Engine.SkeletalMeshComponent.EBoneVisibilityStatus
enum class EBoneVisibilityStatus : uint8_t
{
	BVS_HiddenByParent                                 = 0,
	BVS_Visible                                        = 1,
	BVS_ExplicitlyHidden                               = 2,
	BVS_END                                            = 3
};

// Enum Engine.SkeletalMeshComponent.EFaceFXRegOp
enum class EFaceFXRegOp : uint8_t
{
	FXRO_Add                                           = 0,
	FXRO_Multiply                                      = 1,
	FXRO_Replace                                       = 2,
	FXRO_END                                           = 3
};

// Enum Engine.SkeletalMeshComponent.EFaceFXBlendMode
enum class EFaceFXBlendMode : uint8_t
{
	FXBM_Overwrite                                     = 0,
	FXBM_Additive                                      = 1,
	FXBM_END                                           = 2
};

// Enum Engine.SkeletalMeshComponent.EAnimRotationOnly
enum class EAnimRotationOnly : uint8_t
{
	EARO_AnimSet                                       = 0,
	EARO_ForceEnabled                                  = 1,
	EARO_ForceDisabled                                 = 2,
	EARO_END                                           = 3
};

// Enum Engine.SkeletalMeshComponent.ERootMotionRotationMode
enum class ERootMotionRotationMode : uint8_t
{
	RMRM_Ignore                                        = 0,
	RMRM_RotateActor                                   = 1,
	RMRM_END                                           = 2
};

// Enum Engine.SkeletalMeshComponent.ERootMotionMode
enum class ERootMotionMode : uint8_t
{
	RMM_Translate                                      = 0,
	RMM_Velocity                                       = 1,
	RMM_Ignore                                         = 2,
	RMM_Accel                                          = 3,
	RMM_Relative                                       = 4,
	RMM_TranslateWithGravity                           = 5,
	RMM_END                                            = 6
};

// Enum Engine.SkeletalMeshComponent.EInstanceWeightUsage
enum class EInstanceWeightUsage : uint8_t
{
	IWU_PartialSwap                                    = 0,
	IWU_FullSwap                                       = 1,
	IWU_END                                            = 2
};

// Enum Engine.SkeletalMeshComponent.EMaxDistanceScaleMode
enum class EMaxDistanceScaleMode : uint8_t
{
	MDSM_Multiply                                      = 0,
	MDSM_Substract                                     = 1,
	MDSM_END                                           = 2
};

// Enum Engine.ITargetable.EChangeStatus
enum class EChangeStatus : uint8_t
{
	CHANGE_Toggle                                      = 0,
	CHANGE_Enable                                      = 1,
	CHANGE_Disable                                     = 2,
	CHANGE_END                                         = 3
};

// Enum Engine.ITargetable.EInfoBarType
enum class EInfoBarType : uint8_t
{
	EIBT_Shield                                        = 0,
	EIBT_Health                                        = 1,
	EIBT_Vehicle                                       = 2,
	EIBT_Minibar                                       = 3,
	EIBT_Energy                                        = 4,
	EIBT_Overshield                                    = 5,
	EIBT_END                                           = 6
};

// Enum Engine.ITargetable.EAutoAimProfile
enum class EAutoAimProfile : uint8_t
{
	AAP_Heavy                                          = 0,
	AAP_Medium                                         = 1,
	AAP_Light                                          = 2,
	AAP_None                                           = 3,
	AAP_END                                            = 4
};

// Enum Engine.DamageTypeDefinition.EDamageType
enum class EDamageType : uint8_t
{
	DAMAGE_TYPE_Unknown                                = 0,
	DAMAGE_TYPE_Incendiary                             = 1,
	DAMAGE_TYPE_Shock                                  = 2,
	DAMAGE_TYPE_Explosive                              = 3,
	DAMAGE_TYPE_Corrosive                              = 4,
	DAMAGE_TYPE_Impact                                 = 5,
	DAMAGE_TYPE_Healing                                = 6,
	DAMAGE_TYPE_Amp                                    = 7,
	DAMAGE_TYPE_PhysicalDamage                         = 8,
	DAMAGE_TYPE_ElementalDamage                        = 9,
	DAMAGE_TYPE_True                                   = 10,
	DAMAGE_TYPE_Shield                                 = 11,
	DAMAGE_TYPE_ShieldHealing                          = 12,
	DAMAGE_TYPE_END                                    = 13
};

// Enum Engine.DynamicLightEnvironmentComponent.EDynamicLightEnvironmentBoundsMethod
enum class EDynamicLightEnvironmentBoundsMethod : uint8_t
{
	DLEB_OwnerComponents                               = 0,
	DLEB_ManualOverride                                = 1,
	DLEB_ActiveComponents                              = 2,
	DLEB_END                                           = 3
};

// Enum Engine.ApexDestructibleAsset.EImpactDamageOverride
enum class EImpactDamageOverride : uint8_t
{
	IDO_None                                           = 0,
	IDO_On                                             = 1,
	IDO_Off                                            = 2,
	IDO_END                                            = 3
};

// Enum Engine.ApexDestructibleDamageParameters.EDamageParameterOverrideMode
enum class EDamageParameterOverrideMode : uint8_t
{
	DPOM_Absolute                                      = 0,
	DPOM_Multiplier                                    = 1,
	DPOM_END                                           = 2
};

// Enum Engine.AttributeDefinitionBase.EAttributeDataType
enum class EAttributeDataType : uint8_t
{
	ADT_Float                                          = 0,
	ADT_Int                                            = 1,
	ADT_Bool                                           = 2,
	ADT_END                                            = 3
};

// Enum Engine.AttributeDefinition.EAttributeTranslationStyle
enum class EAttributeTranslationStyle : uint8_t
{
	ATTRSTYLE_JustNumber                               = 0,
	ATTRSTYLE_ModifierText                             = 1,
	ATTRSTYLE_Debug                                    = 2,
	ATTRSTYLE_LeaveBlank                               = 3,
	ATTRSTYLE_END                                      = 4
};

// Enum Engine.AttributeExpression.EExpressionEvaluationMode
enum class EExpressionEvaluationMode : uint8_t
{
	EXPRMODE_And                                       = 0,
	EXPRMODE_Or                                        = 1,
	EXPRMODE_END                                       = 2
};

// Enum Engine.AttributeExpression.EOperandUsage
enum class EOperandUsage : uint8_t
{
	OPERAND_PreferAttribute                            = 0,
	OPERAND_Multiply                                   = 1,
	OPERAND_END                                        = 2
};

// Enum Engine.AttributeExpression.EComparisonOperator
enum class EComparisonOperator : uint8_t
{
	OPERATOR_EqualTo                                   = 0,
	OPERATOR_NotEqualTo                                = 1,
	OPERATOR_LessThan                                  = 2,
	OPERATOR_LessThanOrEqual                           = 3,
	OPERATOR_GreaterThan                               = 4,
	OPERATOR_GreaterThanOrEqual                        = 5,
	OPERATOR_END                                       = 6
};

// Enum Engine.AttributeInitializationDefinition.EAttributeInitializationRounding
enum class EAttributeInitializationRounding : uint8_t
{
	ATTRROUNDING_Float                                 = 0,
	ATTRROUNDING_IntRound                              = 1,
	ATTRROUNDING_IntFloor                              = 2,
	ATTRROUNDING_IntCeil                               = 3,
	ATTRROUNDING_END                                   = 4
};

// Enum Engine.AttributeInitializationDefinition.EBaseValueMode
enum class EBaseValueMode : uint8_t
{
	BASEVALUE_InitializationDefSetsBaseValue           = 0,
	BASEVALUE_InitializationDefAddsToBaseValue         = 1,
	BASEVALUE_InitializationDefScalesBaseValue         = 2,
	BASEVALUE_InitializationDefOffsetByBaseValue       = 3,
	BASEVALUE_END                                      = 4
};

// Enum Engine.AttributeInitializationDefinition.EConditionalFormulaProcessingOptions
enum class EConditionalFormulaProcessingOptions : uint8_t
{
	CFPO_ProcessEntireFormula                          = 0,
	CFPO_SkipEntireFormula                             = 1,
	CFPO_END                                           = 2
};

// Enum Engine.AttributeInitializationDefinition.EBalanceFormulaProcessingOptions
enum class EBalanceFormulaProcessingOptions : uint8_t
{
	BFPO_ProcessEntireFormula                          = 0,
	BFPO_SkipEntireFormula                             = 1,
	BFPO_END                                           = 2
};

// Enum Engine.AttributeInitializationDefinition.ECoeffecientFormulaProcessingOptions
enum class ECoeffecientFormulaProcessingOptions : uint8_t
{
	COFPO_ProcessEntireFormula                         = 0,
	COFPO_SkipEntireFormula                            = 1,
	COFPO_ProcessBothCoeffecientsMinusBaseValue        = 2,
	COFPO_ProcessCoeffecientOneWithBaseValue           = 3,
	COFPO_ProcessCoeffecientOneWithoutBaseValue        = 4,
	COFPO_ProcessCoeffecientTwoWithBaseValue           = 5,
	COFPO_PrcoessCoeffecientTwoWithoutBaseValue        = 6,
	COFPO_END                                          = 7
};

// Enum Engine.BehaviorBase.EBehaviorContext
enum class EBehaviorContext : uint8_t
{
	BCONTEXT_Self                                      = 0,
	BCONTEXT_MyInstigator                              = 1,
	BCONTEXT_OtherEventParticipant                     = 2,
	BCONTEXT_EventData                                 = 3,
	BCONTEXT_UseContextObject                          = 4,
	BCONTEXT_END                                       = 5
};

// Enum Engine.ICounterBehavior.EBehaviorCounterEvent
enum class EBehaviorCounterEvent : uint8_t
{
	COUNTEREVENT_Counter1AtTarget                      = 0,
	COUNTEREVENT_Counter2AtTarget                      = 1,
	COUNTEREVENT_END                                   = 2
};

// Enum Engine.ICounterBehavior.EBehaviorCounterID
enum class EBehaviorCounterID : uint8_t
{
	BCOUNTER                                           = 0,
	BCOUNTER01                                         = 1,
	BCOUNTER_END                                       = 2
};

// Enum Engine.Behavior_CustomAnimation.EBehaviorCustomAnimationReaction
enum class EBehaviorCustomAnimationReaction : uint8_t
{
	AR_Play                                            = 0,
	AR_Stop                                            = 1,
	AR_END                                             = 2
};

// Enum Engine.Behavior_FollowAllegiance.EFollowAllegiance
enum class EFollowAllegiance : uint8_t
{
	FollowAllegiance_Follow                            = 0,
	FollowAllegiance_Release                           = 1,
	FollowAllegiance_END                               = 2
};

// Enum Engine.IKilledBehavior.EScriptedKillType
enum class EScriptedKillType : uint8_t
{
	KILL_Normal                                        = 0,
	KILL_GibOnly                                       = 1,
	KILL_TechOnly                                      = 2,
	KILL_PreferTech                                    = 3,
	KILL_SpecialDeath1                                 = 4,
	KILL_SpecialDeath2                                 = 5,
	KILL_SpecialDeath3                                 = 6,
	KILL_END                                           = 7
};

// Enum Engine.Behavior_SetPhysics.EBodyAction
enum class EBodyAction : uint8_t
{
	BA_UnfixAllBodies                                  = 0,
	BA_FixAllBodies                                    = 1,
	BA_NoChange                                        = 2,
	BA_END                                             = 3
};

// Enum Engine.Behavior_SetPhysics.ESimulationAction
enum class ESimulationAction : uint8_t
{
	SA_NoChange                                        = 0,
	SA_StartSimulation                                 = 1,
	SA_StopSimulation                                  = 2,
	SA_END                                             = 3
};

// Enum Engine.Behavior_SetPhysics.EPartialRagdollAction
enum class EPartialRagdollAction : uint8_t
{
	PRA_NoChange                                       = 0,
	PRA_Enable                                         = 1,
	PRA_Disable                                        = 2,
	PRA_END                                            = 3
};

// Enum Engine.Brush.ECsgOper
enum class ECsgOper : uint8_t
{
	CSG_Active                                         = 0,
	CSG_Add                                            = 1,
	CSG_Subtract                                       = 2,
	CSG_Intersect                                      = 3,
	CSG_Deintersect                                    = 4,
	CSG_END                                            = 5
};

// Enum Engine.CameraShake.EInitialOscillatorOffset
enum class EInitialOscillatorOffset : uint8_t
{
	EOO_OffsetRandom                                   = 0,
	EOO_OffsetZero                                     = 1,
	EOO_END                                            = 2
};

// Enum Engine.Texture.TextureMipGenSettings
enum class ETextureMipGenSettings : uint8_t
{
	TMGS_FromTextureGroup                              = 0,
	TMGS_SimpleAverage                                 = 1,
	TMGS_Sharpen0                                      = 2,
	TMGS_Sharpen1                                      = 3,
	TMGS_Sharpen2                                      = 4,
	TMGS_Sharpen3                                      = 5,
	TMGS_Sharpen4                                      = 6,
	TMGS_Sharpen5                                      = 7,
	TMGS_Sharpen6                                      = 8,
	TMGS_Sharpen7                                      = 9,
	TMGS_Sharpen8                                      = 10,
	TMGS_Sharpen9                                      = 11,
	TMGS_Sharpen10                                     = 12,
	TMGS_NoMipmaps                                     = 13,
	TMGS_LeaveExistingMips                             = 14,
	TMGS_Blur1                                         = 15,
	TMGS_Blur2                                         = 16,
	TMGS_Blur3                                         = 17,
	TMGS_Blur4                                         = 18,
	TMGS_Blur5                                         = 19,
	TMGS_END                                           = 20
};

// Enum Engine.Texture.TextureCompressionSettings
enum class ETextureCompressionSettings : uint8_t
{
	TC_Default                                         = 0,
	TC_Normalmap                                       = 1,
	TC_Displacementmap                                 = 2,
	TC_NormalmapAlpha                                  = 3,
	TC_Grayscale                                       = 4,
	TC_HighDynamicRange                                = 5,
	TC_OneBitAlpha                                     = 6,
	TC_NormalmapBC5                                    = 7,
	TC_OneBitMonochrome                                = 8,
	TC_SimpleLightmapModification                      = 9,
	TC_VectorDisplacementmap                           = 10,
	TC_END                                             = 11
};

// Enum Engine.Texture.TextureGroup
enum class ETextureGroup : uint8_t
{
	TEXTUREGROUP_Default                               = 0,
	TEXTUREGROUP_World                                 = 1,
	TEXTUREGROUP_WorldNormalMap                        = 2,
	TEXTUREGROUP_WorldSpecular                         = 3,
	TEXTUREGROUP_WorldMasks                            = 4,
	TEXTUREGROUP_Character                             = 5,
	TEXTUREGROUP_CharacterNormalMap                    = 6,
	TEXTUREGROUP_CharacterSpecular                     = 7,
	TEXTUREGROUP_CharacterMasks                        = 8,
	TEXTUREGROUP_NPC                                   = 9,
	TEXTUREGROUP_NPCNormalMap                          = 10,
	TEXTUREGROUP_NPCSpecular                           = 11,
	TEXTUREGROUP_NPCMasks                              = 12,
	TEXTUREGROUP_Weapon                                = 13,
	TEXTUREGROUP_WeaponNormalMap                       = 14,
	TEXTUREGROUP_WeaponSpecular                        = 15,
	TEXTUREGROUP_WeaponMasks                           = 16,
	TEXTUREGROUP_Vehicle                               = 17,
	TEXTUREGROUP_VehicleNormalMap                      = 18,
	TEXTUREGROUP_VehicleSpecular                       = 19,
	TEXTUREGROUP_VehicleMasks                          = 20,
	TEXTUREGROUP_Cinematic                             = 21,
	TEXTUREGROUP_Effects                               = 22,
	TEXTUREGROUP_EffectsCharacter                      = 23,
	TEXTUREGROUP_EffectsEnvironment                    = 24,
	TEXTUREGROUP_Skybox                                = 25,
	TEXTUREGROUP_UI                                    = 26,
	TEXTUREGROUP_Lightmap                              = 27,
	TEXTUREGROUP_RenderTarget                          = 28,
	TEXTUREGROUP_Shadowmap                             = 29,
	TEXTUREGROUP_ColorLookupTable                      = 30,
	TEXTUREGROUP_Terrain_Heightmap                     = 31,
	TEXTUREGROUP_Terrain_Weightmap                     = 32,
	TEXTUREGROUP_Editor                                = 33,
	TEXTUREGROUP_HeroWorld                             = 34,
	TEXTUREGROUP_HeroCharacter                         = 35,
	TEXTUREGROUP_HeroNPC                               = 36,
	TEXTUREGROUP_HeroWeapon                            = 37,
	TEXTUREGROUP_HeroVehicle                           = 38,
	TEXTUREGROUP_HeroEffects                           = 39,
	TEXTUREGROUP_Cubemap                               = 40,
	TEXTUREGROUP_END                                   = 41
};

// Enum Engine.Texture.TextureAddress
enum class ETextureAddress : uint8_t
{
	TA_Wrap                                            = 0,
	TA_Clamp                                           = 1,
	TA_Mirror                                          = 2,
	TA_MirrorOnce                                      = 3,
	TA_END                                             = 4
};

// Enum Engine.Texture.ETextureTypeChoice
enum class ETextureTypeChoice : uint8_t
{
	TTC_Uncompressed                                   = 0,
	TTC_BC7_Color                                      = 1,
	TTC_BC7_Normal                                     = 2,
	TTC_BC7_Normal_RG                                  = 3,
	TTC_BC1                                            = 4,
	TTC_BC1a                                           = 5,
	TTC_BC6                                            = 6,
	TTC_END                                            = 7
};

// Enum Engine.Texture.ETextureMipCount
enum class ETextureMipCount : uint8_t
{
	TMC_ResidentMips                                   = 0,
	TMC_AllMips                                        = 1,
	TMC_AllMipsBiased                                  = 2,
	TMC_END                                            = 3
};

// Enum Engine.Texture.TextureFilter
enum class ETextureFilter : uint8_t
{
	TF_Nearest                                         = 0,
	TF_Linear                                          = 1,
	TF_END                                             = 2
};

// Enum Engine.Texture.EPixelFormat
enum class EPixelFormat : uint8_t
{
	LEGACY_PF_Unknown                                  = 0,
	LEGACY_PF_A32B32G32R32F                            = 1,
	LEGACY_PF_A8R8G8B8                                 = 2,
	LEGACY_PF_G8                                       = 3,
	LEGACY_PF_G16                                      = 4,
	LEGACY_PF_DXT1                                     = 5,
	LEGACY_PF_DXT3                                     = 6,
	LEGACY_PF_DXT5                                     = 7,
	LEGACY_PF_UYVY                                     = 8,
	LEGACY_PF_FloatRGB                                 = 9,
	LEGACY_PF_FloatRGBA                                = 10,
	LEGACY_PF_DepthStencil                             = 11,
	LEGACY_PF_ShadowDepth                              = 12,
	LEGACY_PF_FilteredShadowDepth                      = 13,
	LEGACY_PF_R32F                                     = 14,
	LEGACY_PF_G16R16                                   = 15,
	LEGACY_PF_G16R16F                                  = 16,
	LEGACY_PF_G16R16F_FILTER                           = 17,
	LEGACY_PF_G32R32F                                  = 18,
	LEGACY_PF_A2B10G10R10                              = 19,
	LEGACY_PF_A16B16G16R16                             = 20,
	LEGACY_PF_D24                                      = 21,
	LEGACY_PF_R16F                                     = 22,
	LEGACY_PF_R16F_FILTER                              = 23,
	LEGACY_PF_BC5                                      = 24,
	LEGACY_PF_V8U8                                     = 25,
	LEGACY_PF_A1                                       = 26,
	LEGACY_PF_FloatR11G11B10                           = 27,
	LEGACY_PF_END                                      = 28
};

// Enum Engine.UIRoot.EUIDataProviderFieldType
enum class EUIDataProviderFieldType : uint8_t
{
	DATATYPE_Property                                  = 0,
	DATATYPE_Provider                                  = 1,
	DATATYPE_RangeProperty                             = 2,
	DATATYPE_Collection                                = 3,
	DATATYPE_ProviderCollection                        = 4,
	DATATYPE_END                                       = 5
};

// Enum Engine.MaterialInterface.EMaterialUsage
enum class EMaterialUsage : uint8_t
{
	MATUSAGE_SkeletalMesh                              = 0,
	MATUSAGE_ParticleSprites                           = 1,
	MATUSAGE_BeamTrails                                = 2,
	MATUSAGE_ParticleSubUV                             = 3,
	MATUSAGE_Foliage                                   = 4,
	MATUSAGE_StaticLighting                            = 5,
	MATUSAGE_LensFlare                                 = 6,
	MATUSAGE_InstancedMeshParticles                    = 7,
	MATUSAGE_Decals                                    = 8,
	MATUSAGE_MaterialEffect                            = 9,
	MATUSAGE_MorphTargets                              = 10,
	MATUSAGE_FogVolumes                                = 11,
	MATUSAGE_RadialBlur                                = 12,
	MATUSAGE_InstancedMeshes                           = 13,
	MATUSAGE_SplineMesh                                = 14,
	MATUSAGE_APEXMesh                                  = 15,
	MATUSAGE_Terrain                                   = 16,
	MATUSAGE_SPHFluid                                  = 17,
	MATUSAGE_RealtimeShatter                           = 18,
	MATUSAGE_END                                       = 19
};

// Enum Engine.Material.EParticleDownsampling
enum class EParticleDownsampling : uint8_t
{
	PDS_Full                                           = 0,
	PDS_Half                                           = 1,
	PDS_Quarter                                        = 2,
	PDS_END                                            = 3
};

// Enum Engine.Material.EMaterialInputType
enum class EMaterialInputType : uint8_t
{
	MIDT_Float1                                        = 0,
	MIDT_Float2                                        = 1,
	MIDT_Float3                                        = 2,
	MIDT_Float4                                        = 3,
	MIDT_Bool                                          = 4,
	MIDT_Int1                                          = 5,
	MIDT_END                                           = 6
};

// Enum Engine.CoverGroup.ECoverGroupFillAction
enum class ECoverGroupFillAction : uint8_t
{
	CGFA_Overwrite                                     = 0,
	CGFA_Add                                           = 1,
	CGFA_Remove                                        = 2,
	CGFA_Clear                                         = 3,
	CGFA_Cylinder                                      = 4,
	CGFA_END                                           = 5
};

// Enum Engine.CoverSlotComponent.ECoverType
enum class ECoverType : uint8_t
{
	CT_None                                            = 0,
	CT_Standing                                        = 1,
	CT_MidLevel                                        = 2,
	CT_END                                             = 3
};

// Enum Engine.CoverTag.ECoverAction
enum class ECoverAction : uint8_t
{
	CA_LeanLeft                                        = 0,
	CA_LeanRight                                       = 1,
	CA_PopUp                                           = 2,
	CA_END                                             = 3
};

// Enum Engine.GBXPipeline.ERewardMessageType
enum class ERewardMessageType : uint8_t
{
	RMT_None                                           = 0,
	RMT_Killer                                         = 1,
	RMT_Assist                                         = 2,
	RMT_MasterKill                                     = 3,
	RMT_MasterAssist                                   = 4,
	RMT_Generic                                        = 5,
	RMT_END                                            = 6
};

// Enum Engine.GBXPipeline.ECriticalHitFilterType
enum class ECriticalHitFilterType : uint8_t
{
	CHFT_NoFilter                                      = 0,
	CHFT_OnlyCrits                                     = 1,
	CHFT_NoCrits                                       = 2,
	CHFT_END                                           = 3
};

// Enum Engine.GBXPipeline.EAttackerDefenderFilterType
enum class EAttackerDefenderFilterType : uint8_t
{
	ADFT_NoFilter                                      = 0,
	ADFT_Attacker                                      = 1,
	ADFT_Defender                                      = 2,
	ADFT_END                                           = 3
};

// Enum Engine.DamagePipeline.EBulletFromClip
enum class EBulletFromClip : uint8_t
{
	BFC_Other                                          = 0,
	BFC_First                                          = 1,
	BFC_Last                                           = 2,
	BFC_END                                            = 3
};

// Enum Engine.DamagePipeline.EReflectionType
enum class EReflectionType : uint8_t
{
	REFLT_None                                         = 0,
	REFLT_Instigator                                   = 1,
	REFLT_Self                                         = 2,
	REFLT_END                                          = 3
};

// Enum Engine.DamagePipeline.EDamageSkillEventType
enum class EDamageSkillEventType : uint8_t
{
	DSET_DamageTaken                                   = 0,
	DSET_DamageDealt                                   = 1,
	DSET_END                                           = 2
};

// Enum Engine.DecalComponent.EFilterMode
enum class EFilterMode : uint8_t
{
	FM_None                                            = 0,
	FM_Ignore                                          = 1,
	FM_Affect                                          = 2,
	FM_END                                             = 3
};

// Enum Engine.DecalComponent.EDecalTransform
enum class EDecalTransform : uint8_t
{
	DecalTransform_OwnerAbsolute                       = 0,
	DecalTransform_OwnerRelative                       = 1,
	DecalTransform_SpawnRelative                       = 2,
	DecalTransform_END                                 = 3
};

// Enum Engine.DistributionFloatParameterBase.DistributionParamMode
enum class EDistributionParamMode : uint8_t
{
	DPM_Normal                                         = 0,
	DPM_Abs                                            = 1,
	DPM_Direct                                         = 2,
	DPM_END                                            = 3
};

// Enum Engine.DOFAndBloomEffect.EDOFQuality
enum class EDOFQuality : uint8_t
{
	DOFQuality_Low                                     = 0,
	DOFQuality_Medium                                  = 1,
	DOFQuality_High                                    = 2,
	DOFQuality_END                                     = 3
};

// Enum Engine.DOFAndBloomEffect.EDOFType
enum class EDOFType : uint8_t
{
	DOFType_SimpleDOF                                  = 0,
	DOFType_Off                                        = 1,
	DOFType_END                                        = 2
};

// Enum Engine.DownloadableContentEnumerator.EDlcEnumerationState
enum class EDlcEnumerationState : uint8_t
{
	DLC_ENUM_None                                      = 0,
	DLC_ENUM_EnumeratingFiles                          = 1,
	DLC_ENUM_EnumerationComplete                       = 2,
	DLC_ENUM_END                                       = 3
};

// Enum Engine.DownloadableContentManager.EInstalledContentType
enum class EInstalledContentType : uint8_t
{
	INSTALLED_CONTENT_TYPE_UnNamed                     = 0,
	INSTALLED_CONTENT_TYPE_Named                       = 1,
	INSTALLED_CONTENT_TYPE_Compatibility               = 2,
	INSTALLED_CONTENT_TYPE_SeasonPass                  = 3,
	INSTALLED_CONTENT_TYPE_PreorderBonus               = 4,
	INSTALLED_CONTENT_TYPE_CompatibilityPackContainer  = 5,
	INSTALLED_CONTENT_TYPE_END                         = 6
};

// Enum Engine.DownloadableContentOfferEnumerator.EDlcOfferEnumerationState
enum class EDlcOfferEnumerationState : uint8_t
{
	DLC_OFFER_ENUM_None                                = 0,
	DLC_OFFER_ENUM_EnumeratingOffers                   = 1,
	DLC_OFFER_ENUM_EnumerationComplete                 = 2,
	DLC_OFFER_ENUM_END                                 = 3
};

// Enum Engine.DownloadableContentManager.EInstallDLCResult
enum class EInstallDLCResult : uint8_t
{
	INSTALLDLC_RES_Success                             = 0,
	INSTALLDLC_RES_InvalidNameInfo                     = 1,
	INSTALLDLC_RES_InvalidEngineVersion                = 2,
	INSTALLDLC_RES_CookedGuidMismatch                  = 3,
	INSTALLDLC_RES_CorruptContent                      = 4,
	INSTALLDLC_RES_UnknownFailure                      = 5,
	INSTALLDLC_RES_CannotInstallCompatibility          = 6,
	INSTALLDLC_RES_CompabitilityContentNotInstalled    = 7,
	INSTALLDLC_RES_UnlicensedNamedContent              = 8,
	INSTALLDLC_RES_END                                 = 9
};

// Enum Engine.Emitter.EEmitterBeamAttachmentType
enum class EEmitterBeamAttachmentType : uint8_t
{
	EBAT_None                                          = 0,
	EBAT_Location                                      = 1,
	EBAT_Actor                                         = 2,
	EBAT_Socket                                        = 3,
	EBAT_Component                                     = 4,
	EBAT_END                                           = 5
};

// Enum Engine.ParticleSystemComponent.EParticleEventType
enum class EParticleEventType : uint8_t
{
	EPET_Any                                           = 0,
	EPET_Spawn                                         = 1,
	EPET_Death                                         = 2,
	EPET_Collision                                     = 3,
	EPET_Kismet                                        = 4,
	EPET_Trace                                         = 5,
	EPET_Construct                                     = 6,
	EPET_END                                           = 7
};

// Enum Engine.ParticleSystemComponent.EParticleSysParamType
enum class EParticleSysParamType : uint8_t
{
	PSPT_None                                          = 0,
	PSPT_Scalar                                        = 1,
	PSPT_ScalarRand                                    = 2,
	PSPT_Vector                                        = 3,
	PSPT_VectorRand                                    = 4,
	PSPT_Color                                         = 5,
	PSPT_Actor                                         = 6,
	PSPT_Material                                      = 7,
	PSPT_END                                           = 8
};

// Enum Engine.ParticleSystem.EParticleSystemOcclusionBoundsMethod
enum class EParticleSystemOcclusionBoundsMethod : uint8_t
{
	EPSOBM_None                                        = 0,
	EPSOBM_ParticleBounds                              = 1,
	EPSOBM_CustomBounds                                = 2,
	EPSOBM_END                                         = 3
};

// Enum Engine.ParticleSystem.ParticleSystemLODMethod
enum class EParticleSystemLODMethod : uint8_t
{
	PARTICLESYSTEMLODMETHOD_Automatic                  = 0,
	PARTICLESYSTEMLODMETHOD_DirectSet                  = 1,
	PARTICLESYSTEMLODMETHOD_ActivateAutomatic          = 2,
	PARTICLESYSTEMLODMETHOD_END                        = 3
};

// Enum Engine.ParticleSystem.EParticleSystemUpdateMode
enum class EParticleSystemUpdateMode : uint8_t
{
	EPSUM_RealTime                                     = 0,
	EPSUM_FixedTime                                    = 1,
	EPSUM_HighFidelity                                 = 2,
	EPSUM_FrozenTime                                   = 3,
	EPSUM_END                                          = 4
};

// Enum Engine.Engine.ETransitionType
enum class ETransitionType : uint8_t
{
	TT_None                                            = 0,
	TT_Paused                                          = 1,
	TT_Loading                                         = 2,
	TT_Saving                                          = 3,
	TT_Connecting                                      = 4,
	TT_Precaching                                      = 5,
	TT_END                                             = 6
};

// Enum Engine.FontImportOptions.EFontImportCharacterSet
enum class EFontImportCharacterSet : uint8_t
{
	FontICS_Default                                    = 0,
	FontICS_Ansi                                       = 1,
	FontICS_Symbol                                     = 2,
	FontICS_END                                        = 3
};

// Enum Engine.FileWriter.FWFileType
enum class EFWFileType : uint8_t
{
	FWFT_Log                                           = 0,
	FWFT_Stats                                         = 1,
	FWFT_HTML                                          = 2,
	FWFT_User                                          = 3,
	FWFT_Debug                                         = 4,
	FWFT_END                                           = 5
};

// Enum Engine.ForceFeedbackWaveform.EWaveformFunction
enum class EWaveformFunction : uint8_t
{
	WF_Constant                                        = 0,
	WF_LinearIncreasing                                = 1,
	WF_LinearDecreasing                                = 2,
	WF_Sin0to90                                        = 3,
	WF_Sin90to180                                      = 4,
	WF_Sin0to180                                       = 5,
	WF_Noise                                           = 6,
	WF_END                                             = 7
};

// Enum Engine.ForceFeedbackWaveform.EWaveformTarget
enum class EWaveformTarget : uint8_t
{
	WFTARG_Standard                                    = 0,
	WFTARG_ImpulseTriggers                             = 1,
	WFTARG_ImpulseTriggersOrStandard                   = 2,
	WFTARG_END                                         = 3
};

// Enum Engine.GameEngine.EFullyLoadPackageType
enum class EFullyLoadPackageType : uint8_t
{
	FULLYLOAD_Map                                      = 0,
	FULLYLOAD_Game_PreLoadClass                        = 1,
	FULLYLOAD_Game_PostLoadClass                       = 2,
	FULLYLOAD_Always                                   = 3,
	FULLYLOAD_Mutator                                  = 4,
	FULLYLOAD_GID                                      = 5,
	FULLYLOAD_END                                      = 6
};

// Enum Engine.GameEngine.ELoadingMovieState
enum class ELoadingMovieState : uint8_t
{
	LOADINGMOVIE_NotPlaying                            = 0,
	LOADINGMOVIE_Playing                               = 1,
	LOADINGMOVIE_Stopping                              = 2,
	LOADINGMOVIE_END                                   = 3
};

// Enum Engine.GameInfo.EStandbyType
enum class EStandbyType : uint8_t
{
	STDBY_Rx                                           = 0,
	STDBY_Tx                                           = 1,
	STDBY_BadPing                                      = 2,
	STDBY_END                                          = 3
};

// Enum Engine.MusicTrackDataStructures.EMusicState
enum class EMusicState : uint8_t
{
	MUSIC_PlayingAmbientMusic                          = 0,
	MUSIC_PlayingCustomAmbientMusic                    = 1,
	MUSIC_PlayingCombatMusicFull                       = 2,
	MUSIC_PlayingCombatMusicMid                        = 3,
	MUSIC_PlayingBossMusic                             = 4,
	MUSIC_PlayingCustomCombatMusic                     = 5,
	MUSIC_END                                          = 6
};

// Enum Engine.WorldInfo.EVisibilityAggressiveness
enum class EVisibilityAggressiveness : uint8_t
{
	VIS_LeastAggressive                                = 0,
	VIS_ModeratelyAggressive                           = 1,
	VIS_MostAggressive                                 = 2,
	VIS_Max                                            = 3
};

// Enum Engine.WorldInfo.ENetMode
enum class ENetMode : uint8_t
{
	NM_Standalone                                      = 0,
	NM_DedicatedServer                                 = 1,
	NM_ListenServer                                    = 2,
	NM_Client                                          = 3,
	NM_END                                             = 4
};

// Enum Engine.GameViewportClient.EAspectRatio
enum class EAspectRatio : uint8_t
{
	ASPECTRATIOCATEGORY_NOVIEWPORT                     = 0,
	ASPECTRATIOCATEGORY_4X3                            = 1,
	ASPECTRATIOCATEGORY_16X9                           = 2,
	ASPECTRATIOCATEGORY_16X10                          = 3,
	ASPECTRATIOCATEGORY_END                            = 4
};

// Enum Engine.GameViewportClient.ESafeZoneType
enum class ESafeZoneType : uint8_t
{
	eSZ_TOP                                            = 0,
	eSZ_BOTTOM                                         = 1,
	eSZ_LEFT                                           = 2,
	eSZ_RIGHT                                          = 3,
	eSZ_END                                            = 4
};

// Enum Engine.GameViewportClient.ESplitScreenType
enum class ESplitScreenType : uint8_t
{
	eSST_NONE                                          = 0,
	eSST_2P_HORIZONTAL                                 = 1,
	eSST_2P_VERTICAL                                   = 2,
	eSST_3P_FAVOR_TOP                                  = 3,
	eSST_3P_FAVOR_BOTTOM                               = 4,
	eSST_3P_FAVOR_LEFT                                 = 5,
	eSST_3P_FAVOR_RIGHT                                = 6,
	eSST_4P                                            = 7,
	eSST_END                                           = 8
};

// Enum Engine.ResourcePool.EResourcePoolState
enum class EResourcePoolState : uint8_t
{
	RPS_Depleted                                       = 0,
	RPS_Filled                                         = 1,
	RPS_Regenerating                                   = 2,
	RPS_END                                            = 3
};

// Enum Engine.IBodyCompositionInstance.EBodySwitchAuthority
enum class EBodySwitchAuthority : uint8_t
{
	BSA_Server                                         = 0,
	BSA_Owner                                          = 1,
	BSA_Local                                          = 2,
	BSA_END                                            = 3
};

// Enum Engine.IBodyCompositionInstance.EBodyApplicationMode
enum class EBodyApplicationMode : uint8_t
{
	EBCAM_Game                                         = 0,
	EBCAM_EditorPreview                                = 1,
	EBCAM_Foreground                                   = 2,
	EBCAM_Frontend                                     = 3,
	EBCAM_BackMenu                                     = 4,
	EBCAM_BackMenuInspection                           = 5,
	EBCAM_END                                          = 6
};

// Enum Engine.IGBXNavMeshObstacle.EObstacleCollisionType
enum class EObstacleCollisionType : uint8_t
{
	EOCT_ModifyNavMesh                                 = 0,
	EOCT_BuildThrough                                  = 1,
	EOCT_BuildAround                                   = 2,
	EOCT_END                                           = 3
};

// Enum Engine.IGBXNavMeshSpecialMove.GBXNavMeshSpecialMoveType
enum class EGBXNavMeshSpecialMoveType : uint8_t
{
	GBXNAVSPECIALMOVE_None                             = 0,
	GBXNAVSPECIALMOVE_WaitForPathObject                = 1,
	GBXNAVSPECIALMOVE_ForceMoveToDestination           = 2,
	GBXNAVSPECIALMOVE_END                              = 3
};

// Enum Engine.IInstanceData.EBodyAttachmentEvent
enum class EBodyAttachmentEvent : uint8_t
{
	BODYEVENT_Attach                                   = 0,
	BODYEVENT_Detach                                   = 1,
	BODYEVENT_END                                      = 2
};

// Enum Engine.InterpGroupAI.InterpGroupAlignmentTypes
enum class EInterpGroupAlignmentTypes : uint8_t
{
	IGAT_None                                          = 0,
	IGAT_Teleport                                      = 1,
	IGAT_Lerp                                          = 2,
	IGAT_END                                           = 3
};

// Enum Engine.InterpTrack.ETrackPlayDirection
enum class ETrackPlayDirection : uint8_t
{
	ETPD_PlayBoth                                      = 0,
	ETPD_PlayOnlyForward                               = 1,
	ETPD_PlayOnlyReverse                               = 2,
	ETPD_END                                           = 3
};

// Enum Engine.InterpTrack.ETrackActiveCondition
enum class ETrackActiveCondition : uint8_t
{
	ETAC_Always                                        = 0,
	ETAC_GoreEnabled                                   = 1,
	ETAC_GoreDisabled                                  = 2,
	ETAC_END                                           = 3
};

// Enum Engine.InterpTrackHeadTracking.EHeadTrackingAction
enum class EHeadTrackingAction : uint8_t
{
	EHTA_DisableHeadTracking                           = 0,
	EHTA_EnableHeadTracking                            = 1,
	EHTA_END                                           = 2
};

// Enum Engine.InterpTrackToggle.ETrackToggleAction
enum class ETrackToggleAction : uint8_t
{
	ETTA_Off                                           = 0,
	ETTA_On                                            = 1,
	ETTA_Toggle                                        = 2,
	ETTA_Trigger                                       = 3,
	ETTA_END                                           = 4
};

// Enum Engine.InterpTrackVisibility.EVisibilityTrackCondition
enum class EVisibilityTrackCondition : uint8_t
{
	EVTC_Always                                        = 0,
	EVTC_GoreEnabled                                   = 1,
	EVTC_GoreDisabled                                  = 2,
	EVTC_END                                           = 3
};

// Enum Engine.InterpTrackVisibility.EVisibilityTrackAction
enum class EVisibilityTrackAction : uint8_t
{
	EVTA_Hide                                          = 0,
	EVTA_Show                                          = 1,
	EVTA_Toggle                                        = 2,
	EVTA_END                                           = 3
};

// Enum Engine.InterpTrackMove.EInterpTrackMoveRotMode
enum class EInterpTrackMoveRotMode : uint8_t
{
	IMR_Keyframed                                      = 0,
	IMR_LookAtGroup                                    = 1,
	IMR_Ignore                                         = 2,
	IMR_END                                            = 3
};

// Enum Engine.InterpTrackMove.EInterpTrackMoveFrame
enum class EInterpTrackMoveFrame : uint8_t
{
	IMF_World                                          = 0,
	IMF_RelativeToInitial                              = 1,
	IMF_END                                            = 2
};

// Enum Engine.InterpTrackMoveAxis.EInterpMoveAxis
enum class EInterpMoveAxis : uint8_t
{
	AXIS_TranslationX                                  = 0,
	AXIS_TranslationY                                  = 1,
	AXIS_TranslationZ                                  = 2,
	AXIS_RotationX                                     = 3,
	AXIS_RotationY                                     = 4,
	AXIS_RotationZ                                     = 5,
	AXIS_END                                           = 6
};

// Enum Engine.LevelGridVolume.LevelGridCellShape
enum class ELevelGridCellShape : uint8_t
{
	LGCS_Box                                           = 0,
	LGCS_Hex                                           = 1,
	LGCS_END                                           = 2
};

// Enum Engine.LevelLandmark.ELandmarkType
enum class ELandmarkType : uint8_t
{
	LANDMARK_Custom                                    = 0,
	LANDMARK_Transition                                = 1,
	LANDMARK_END                                       = 2
};

// Enum Engine.LevelStreamingVolume.ECurrentVisibility
enum class ECurrentVisibility : uint8_t
{
	ECV_NotUpdated                                     = 0,
	ECV_Encompasses                                    = 1,
	ECV_NotEncompasses                                 = 2,
	ECV_Disabled                                       = 3,
	ECV_END                                            = 4
};

// Enum Engine.LevelStreamingVolume.EStreamingVolumeUsage
enum class EStreamingVolumeUsage : uint8_t
{
	SVB_Loading                                        = 0,
	SVB_LoadingAndVisibility                           = 1,
	SVB_VisibilityBlockingOnLoad                       = 2,
	SVB_BlockingOnLoad                                 = 3,
	SVB_LoadingNotVisible                              = 4,
	SVB_END                                            = 5
};

// Enum Engine.LineData.ELineEditMode
enum class ELineEditMode : uint8_t
{
	LEM_Cover                                          = 0,
	LEM_SI                                             = 1,
	LEM_END                                            = 2
};

// Enum Engine.LineSegment.ELineSegmentType
enum class ELineSegmentType : uint8_t
{
	LSTY_Cover                                         = 0,
	LSTY_CoverLink                                     = 1,
	LSTY_SIZone                                        = 2,
	LSTY_SIRetreat                                     = 3,
	LSTY_SICombatZone                                  = 4,
	LSTY_SIStealth                                     = 5,
	LSTY_END                                           = 6
};

// Enum Engine.LineSegment.ELineSegmentMaterial
enum class ELineSegmentMaterial : uint8_t
{
	LSM_Default                                        = 0,
	LSM_Vulnerable                                     = 1,
	LSM_Vantage                                        = 2,
	LSM_END                                            = 3
};

// Enum Engine.MaterialExpression.EMaterialTextureFilter
enum class EMaterialTextureFilter : uint8_t
{
	MTF_MIN_MAG_MIP_POINT                              = 0,
	MTF_MIN_MAG_POINT_MIP_LINEAR                       = 1,
	MTF_MIN_POINT_MAG_LINEAR_MIP_POINT                 = 2,
	MTF_MIN_POINT_MAG_MIP_LINEAR                       = 3,
	MTF_MIN_LINEAR_MAG_MIP_POINT                       = 4,
	MTF_MIN_LINEAR_MAG_POINT_MIP_LINEAR                = 5,
	MTF_MIN_MAG_LINEAR_MIP_POINT                       = 6,
	MTF_MIN_MAG_MIP_LINEAR                             = 7,
	MTF_ANISOTROPIC                                    = 8,
	MTF_END                                            = 9
};

// Enum Engine.MaterialExpression.EMaterialTextureAddress
enum class EMaterialTextureAddress : uint8_t
{
	MTA_Wrap                                           = 0,
	MTA_Clamp                                          = 1,
	MTA_Mirror                                         = 2,
	MTA_MirrorOnce                                     = 3,
	MTA_END                                            = 4
};

// Enum Engine.MaterialExpression.ETextureSampleSamplerConfiguration
enum class ETextureSampleSamplerConfiguration : uint8_t
{
	TSSC_Point_Clamp                                   = 0,
	TSSC_Point_Wrap                                    = 1,
	TSSC_Trilinear_Clamp                               = 2,
	TSSC_Trilinear_Wrap                                = 3,
	TSSC_Aniso_Clamp                                   = 4,
	TSSC_Aniso_Wrap                                    = 5,
	TSSC_END                                           = 6
};

// Enum Engine.MaterialExpression.ETextureSampleColorTransform
enum class ETextureSampleColorTransform : uint8_t
{
	TSCT_Identity                                      = 0,
	TSCT_UnpackNormal                                  = 1,
	TSCT_END                                           = 2
};

// Enum Engine.MaterialExpression.ECompareType
enum class ECompareType : uint8_t
{
	CMP_Greater                                        = 0,
	CMP_GreaterEqual                                   = 1,
	CMP_Less                                           = 2,
	CMP_LessEqual                                      = 3,
	CMP_Equal                                          = 4,
	CMP_NotEqual                                       = 5,
	CMP_END                                            = 6
};

// Enum Engine.MaterialExpressionAntialiasedTextureMask.ETextureColorChannel
enum class ETextureColorChannel : uint8_t
{
	TCC_Red                                            = 0,
	TCC_Green                                          = 1,
	TCC_Blue                                           = 2,
	TCC_Alpha                                          = 3,
	TCC_END                                            = 4
};

// Enum Engine.MaterialExpressionCustom.ECustomMaterialOutputType
enum class ECustomMaterialOutputType : uint8_t
{
	CMOT_Float1                                        = 0,
	CMOT_Float2                                        = 1,
	CMOT_Float3                                        = 2,
	CMOT_Float4                                        = 3,
	CMOT_Bool                                          = 4,
	CMOT_Int1                                          = 5,
	CMOT_Int2                                          = 6,
	CMOT_Int3                                          = 7,
	CMOT_Int4                                          = 8,
	CMOT_END                                           = 9
};

// Enum Engine.MaterialExpressionDepthOfFieldFunction.EDepthOfFieldFunctionValue
enum class EDepthOfFieldFunctionValue : uint8_t
{
	TDOF_NearAndFarMask                                = 0,
	TDOF_NearMask                                      = 1,
	TDOF_FarMask                                       = 2,
	TDOF_END                                           = 3
};

// Enum Engine.MaterialExpressionFunctionInput.EFunctionInputType
enum class EFunctionInputType : uint8_t
{
	FunctionInput_Float                                = 0,
	FunctionInput_Float2                               = 1,
	FunctionInput_Float3                               = 2,
	FunctionInput_Float4                               = 3,
	FunctionInput_Texture2D                            = 4,
	FunctionInput_Texture3D                            = 5,
	FunctionInput_TextureCube                          = 6,
	FunctionInput_StaticBool                           = 7,
	FunctionInput_Sampler                              = 8,
	FunctionInput_Int1                                 = 9,
	FunctionInput_Int2                                 = 10,
	FunctionInput_Int3                                 = 11,
	FunctionInput_Int4                                 = 12,
	FunctionInput_END                                  = 13
};

// Enum Engine.MaterialExpressionGradient.EGradientStyle
enum class EGradientStyle : uint8_t
{
	GRADIENT_Linear                                    = 0,
	GRADIENT_Radial                                    = 1,
	GRADIENT_Reflected                                 = 2,
	GRADIENT_END                                       = 3
};

// Enum Engine.MaterialExpressionSceneTexture.ESceneTextureType
enum class ESceneTextureType : uint8_t
{
	SceneTex_Lighting                                  = 0,
	SceneTex_END                                       = 1
};

// Enum Engine.MaterialExpressionTeamIndex.ETeamDataSource
enum class ETeamDataSource : uint8_t
{
	TDS_View                                           = 0,
	TDS_Primitive                                      = 1,
	TDS_END                                            = 2
};

// Enum Engine.MaterialExpressionTerrainLayerCoords.ETerrainCoordMappingType
enum class ETerrainCoordMappingType : uint8_t
{
	TCMT_Auto                                          = 0,
	TCMT_XY                                            = 1,
	TCMT_XZ                                            = 2,
	TCMT_YZ                                            = 3,
	TCMT_END                                           = 4
};

// Enum Engine.MaterialExpressionTerrainTextureCoordinate.ETerrainMaterialProjectionType
enum class ETerrainMaterialProjectionType : uint8_t
{
	TMPT_XY                                            = 0,
	TMPT_XZ                                            = 1,
	TMPT_YZ                                            = 2,
	TMPT_END                                           = 3
};

// Enum Engine.MaterialExpressionTransform.EMaterialVectorCoordTransform
enum class EMaterialVectorCoordTransform : uint8_t
{
	TRANSFORM_World                                    = 0,
	TRANSFORM_View                                     = 1,
	TRANSFORM_Local                                    = 2,
	TRANSFORM_Tangent                                  = 3,
	TRANSFORM_END                                      = 4
};

// Enum Engine.MaterialExpressionTransform.EMaterialVectorCoordTransformSource
enum class EMaterialVectorCoordTransformSource : uint8_t
{
	TRANSFORMSOURCE_World                              = 0,
	TRANSFORMSOURCE_Local                              = 1,
	TRANSFORMSOURCE_Tangent                            = 2,
	TRANSFORMSOURCE_View                               = 3,
	TRANSFORMSOURCE_END                                = 4
};

// Enum Engine.MaterialExpressionTransformPosition.EMaterialPositionTransform
enum class EMaterialPositionTransform : uint8_t
{
	TRANSFORMPOS_ScreenToWorld                         = 0,
	TRANSFORMPOS_WorldToScreen                         = 1,
	TRANSFORMPOS_ScreenToView                          = 2,
	TRANSFORMPOS_ViewToScreen                          = 3,
	TRANSFORMPOS_ScreenToCamera                        = 4,
	TRANSFORMPOS_CameraToScreen                        = 5,
	TRANSFORMPOS_END                                   = 6
};

// Enum Engine.MaterialExpressionVectorIf.EVectorIfComparator
enum class EVectorIfComparator : uint8_t
{
	VIC_Greater                                        = 0,
	VIC_GreaterEqual                                   = 1,
	VIC_Equal                                          = 2,
	VIC_NotEqual                                       = 3,
	VIC_END                                            = 4
};

// Enum Engine.NxForceFieldGeneric.FFG_ForceFieldCoordinates
enum class EFFG_ForceFieldCoordinates : uint8_t
{
	FFG_CARTESIAN                                      = 0,
	FFG_SPHERICAL                                      = 1,
	FFG_CYLINDRICAL                                    = 2,
	FFG_TOROIDAL                                       = 3,
	FFG_END                                            = 4
};

// Enum Engine.NxGenericForceFieldBrush.FFB_ForceFieldCoordinates
enum class EFFB_ForceFieldCoordinates : uint8_t
{
	FFB_CARTESIAN                                      = 0,
	FFB_SPHERICAL                                      = 1,
	FFB_CYLINDRICAL                                    = 2,
	FFB_TOROIDAL                                       = 3,
	FFB_END                                            = 4
};

// Enum Engine.OnlineSubsystem.EGameLicenseType
enum class EGameLicenseType : uint8_t
{
	GLT_Unknown                                        = 0,
	GLT_Trial                                          = 1,
	GLT_Full                                           = 2,
	GLT_END                                            = 3
};

// Enum Engine.OnlineGameSearch.EOnlineGameSearchSortType
enum class EOnlineGameSearchSortType : uint8_t
{
	OGSSO_Ascending                                    = 0,
	OGSSO_Descending                                   = 1,
	OGSSO_END                                          = 2
};

// Enum Engine.OnlineGameSearch.EOnlineGameSearchComparisonType
enum class EOnlineGameSearchComparisonType : uint8_t
{
	OGSCT_Equals                                       = 0,
	OGSCT_NotEquals                                    = 1,
	OGSCT_GreaterThan                                  = 2,
	OGSCT_GreaterThanEquals                            = 3,
	OGSCT_LessThan                                     = 4,
	OGSCT_LessThanEquals                               = 5,
	OGSCT_END                                          = 6
};

// Enum Engine.OnlineGameSearch.EOnlineGameSearchEntryType
enum class EOnlineGameSearchEntryType : uint8_t
{
	OGSET_Property                                     = 0,
	OGSET_LocalizedSetting                             = 1,
	OGSET_ObjectProperty                               = 2,
	OGSET_END                                          = 3
};

// Enum Engine.Settings.EOnlineDataAdvertisementType
enum class EOnlineDataAdvertisementType : uint8_t
{
	ODAT_DontAdvertise                                 = 0,
	ODAT_OnlineService                                 = 1,
	ODAT_QoS                                           = 2,
	ODAT_OnlineServiceAndQoS                           = 3,
	ODAT_END                                           = 4
};

// Enum Engine.Settings.EPropertyValueMappingType
enum class EPropertyValueMappingType : uint8_t
{
	PVMT_RawValue                                      = 0,
	PVMT_PredefinedValues                              = 1,
	PVMT_Ranged                                        = 2,
	PVMT_IdMapped                                      = 3,
	PVMT_END                                           = 4
};

// Enum Engine.Settings.ESettingsDataType
enum class ESettingsDataType : uint8_t
{
	SDT_Empty                                          = 0,
	SDT_Int32                                          = 1,
	SDT_Int64                                          = 2,
	SDT_Double                                         = 3,
	SDT_String                                         = 4,
	SDT_Float                                          = 5,
	SDT_Blob                                           = 6,
	SDT_DateTime                                       = 7,
	SDT_Byte                                           = 8,
	SDT_END                                            = 9
};

// Enum Engine.UIDataProvider.EProviderAccessType
enum class EProviderAccessType : uint8_t
{
	ACCESS_ReadOnly                                    = 0,
	ACCESS_PerField                                    = 1,
	ACCESS_WriteAll                                    = 2,
	ACCESS_END                                         = 3
};

// Enum Engine.OutlinePostProcessEffect.EBlurDownSampleFactor
enum class EBlurDownSampleFactor : uint8_t
{
	BDSF_Quarter                                       = 0,
	BDSF_Half                                          = 1,
	BDSF_None                                          = 2,
	BDSF_END                                           = 3
};

// Enum Engine.ParticleEmitter.EEmitterLODFlag
enum class EEmitterLODFlag : uint8_t
{
	ELODF_Enabled                                      = 0,
	ELODF_Partial                                      = 1,
	ELODF_Disabled                                     = 2,
	ELODF_END                                          = 3
};

// Enum Engine.ParticleEmitter.EEmitterLODPlatform
enum class EEmitterLODPlatform : uint8_t
{
	ELODP_PC                                           = 0,
	ELODP_XB                                           = 1,
	ELODP_PS                                           = 2,
	ELODP_SS                                           = 3,
	ELODP_END                                          = 4
};

// Enum Engine.ParticleEmitter.EEmitterRenderMode
enum class EEmitterRenderMode : uint8_t
{
	ERM_Normal                                         = 0,
	ERM_Point                                          = 1,
	ERM_Cross                                          = 2,
	ERM_None                                           = 3,
	ERM_END                                            = 4
};

// Enum Engine.ParticleEmitter.EParticleSubUVInterpMethod
enum class EParticleSubUVInterpMethod : uint8_t
{
	PSUVIM_None                                        = 0,
	PSUVIM_Linear                                      = 1,
	PSUVIM_Linear_Blend                                = 2,
	PSUVIM_Random                                      = 3,
	PSUVIM_Random_Blend                                = 4,
	PSUVIM_END                                         = 5
};

// Enum Engine.ParticleEmitter.EParticleBurstMethod
enum class EParticleBurstMethod : uint8_t
{
	EPBM_Instant                                       = 0,
	EPBM_Interpolated                                  = 1,
	EPBM_END                                           = 2
};

// Enum Engine.ParticleModule.EParticleSourceSelectionMethod
enum class EParticleSourceSelectionMethod : uint8_t
{
	EPSSM_Random                                       = 0,
	EPSSM_Sequential                                   = 1,
	EPSSM_Oldest                                       = 2,
	EPSSM_Newest                                       = 3,
	EPSSM_END                                          = 4
};

// Enum Engine.ParticleModule.EModuleType
enum class EModuleType : uint8_t
{
	EPMT_General                                       = 0,
	EPMT_TypeData                                      = 1,
	EPMT_Beam                                          = 2,
	EPMT_Trail                                         = 3,
	EPMT_Spawn                                         = 4,
	EPMT_Required                                      = 5,
	EPMT_Event                                         = 6,
	EPMT_END                                           = 7
};

// Enum Engine.ParticleModuleAttractorParticle.EAttractorParticleSelectionMethod
enum class EAttractorParticleSelectionMethod : uint8_t
{
	EAPSM_Random                                       = 0,
	EAPSM_Sequential                                   = 1,
	EAPSM_END                                          = 2
};

// Enum Engine.ParticleModuleBeamBase.Beam2SourceTargetTangentMethod
enum class EBeam2SourceTargetTangentMethod : uint8_t
{
	PEB2STTM_Direct                                    = 0,
	PEB2STTM_UserSet                                   = 1,
	PEB2STTM_Distribution                              = 2,
	PEB2STTM_Emitter                                   = 3,
	PEB2STTM_END                                       = 4
};

// Enum Engine.ParticleModuleBeamBase.Beam2SourceTargetMethod
enum class EBeam2SourceTargetMethod : uint8_t
{
	PEB2STM_Override                                   = 0,
	PEB2STM_UserSet                                    = 1,
	PEB2STM_Emitter                                    = 2,
	PEB2STM_Particle                                   = 3,
	PEB2STM_Actor                                      = 4,
	PEB2STM_END                                        = 5
};

// Enum Engine.ParticleModuleBeam.EBeamMethod
enum class EBeamMethod : uint8_t
{
	PEBM_Distance                                      = 0,
	PEBM_Target                                        = 1,
	PEBM_END                                           = 2
};

// Enum Engine.ParticleModuleCameraOffset.EParticleCameraOffsetUpdateMethod
enum class EParticleCameraOffsetUpdateMethod : uint8_t
{
	EPCOUM_DirectSet                                   = 0,
	EPCOUM_Additive                                    = 1,
	EPCOUM_Scalar                                      = 2,
	EPCOUM_END                                         = 3
};

// Enum Engine.ParticleModuleCollisionBase.EParticleCollisionComplete
enum class EParticleCollisionComplete : uint8_t
{
	EPCC_Kill                                          = 0,
	EPCC_HaltCollisions                                = 1,
	EPCC_FreezeTranslation                             = 2,
	EPCC_FreezeRotation                                = 3,
	EPCC_FreezeMovement                                = 4,
	EPCC_END                                           = 5
};

// Enum Engine.ParticleModuleEventReceiverEnabler.EEmitterEnablerTarget
enum class EEmitterEnablerTarget : uint8_t
{
	EET_Emitter                                        = 0,
	EET_Layer                                          = 1,
	EET_END                                            = 2
};

// Enum Engine.ParticleModuleEventReceiverEnabler.EEmitterEnablerAction
enum class EEmitterEnablerAction : uint8_t
{
	EEA_Disable                                        = 0,
	EEA_Enable                                         = 1,
	EEA_Toggle                                         = 2,
	EEA_END                                            = 3
};

// Enum Engine.ParticleModuleLocationBoneSocket.ELocationBoneSocketSelectionMethod
enum class ELocationBoneSocketSelectionMethod : uint8_t
{
	BONESOCKETSEL_Sequential                           = 0,
	BONESOCKETSEL_Random                               = 1,
	BONESOCKETSEL_RandomExhaustive                     = 2,
	BONESOCKETSEL_END                                  = 3
};

// Enum Engine.ParticleModuleLocationBoneSocket.ELocationBoneSocketSource
enum class ELocationBoneSocketSource : uint8_t
{
	BONESOCKETSOURCE_Bones                             = 0,
	BONESOCKETSOURCE_Sockets                           = 1,
	BONESOCKETSOURCE_END                               = 2
};

// Enum Engine.ParticleModuleLocationEmitter.ELocationEmitterSelectionMethod
enum class ELocationEmitterSelectionMethod : uint8_t
{
	ELESM_Random                                       = 0,
	ELESM_Sequential                                   = 1,
	ELESM_Oldest                                       = 2,
	ELESM_Newest                                       = 3,
	ELESM_END                                          = 4
};

// Enum Engine.ParticleModuleLocationIceChunks.ELocationIceChunkSelectionMethod
enum class ELocationIceChunkSelectionMethod : uint8_t
{
	ICECHUNK_Sequential                                = 0,
	ICECHUNK_Random                                    = 1,
	ICECHUNK_END                                       = 2
};

// Enum Engine.ParticleModuleLocationOffset.EParticleLocationOffsetUpdateMethod
enum class EParticleLocationOffsetUpdateMethod : uint8_t
{
	EPLOUM_DirectSet                                   = 0,
	EPLOUM_Additive                                    = 1,
	EPLOUM_Scalar                                      = 2,
	EPLOUM_END                                         = 3
};

// Enum Engine.ParticleModuleLocationPrimitiveCylinder.CylinderHeightAxis
enum class ECylinderHeightAxis : uint8_t
{
	PMLPC_HEIGHTAXIS_X                                 = 0,
	PMLPC_HEIGHTAXIS_Y                                 = 1,
	PMLPC_HEIGHTAXIS_Z                                 = 2,
	PMLPC_HEIGHTAXIS_END                               = 3
};

// Enum Engine.ParticleModuleLocationSkelVertSurface.ELocationSkelVertSurfaceSource
enum class ELocationSkelVertSurfaceSource : uint8_t
{
	VERTSURFACESOURCE_Vert                             = 0,
	VERTSURFACESOURCE_Surface                          = 1,
	VERTSURFACESOURCE_END                              = 2
};

// Enum Engine.ParticleModuleOrbit.EOrbitChainMode
enum class EOrbitChainMode : uint8_t
{
	EOChainMode_Add                                    = 0,
	EOChainMode_Scale                                  = 1,
	EOChainMode_Link                                   = 2,
	EOChainMode_END                                    = 3
};

// Enum Engine.ParticleModuleOrientationAxisLock.EParticleAxisLock
enum class EParticleAxisLock : uint8_t
{
	EPAL_NONE                                          = 0,
	EPAL_X                                             = 1,
	EPAL_Y                                             = 2,
	EPAL_Z                                             = 3,
	EPAL_NEGATIVE_X                                    = 4,
	EPAL_NEGATIVE_Y                                    = 5,
	EPAL_NEGATIVE_Z                                    = 6,
	EPAL_ROTATE_X                                      = 7,
	EPAL_ROTATE_Y                                      = 8,
	EPAL_ROTATE_Z                                      = 9,
	EPAL_Orientation                                   = 10,
	EPAL_END                                           = 11
};

// Enum Engine.ParticleModuleParameterDynamic.EEmitterDynamicParameterValue
enum class EEmitterDynamicParameterValue : uint8_t
{
	EDPV_UserSet                                       = 0,
	EDPV_VelocityX                                     = 1,
	EDPV_VelocityY                                     = 2,
	EDPV_VelocityZ                                     = 3,
	EDPV_VelocityMag                                   = 4,
	EDPV_END                                           = 5
};

// Enum Engine.ParticleModuleRequired.EParticleSortMode
enum class EParticleSortMode : uint8_t
{
	PSORTMODE_None                                     = 0,
	PSORTMODE_ViewProjDepth                            = 1,
	PSORTMODE_DistanceToView                           = 2,
	PSORTMODE_Age_OldestFirst                          = 3,
	PSORTMODE_Age_NewestFirst                          = 4,
	PSORTMODE_END                                      = 5
};

// Enum Engine.ParticleSpriteEmitter.EParticleScreenAlignment
enum class EParticleScreenAlignment : uint8_t
{
	PSA_Square                                         = 0,
	PSA_Rectangle                                      = 1,
	PSA_Velocity                                       = 2,
	PSA_TypeSpecific                                   = 3,
	PSA_END                                            = 4
};

// Enum Engine.ParticleModuleTrailNoise.EParticleTrailNoiseType
enum class EParticleTrailNoiseType : uint8_t
{
	EPTNT_Sine                                         = 0,
	EPTNT_Square                                       = 1,
	EPTNT_Triangle                                     = 2,
	EPTNT_Sawtooth                                     = 3,
	EPTNT_END                                          = 4
};

// Enum Engine.ParticleModuleTrailSource.ETrail2SourceMethod
enum class ETrail2SourceMethod : uint8_t
{
	PET2SRCM_Default                                   = 0,
	PET2SRCM_Particle                                  = 1,
	PET2SRCM_Actor                                     = 2,
	PET2SRCM_END                                       = 3
};

// Enum Engine.ParticleModuleTrailSpawn.ETrail2SpawnMethod
enum class ETrail2SpawnMethod : uint8_t
{
	PET2SM_Emitter                                     = 0,
	PET2SM_Velocity                                    = 1,
	PET2SM_Distance                                    = 2,
	PET2SM_END                                         = 3
};

// Enum Engine.ParticleModuleTrailTaper.ETrailTaperMethod
enum class ETrailTaperMethod : uint8_t
{
	PETTM_None                                         = 0,
	PETTM_Full                                         = 1,
	PETTM_Partial                                      = 2,
	PETTM_END                                          = 3
};

// Enum Engine.ParticleModuleTypeDataBeam2.EBeamTaperMethod
enum class EBeamTaperMethod : uint8_t
{
	PEBTM_None                                         = 0,
	PEBTM_Full                                         = 1,
	PEBTM_Partial                                      = 2,
	PEBTM_END                                          = 3
};

// Enum Engine.ParticleModuleTypeDataBeam2.EBeam2Method
enum class EBeam2Method : uint8_t
{
	PEB2M_Distance                                     = 0,
	PEB2M_Target                                       = 1,
	PEB2M_Branch                                       = 2,
	PEB2M_END                                          = 3
};

// Enum Engine.ParticleModuleTypeDataBeam2.EBeam2Interpolation
enum class EBeam2Interpolation : uint8_t
{
	PEB2I_Linear                                       = 0,
	PEB2I_Cubic                                        = 1,
	PEB2I_Spline                                       = 2,
	PEB2I_END                                          = 3
};

// Enum Engine.ParticleModuleTypeDataMesh.EMeshCameraFacingOptions
enum class EMeshCameraFacingOptions : uint8_t
{
	XAxisFacing_NoUp                                   = 0,
	XAxisFacing_ZUp                                    = 1,
	XAxisFacing_NegativeZUp                            = 2,
	XAxisFacing_YUp                                    = 3,
	XAxisFacing_NegativeYUp                            = 4,
	LockedAxis_ZAxisFacing                             = 5,
	LockedAxis_NegativeZAxisFacing                     = 6,
	LockedAxis_YAxisFacing                             = 7,
	LockedAxis_NegativeYAxisFacing                     = 8,
	VelocityAligned_ZAxisFacing                        = 9,
	VelocityAligned_NegativeZAxisFacing                = 10,
	VelocityAligned_YAxisFacing                        = 11,
	VelocityAligned_NegativeYAxisFacing                = 12,
	EMeshCameraFacingOptions_END                       = 13
};

// Enum Engine.ParticleModuleTypeDataMesh.EMeshCameraFacingUpAxis
enum class EMeshCameraFacingUpAxis : uint8_t
{
	CameraFacing_NoneUP                                = 0,
	CameraFacing_ZUp                                   = 1,
	CameraFacing_NegativeZUp                           = 2,
	CameraFacing_YUp                                   = 3,
	CameraFacing_NegativeYUp                           = 4,
	CameraFacing_END                                   = 5
};

// Enum Engine.ParticleModuleTypeDataMesh.EMeshScreenAlignment
enum class EMeshScreenAlignment : uint8_t
{
	PSMA_MeshFaceCameraWithRoll                        = 0,
	PSMA_MeshFaceCameraWithSpin                        = 1,
	PSMA_MeshFaceCameraWithLockedAxis                  = 2,
	PSMA_END                                           = 3
};

// Enum Engine.ParticleModuleTypeDataMeshPhysX.EPhysXMeshRotationMethod
enum class EPhysXMeshRotationMethod : uint8_t
{
	PMRM_Disabled                                      = 0,
	PMRM_Spherical                                     = 1,
	PMRM_Box                                           = 2,
	PMRM_LongBox                                       = 3,
	PMRM_FlatBox                                       = 4,
	PMRM_Velocity                                      = 5,
	PMRM_END                                           = 6
};

// Enum Engine.ParticleModuleTypeDataRibbon.ETrailsRenderAxisOption
enum class ETrailsRenderAxisOption : uint8_t
{
	Trails_CameraUp                                    = 0,
	Trails_SourceUp                                    = 1,
	Trails_WorldUp                                     = 2,
	Beams_CameraUp                                     = 3,
	ETrailsRenderAxisOption_END                        = 4
};

// Enum Engine.ParticleModuleVelocityVortex.EVortexAxisAlignment
enum class EVortexAxisAlignment : uint8_t
{
	VAA_X                                              = 0,
	VAA_Y                                              = 1,
	VAA_Z                                              = 2,
	VAA_END                                            = 3
};

// Enum Engine.PersistentGameDataManager.EPersistentOperation
enum class EPersistentOperation : uint8_t
{
	PO_Saving                                          = 0,
	PO_Restoring                                       = 1,
	PO_END                                             = 2
};

// Enum Engine.PhysicalMaterial.EPhysEffectType
enum class EPhysEffectType : uint8_t
{
	EPMET_Impact                                       = 0,
	EPMET_Slide                                        = 1,
	EPMET_END                                          = 2
};

// Enum Engine.RB_ConstraintInstance.EConstraintDriveChange
enum class EConstraintDriveChange : uint8_t
{
	CONST_DRIVE_Unchanged                              = 0,
	CONST_DRIVE_Enabled                                = 1,
	CONST_DRIVE_Disabled                               = 2,
	CONST_DRIVE_END                                    = 3
};

// Enum Engine.PhysicsResponseDefinition.HitDirectionType
enum class EHitDirectionType : uint8_t
{
	HitNormal                                          = 0,
	RadialOutward                                      = 1,
	RadialInward                                       = 2,
	HitDirectionType_END                               = 3
};

// Enum Engine.PhysXParticleSystem.ESimulationMethod
enum class ESimulationMethod : uint8_t
{
	ESM_SPH                                            = 0,
	ESM_NO_PARTICLE_INTERACTION                        = 1,
	ESM_MIXED_MODE                                     = 2,
	ESM_END                                            = 3
};

// Enum Engine.PhysXParticleSystem.EPacketSizeMultiplier
enum class EPacketSizeMultiplier : uint8_t
{
	EPSM                                               = 0,
	EPSM01                                             = 1,
	EPSM02                                             = 2,
	EPSM03                                             = 3,
	EPSM04                                             = 4,
	EPSM05                                             = 5,
	EPSM_END                                           = 6
};

// Enum Engine.PlayerReplicationInfo.EPlayerState
enum class EPlayerState : uint8_t
{
	PlayerState_Initial                                = 0,
	PlayerState_Disconnected                           = 1,
	PlayerState_Quit                                   = 2,
	PlayerState_Connected                              = 3,
	PlayerState_WaitingToStart                         = 4,
	PlayerState_ReadyToSpawnCharacter                  = 5,
	PlayerState_ReadyForMatchStart                     = 6,
	PlayerState_Playing                                = 7,
	PlayerState_END                                    = 8
};

// Enum Engine.ProxyMeshLODTemplates.ECombineTextureType
enum class ECombineTextureType : uint8_t
{
	CTT_Diffuse                                        = 0,
	CTT_Normal                                         = 1,
	CTT_Specular                                       = 2,
	CTT_Masks                                          = 3,
	CTT_Masks2                                         = 4,
	CTT_END                                            = 5
};

// Enum Engine.RB_BodySetup.EParentVelocityBlendType
enum class EParentVelocityBlendType : uint8_t
{
	PVBT_Actor                                         = 0,
	PVBT_ImmediateKinematic                            = 1,
	PVBT_ImmediateParent                               = 2,
	PVBT_END                                           = 3
};

// Enum Engine.RB_BodySetup.ESleepFamily
enum class ESleepFamily : uint8_t
{
	SF_Normal                                          = 0,
	SF_Sensitive                                       = 1,
	SF_END                                             = 2
};

// Enum Engine.RB_RadialForceActor.ERadialForceType
enum class ERadialForceType : uint8_t
{
	RFT_Force                                          = 0,
	RFT_Impulse                                        = 1,
	RFT_END                                            = 2
};

// Enum Engine.ResourcePoolDefinition.ENetRelevantFor
enum class ENetRelevantFor : uint8_t
{
	NETRELEVANT_Everyone                               = 0,
	NETRELEVANT_Owner                                  = 1,
	NETRELEVANT_Server                                 = 2,
	NETRELEVANT_END                                    = 3
};

// Enum Engine.SaveDataManager.ESaveDataOperationResult
enum class ESaveDataOperationResult : uint8_t
{
	SDOR_Pending                                       = 0,
	SDOR_Success                                       = 1,
	SDOR_Failed                                        = 2,
	SDOR_FailedInProgress                              = 3,
	SDOR_FailedNoFile                                  = 4,
	SDOR_FailedCorrupt                                 = 5,
	SDOR_END                                           = 6
};

// Enum Engine.SaveDataManager.ESaveDataOperationState
enum class ESaveDataOperationState : uint8_t
{
	SDOS_NotStarted                                    = 0,
	SDOS_InProgress                                    = 1,
	SDOS_Finished                                      = 2,
	SDOS_END                                           = 3
};

// Enum Engine.SaveDataManager.ECurrentSaveDataOperation
enum class ECurrentSaveDataOperation : uint8_t
{
	CSDO_Idle                                          = 0,
	CSDO_Reading                                       = 1,
	CSDO_Writing                                       = 2,
	CSDO_Deleting                                      = 3,
	CSDO_Listing                                       = 4,
	CSDO_CheckingFileExists                            = 5,
	CSDO_END                                           = 6
};

// Enum Engine.SeqAct_ActorFactory.EPointSelection
enum class EPointSelection : uint8_t
{
	PS_Normal                                          = 0,
	PS_Random                                          = 1,
	PS_Reverse                                         = 2,
	PS_END                                             = 3
};

// Enum Engine.SeqAct_GetDistance.DistanceMethod
enum class EDistanceMethod : uint8_t
{
	DISTANCE_Average                                   = 0,
	DISTANCE_Furthest                                  = 1,
	DISTANCE_Nearest                                   = 2,
	DISTANCE_END                                       = 3
};

// Enum Engine.SeqAct_SetMesh.EMeshType
enum class EMeshType : uint8_t
{
	MeshType_StaticMesh                                = 0,
	MeshType_SkeletalMesh                              = 1,
	MeshType_END                                       = 2
};

// Enum Engine.SeqEvent_ParticleEvent.EParticleEventOutputType
enum class EParticleEventOutputType : uint8_t
{
	ePARTICLEOUT_Spawn                                 = 0,
	ePARTICLEOUT_Death                                 = 1,
	ePARTICLEOUT_Collision                             = 2,
	ePARTICLEOUT_Kismet                                = 3,
	ePARTICLEOUT_Trace                                 = 4,
	ePARTICLEOUT_END                                   = 5
};

// Enum Engine.SkelControlBase.EBoneControlSpace
enum class EBoneControlSpace : uint8_t
{
	BCS_WorldSpace                                     = 0,
	BCS_ActorSpace                                     = 1,
	BCS_ComponentSpace                                 = 2,
	BCS_ParentBoneSpace                                = 3,
	BCS_BoneSpace                                      = 4,
	BCS_OtherBoneSpace                                 = 5,
	BCS_BaseMeshSpace                                  = 6,
	BCS_SocketSpace                                    = 7,
	BCS_END                                            = 8
};

// Enum Engine.SkelControlSpline.ESplineControlRotMode
enum class ESplineControlRotMode : uint8_t
{
	SCR_NoChange                                       = 0,
	SCR_AlongSpline                                    = 1,
	SCR_Interpolate                                    = 2,
	SCR_END                                            = 3
};

// Enum Engine.SkeletalMesh.SoftBodyBoneType
enum class ESoftBodyBoneType : uint8_t
{
	SOFTBODYBONE_Fixed                                 = 0,
	SOFTBODYBONE_BreakableAttachment                   = 1,
	SOFTBODYBONE_TwoWayAttachment                      = 2,
	SOFTBODYBONE_END                                   = 3
};

// Enum Engine.SkeletalMesh.ClothBoneType
enum class EClothBoneType : uint8_t
{
	CLOTHBONE_Fixed                                    = 0,
	CLOTHBONE_BreakableAttachment                      = 1,
	CLOTHBONE_TearLine                                 = 2,
	CLOTHBONE_END                                      = 3
};

// Enum Engine.SkeletalMesh.TriangleSortAxis
enum class ETriangleSortAxis : uint8_t
{
	TSA_X_Axis                                         = 0,
	TSA_Y_Axis                                         = 1,
	TSA_Z_Axis                                         = 2,
	TSA_END                                            = 3
};

// Enum Engine.SkeletalMesh.ClothMovementScaleGen
enum class EClothMovementScaleGen : uint8_t
{
	ECMDM_DistToFixedVert                              = 0,
	ECMDM_VertexBoneWeight                             = 1,
	ECMDM_Empty                                        = 2,
	ECMDM_END                                          = 3
};

// Enum Engine.SkeletalMesh.BoneBreakOption
enum class EBoneBreakOption : uint8_t
{
	BONEBREAK_SoftPreferred                            = 0,
	BONEBREAK_AutoDetect                               = 1,
	BONEBREAK_RigidPreferred                           = 2,
	BONEBREAK_END                                      = 3
};

// Enum Engine.StaticMeshLODTemplates.ELODTemplateNames
enum class ELODTemplateNames : uint8_t
{
	LTN_NotSet                                         = 0,
	LTN_NoTemplate                                     = 1,
	LTN                                                = 2,
	LTN01                                              = 3,
	LTN02                                              = 4,
	LTN03                                              = 5,
	LTN04                                              = 6,
	LTN05                                              = 7,
	LTN06                                              = 8,
	LTN07                                              = 9,
	LTN08                                              = 10,
	LTN09                                              = 11,
	LTN10                                              = 12,
	LTN11                                              = 13,
	LTN12                                              = 14,
	LTN13                                              = 15,
	LTN14                                              = 16,
	LTN_END                                            = 17
};

// Enum Engine.StaticMeshLODTemplates.EImportanceLevel
enum class EImportanceLevel : uint8_t
{
	IL_Off                                             = 0,
	IL_Lowest                                          = 1,
	IL_Low                                             = 2,
	IL_Normal                                          = 3,
	IL_High                                            = 4,
	IL_Highest                                         = 5,
	IL_Max                                             = 6
};

// Enum Engine.StaticMeshLODTemplates.LODTemplateType
enum class ELODTemplateType : uint8_t
{
	LTT_ScreenSpace                                    = 0,
	LTT_PolyReduction                                  = 1,
	LTT_END                                            = 2
};

// Enum Engine.SVehicleWheel.EWheelSide
enum class EWheelSide : uint8_t
{
	SIDE_None                                          = 0,
	SIDE_Left                                          = 1,
	SIDE_Right                                         = 2,
	SIDE_END                                           = 3
};

// Enum Engine.TargetableList.ETargetableListSearchType
enum class ETargetableListSearchType : uint8_t
{
	TL_Enemy                                           = 0,
	TL_Friendly                                        = 1,
	TL_Neutral                                         = 2,
	TL_All                                             = 3,
	TL_END                                             = 4
};

// Enum Engine.TerrainMaterial.ETerrainMappingType
enum class ETerrainMappingType : uint8_t
{
	TMT_Auto                                           = 0,
	TMT_XY                                             = 1,
	TMT_XZ                                             = 2,
	TMT_YZ                                             = 3,
	TMT_END                                            = 4
};

// Enum Engine.TextureFlipBook.TextureFlipBookMethod
enum class ETextureFlipBookMethod : uint8_t
{
	TFBM_UL_ROW                                        = 0,
	TFBM_UL_COL                                        = 1,
	TFBM_UR_ROW                                        = 2,
	TFBM_UR_COL                                        = 3,
	TFBM_LL_ROW                                        = 4,
	TFBM_LL_COL                                        = 5,
	TFBM_LR_ROW                                        = 6,
	TFBM_LR_COL                                        = 7,
	TFBM_RANDOM                                        = 8,
	TFBM_END                                           = 9
};

// Enum Engine.TextureMovie.EMovieStreamSource
enum class EMovieStreamSource : uint8_t
{
	MovieStream_File                                   = 0,
	MovieStream_Memory                                 = 1,
	MovieStream_END                                    = 2
};

// Enum Engine.UberPostProcessEffect.ETonemapperType
enum class ETonemapperType : uint8_t
{
	Tonemapper_Off                                     = 0,
	Tonemapper_Filmic                                  = 1,
	Tonemapper_Customizable                            = 2,
	Tonemapper_END                                     = 3
};

// Enum Engine.WillowInventory.EncryptedSerial
enum class EncryptedSerial : uint8_t
{
	ES_Encrypted                                       = 0,
	ES_END                                             = 1
};

// Enum Engine.WillowInventory.SerialNumberState
enum class ESerialNumberState : uint8_t
{
	SNS_Empty                                          = 0,
	SNS_Writing                                        = 1,
	SNS_Full                                           = 2,
	SNS_Reading                                        = 3,
	SNS_Encrypted                                      = 4,
	SNS_END                                            = 5
};

// Enum Engine.WillowInventory.PlayerMark
enum class EPlayerMark : uint8_t
{
	PM_Trash                                           = 0,
	PM_Standard                                        = 1,
	PM_Favorite                                        = 2,
	PM_END                                             = 3
};

// Enum Engine.WillowInventoryDefinition.EAttributeSlotEffectMode
enum class EAttributeSlotEffectMode : uint8_t
{
	ATTRSLOTEFFECTMODE_Default                         = 0,
	ATTRSLOTEFFECTMODE_Timed                           = 1,
	ATTRSLOTEFFECTMODE_Custom                          = 2,
	ATTRSLOTEFFECTMODE_END                             = 3
};

// Enum Engine.WillowInventoryDefinition.EStatCombinationMethod
enum class EStatCombinationMethod : uint8_t
{
	SCM_Multiply                                       = 0,
	SCM_Divide                                         = 1,
	SCM_Add                                            = 2,
	SCM_Subtract                                       = 3,
	SCM_DontCombine                                    = 4,
	SCM_END                                            = 5
};

// Enum Engine.WillowInventoryDefinition.ECurrencyType
enum class ECurrencyType : uint8_t
{
	CURRENCY_Credits                                   = 0,
	CURRENCY_Eridium                                   = 1,
	CURRENCY_SeraphCrystals                            = 2,
	CURRENCY_Reserved_A                                = 3,
	CURRENCY_Reserved_B                                = 4,
	CURRENCY_Reserved_C                                = 5,
	CURRENCY_Reserved_D                                = 6,
	CURRENCY_Reserved_E                                = 7,
	CURRENCY_Reserved_F                                = 8,
	CURRENCY_Reserved_G                                = 9,
	CURRENCY_Reserved_H                                = 10,
	CURRENCY_Reserved_I                                = 11,
	CURRENCY_Reserved_J                                = 12,
	CURRENCY_END                                       = 13
};

// Enum Engine.WillowInventoryDefinition.EPlayerDroppability
enum class EPlayerDroppability : uint8_t
{
	EPD_Droppable                                      = 0,
	EPD_Sellable                                       = 1,
	EPD_CannotDropOrSell                               = 2,
	EPD_END                                            = 3
};

// Enum Engine.Weapon.EWeaponFireType
enum class EWeaponFireType : uint8_t
{
	EWFT_InstantHit                                    = 0,
	EWFT_Projectile                                    = 1,
	EWFT_Beam                                          = 2,
	EWFT_Custom                                        = 3,
	EWFT_None                                          = 4,
	EWFT_END                                           = 5
};

// Enum Engine.StaticMesh.LODEnumTemplates
enum class ELODEnumTemplates : uint8_t
{
	NotSet                                             = 0,
	NoTemplate                                         = 1,
	LODEnumTemplates_END                               = 2
};


/*
# ========================================================================================= #
# Classes
# ========================================================================================= #
*/

// Class Engine.Actor
// 0x01E8 (0x0058 - 0x0240)
class AActor : public UObject
{
public:
	struct FPointer                                    VfTable_IIWorldBody;                           // 0x0058 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IISpawnActor;                          // 0x0060 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIConsoleCommandBehavior;              // 0x0068 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIAppearanceBehavior;                  // 0x0070 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIPhysicsBehavior;                     // 0x0078 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIChangeCollisionBehavior;             // 0x0080 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIDestroyBehavior;                     // 0x0088 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IISoundBehavior;                       // 0x0090 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIDamageCauser;                        // 0x0098 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIScaleBehavior;                       // 0x00A0 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIAssociated;                          // 0x00A8 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class TArray<class UActorComponent*>               Components;                                    // 0x00B0 (0x0010) [0x000000000448000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UActorComponent*>               AllComponents;                                 // 0x00C0 (0x0010) [0x000000000448200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	struct FVector                                     Location;                                      // 0x00D0 (0x000C) [0x0000000000000023] (CPF_Edit | CPF_Const | CPF_Net)
	struct FRotator                                    Rotation;                                      // 0x00DC (0x000C) [0x0000000000000023] (CPF_Edit | CPF_Const | CPF_Net)
	float                                              DrawScale;                                     // 0x00E8 (0x0004) [0x0000000300000023] (CPF_Edit | CPF_Const | CPF_Net)
	struct FVector                                     DrawScale3D;                                   // 0x00EC (0x000C) [0x0000000200000003] (CPF_Edit | CPF_Const)
	struct FVector                                     PrePivot;                                      // 0x00F8 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FRenderCommandFence                         DetachFence;                                   // 0x0104 (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)
	float                                              CustomTimeDilation;                            // 0x0108 (0x0004) [0x0000000000000020] (CPF_Net)     
	EPhysics                                           Physics;                                       // 0x010C (0x0001) [0x0000000000000023] (CPF_Edit | CPF_Const | CPF_Net)
	ESceneViewSeeType                                  ViewSeeType;                                   // 0x010D (0x0001) [0x0000000000000002] (CPF_Const)   
	ESceneViewHideViewportType                         ViewHideViewportType;                          // 0x010E (0x0001) [0x0000000000000002] (CPF_Const)   
	ENetRole                                           RemoteRole;                                    // 0x010F (0x0001) [0x0000000000000020] (CPF_Net)     
	ENetRole                                           Role;                                          // 0x0110 (0x0001) [0x0000000000000020] (CPF_Net)     
	ECollisionType                                     CollisionType;                                 // 0x0111 (0x0001) [0x0000000000002003] (CPF_Edit | CPF_Const | CPF_Transient)
	ECollisionType                                     ReplicatedCollisionType;                       // 0x0112 (0x0001) [0x0000000000002020] (CPF_Net | CPF_Transient)
	ETickingGroup                                      TickGroup;                                     // 0x0113 (0x0001) [0x0000000000000002] (CPF_Const)   
	class AActor*                                      Owner;                                         // 0x0118 (0x0008) [0x0000000000000022] (CPF_Const | CPF_Net)
	class AActor*                                      Base;                                          // 0x0120 (0x0008) [0x0000000000000023] (CPF_Edit | CPF_Const | CPF_Net)
	class TArray<struct FTimerData>                    Timers;                                        // 0x0128 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	float                                              AlwaysRelevantDistanceSquared;                 // 0x0138 (0x0004) [0x0000000000000002] (CPF_Const)   
	uint32_t                                           bStatic : 1;                                   // 0x013C (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)
	uint32_t                                           bHidden : 1;                                   // 0x013C (0x0004) [0x0000000000000023] [0x00000002] (CPF_Edit | CPF_Const | CPF_Net)
	uint32_t                                           bLockHidden : 1;                               // 0x013C (0x0004) [0x0000000000002002] [0x00000004] (CPF_Const | CPF_Transient)
	uint32_t                                           bLockHiddenRestoreValue : 1;                   // 0x013C (0x0004) [0x0000000000002002] [0x00000008] (CPF_Const | CPF_Transient)
	uint32_t                                           bNoDelete : 1;                                 // 0x013C (0x0004) [0x0000000000000002] [0x00000010] (CPF_Const)
	uint32_t                                           bDeleteMe : 1;                                 // 0x013C (0x0004) [0x0000000000000002] [0x00000020] (CPF_Const)
	uint32_t                                           bTicked : 1;                                   // 0x013C (0x0004) [0x0000000000002002] [0x00000040] (CPF_Const | CPF_Transient)
	uint32_t                                           bOnlyOwnerSee : 1;                             // 0x013C (0x0004) [0x0000000020000002] [0x00000080] (CPF_Const | CPF_Deprecated)
	uint32_t                                           bTickIsDisabled : 1;                           // 0x013C (0x0004) [0x0000000000000002] [0x00000100] (CPF_Const)
	uint32_t                                           bWorldGeometry : 1;                            // 0x013C (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bIgnoreRigidBodyPawns : 1;                     // 0x013C (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	uint32_t                                           bOrientOnSlope : 1;                            // 0x013C (0x0004) [0x0000000000000000] [0x00000800] 
	uint32_t                                           bIgnoreEncroachers : 1;                        // 0x013C (0x0004) [0x0000000000000002] [0x00001000] (CPF_Const)
	uint32_t                                           bPushedByEncroachers : 1;                      // 0x013C (0x0004) [0x0000000000000000] [0x00002000] 
	uint32_t                                           bRouteBeginPlayEvenIfStatic : 1;               // 0x013C (0x0004) [0x0000000000000002] [0x00004000] (CPF_Const)
	uint32_t                                           bIsMoving : 1;                                 // 0x013C (0x0004) [0x0000000000000002] [0x00008000] (CPF_Const)
	uint32_t                                           bAlwaysEncroachCheck : 1;                      // 0x013C (0x0004) [0x0000000000000000] [0x00010000] 
	uint32_t                                           bCanStepUpOn : 1;                              // 0x013C (0x0004) [0x0000000000000001] [0x00020000] (CPF_Edit)
	uint32_t                                           bNetTemporary : 1;                             // 0x013C (0x0004) [0x0000000000000002] [0x00040000] (CPF_Const)
	uint32_t                                           bOnlyRelevantToOwner : 1;                      // 0x013C (0x0004) [0x0000000000000002] [0x00080000] (CPF_Const)
	uint32_t                                           bNetDirty : 1;                                 // 0x013C (0x0004) [0x0000000000002000] [0x00100000] (CPF_Transient)
	uint32_t                                           bAlwaysRelevant : 1;                           // 0x013C (0x0004) [0x0000000000000000] [0x00200000] 
	uint32_t                                           bReplicateInstigator : 1;                      // 0x013C (0x0004) [0x0000000000000000] [0x00400000] 
	uint32_t                                           bReplicateMovement : 1;                        // 0x013C (0x0004) [0x0000000000000000] [0x00800000] 
	uint32_t                                           bSkipRotationReplication : 1;                  // 0x013C (0x0004) [0x0000000000000000] [0x01000000] 
	uint32_t                                           bForceRotationReplication : 1;                 // 0x013C (0x0004) [0x0000000000000000] [0x02000000] 
	uint32_t                                           bSkipActorPropertyReplication : 1;             // 0x013C (0x0004) [0x0000000000000000] [0x04000000] 
	uint32_t                                           bUpdateSimulatedPosition : 1;                  // 0x013C (0x0004) [0x0000000000000000] [0x08000000] 
	uint32_t                                           bTearOff : 1;                                  // 0x013C (0x0004) [0x0000000000000020] [0x10000000] (CPF_Net)
	uint32_t                                           bOnlyDirtyReplication : 1;                     // 0x013C (0x0004) [0x0000000000000000] [0x20000000] 
	uint32_t                                           bSkipHiddenReplication : 1;                    // 0x013C (0x0004) [0x0000000000000000] [0x40000000] 
	uint32_t                                           bSkipStillDirtyReplication : 1;                // 0x013C (0x0004) [0x0000000000000000] [0x80000000] 
	uint32_t                                           bAllowFluidSurfaceInteraction : 1;             // 0x0140 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDemoRecording : 1;                            // 0x0140 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	uint32_t                                           bDemoOwner : 1;                                // 0x0140 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bForceDemoRelevant : 1;                        // 0x0140 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bNetInitialRotation : 1;                       // 0x0140 (0x0004) [0x0000000000000002] [0x00000010] (CPF_Const)
	uint32_t                                           bReplicateRigidBodyLocation : 1;               // 0x0140 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bKillDuringLevelTransition : 1;                // 0x0140 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bExchangedRoles : 1;                           // 0x0140 (0x0004) [0x0000000000000002] [0x00000080] (CPF_Const)
	uint32_t                                           bConsiderAllStaticMeshComponentsForStreaming : 1;// 0x0140 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bPostRenderIfNotVisible : 1;                   // 0x0140 (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bForceNetUpdate : 1;                           // 0x0140 (0x0004) [0x0000000000002000] [0x00000400] (CPF_Transient)
	uint32_t                                           bPendingNetUpdate : 1;                         // 0x0140 (0x0004) [0x0000000000002002] [0x00000800] (CPF_Const | CPF_Transient)
	uint32_t                                           bOneWayTouch : 1;                              // 0x0140 (0x0004) [0x0000000000002000] [0x00001000] (CPF_Transient)
	uint32_t                                           bUseLagCompensation : 1;                       // 0x0140 (0x0004) [0x0000000000002000] [0x00002000] (CPF_Transient)
	uint32_t                                           bHardAttach : 1;                               // 0x0140 (0x0004) [0x0000000000000023] [0x00004000] (CPF_Edit | CPF_Const | CPF_Net)
	uint32_t                                           bIgnoreBaseRotation : 1;                       // 0x0140 (0x0004) [0x0000000000000001] [0x00008000] (CPF_Edit)
	uint32_t                                           bSkipAttachedMoves : 1;                        // 0x0140 (0x0004) [0x0000000000000001] [0x00010000] (CPF_Edit)
	uint32_t                                           bHurtEntry : 1;                                // 0x0140 (0x0004) [0x0000000000000000] [0x00020000] 
	uint32_t                                           bGameRelevant : 1;                             // 0x0140 (0x0004) [0x0000000000000000] [0x00040000] 
	uint32_t                                           bMovable : 1;                                  // 0x0140 (0x0004) [0x0000000000000002] [0x00080000] (CPF_Const)
	uint32_t                                           bDestroyInPainVolume : 1;                      // 0x0140 (0x0004) [0x0000000000000000] [0x00100000] 
	uint32_t                                           bCanBeDamaged : 1;                             // 0x0140 (0x0004) [0x0000000000000000] [0x00200000] 
	uint32_t                                           bShouldBaseAtStartup : 1;                      // 0x0140 (0x0004) [0x0000000000000000] [0x00400000] 
	uint32_t                                           bPendingDelete : 1;                            // 0x0140 (0x0004) [0x0000000000000000] [0x00800000] 
	uint32_t                                           bCanTeleport : 1;                              // 0x0140 (0x0004) [0x0000000000000000] [0x01000000] 
	uint32_t                                           bAlwaysTick : 1;                               // 0x0140 (0x0004) [0x0000000000000002] [0x02000000] (CPF_Const)
	uint32_t                                           bBlocksNavigation : 1;                         // 0x0140 (0x0004) [0x0000000000000001] [0x04000000] (CPF_Edit)
	uint32_t                                           BlockRigidBody : 1;                            // 0x0140 (0x0004) [0x0000000000002003] [0x08000000] (CPF_Edit | CPF_Const | CPF_Transient)
	uint32_t                                           bCollideWhenPlacing : 1;                       // 0x0140 (0x0004) [0x0000000000000000] [0x10000000] 
	uint32_t                                           bCollideActors : 1;                            // 0x0140 (0x0004) [0x0000000000000022] [0x20000000] (CPF_Const | CPF_Net)
	uint32_t                                           bCollideWorld : 1;                             // 0x0140 (0x0004) [0x0000000000000020] [0x40000000] (CPF_Net)
	uint32_t                                           bCollideComplex : 1;                           // 0x0140 (0x0004) [0x0000000000000001] [0x80000000] (CPF_Edit)
	uint32_t                                           bBlockActors : 1;                              // 0x0144 (0x0004) [0x0000000000000020] [0x00000001] (CPF_Net)
	uint32_t                                           bProjTarget : 1;                               // 0x0144 (0x0004) [0x0000000000000020] [0x00000002] (CPF_Net)
	uint32_t                                           bBlocksTeleport : 1;                           // 0x0144 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bProjectileMoveSingleBlocking : 1;             // 0x0144 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bTraceListeners : 1;                           // 0x0144 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bIsBlockingMesh : 1;                           // 0x0144 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bIsWillowInteractiveObject : 1;                // 0x0144 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bIgnoreRadiusDamageCheck : 1;                  // 0x0144 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bNoEncroachCheck : 1;                          // 0x0144 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bCollideAsEncroacher : 1;                      // 0x0144 (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bPhysRigidBodyOutOfWorldCheck : 1;             // 0x0144 (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	uint32_t                                           bComponentOutsideWorld : 1;                    // 0x0144 (0x0004) [0x0000000000002002] [0x00000800] (CPF_Const | CPF_Transient)
	uint32_t                                           bForceOctreeSNFilter : 1;                      // 0x0144 (0x0004) [0x0000000000000000] [0x00001000] 
	uint32_t                                           bRigidBodyWasAwake : 1;                        // 0x0144 (0x0004) [0x0000000000002002] [0x00002000] (CPF_Const | CPF_Transient)
	uint32_t                                           bCallRigidBodyWakeEvents : 1;                  // 0x0144 (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bBounce : 1;                                   // 0x0144 (0x0004) [0x0000000000000000] [0x00008000] 
	uint32_t                                           bJustTeleported : 1;                           // 0x0144 (0x0004) [0x0000000000000002] [0x00010000] (CPF_Const)
	uint32_t                                           bNetInitial : 1;                               // 0x0144 (0x0004) [0x0000000000000002] [0x00020000] (CPF_Const)
	uint32_t                                           bNetOwner : 1;                                 // 0x0144 (0x0004) [0x0000000000000022] [0x00040000] (CPF_Const | CPF_Net)
	uint32_t                                           bHiddenEd : 1;                                 // 0x0144 (0x0004) [0x0000000000000002] [0x00080000] (CPF_Const)
	uint32_t                                           bEditable : 1;                                 // 0x0144 (0x0004) [0x0000000000000002] [0x00100000] (CPF_Const)
	uint32_t                                           bHiddenEdLayer : 1;                            // 0x0144 (0x0004) [0x0000000000000002] [0x00200000] (CPF_Const)
	uint32_t                                           bHiddenEdTemporary : 1;                        // 0x0144 (0x0004) [0x0000000800002000] [0x00400000] (CPF_Transient)
	uint32_t                                           bHiddenEdLevel : 1;                            // 0x0144 (0x0004) [0x0000000800002000] [0x00800000] (CPF_Transient)
	uint32_t                                           bEdShouldSnap : 1;                             // 0x0144 (0x0004) [0x0000000000000001] [0x01000000] (CPF_Edit)
	uint32_t                                           bTempEditor : 1;                               // 0x0144 (0x0004) [0x0000000000002002] [0x02000000] (CPF_Const | CPF_Transient)
	uint32_t                                           bPathColliding : 1;                            // 0x0144 (0x0004) [0x0000000000000001] [0x04000000] (CPF_Edit)
	uint32_t                                           bPathTemp : 1;                                 // 0x0144 (0x0004) [0x0000000000002000] [0x08000000] (CPF_Transient)
	uint32_t                                           bScriptInitialized : 1;                        // 0x0144 (0x0004) [0x0000000000000000] [0x10000000] 
	uint32_t                                           bLockLocation : 1;                             // 0x0144 (0x0004) [0x0000000000000001] [0x20000000] (CPF_Edit)
	uint32_t                                           bForceAllowKismetModification : 1;             // 0x0144 (0x0004) [0x0000000000000002] [0x40000000] (CPF_Const)
	uint32_t                                           bTraceIgnoreRigidBodyForPawns : 1;             // 0x0144 (0x0004) [0x0000000000000000] [0x80000000] 
	uint32_t                                           bAutoMovePlayerOnInterpActor : 1;              // 0x0148 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bMoveActorDoZeroExtentTrace : 1;               // 0x0148 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bDebugEffectIsRelevant : 1;                    // 0x0148 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bLoadIfPhysXLevel0 : 1;                        // 0x0148 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bLoadIfPhysXLevel1 : 1;                        // 0x0148 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bLoadIfPhysXLevel2 : 1;                        // 0x0148 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bHasProxyMesh : 1;                             // 0x0148 (0x0004) [0x0000000000000000] [0x00000040] 
	int32_t                                            NetTag;                                        // 0x014C (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              NetUpdateTime;                                 // 0x0150 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              NetUpdateFrequency;                            // 0x0154 (0x0004) [0x0000000000000000]               
	float                                              NetPriority;                                   // 0x0158 (0x0004) [0x0000000000000000]               
	float                                              LastNetUpdateTime;                             // 0x015C (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class APawn*                                       Instigator;                                    // 0x0160 (0x0008) [0x0000000000000020] (CPF_Net)     
	class AWorldInfo*                                  WorldInfo;                                     // 0x0168 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              LifeSpan;                                      // 0x0170 (0x0004) [0x0000000000000000]               
	float                                              CreationTime;                                  // 0x0174 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              LastRenderTime;                                // 0x0178 (0x0004) [0x0000000000002000] (CPF_Transient)
	class TArray<class AActor*>                        Touching;                                      // 0x0180 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              LatentFloat;                                   // 0x0190 (0x0004) [0x0000000000000002] (CPF_Const)   
	class APhysicsVolume*                              PhysicsVolume;                                 // 0x0198 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FVector                                     Velocity;                                      // 0x01A0 (0x000C) [0x0000000000000020] (CPF_Net)     
	struct FVector                                     Acceleration;                                  // 0x01AC (0x000C) [0x0000000000000000]               
	struct FVector                                     AngularVelocity;                               // 0x01B8 (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class USkeletalMeshComponent*                      BaseSkelComponent;                             // 0x01C8 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FName                                       BaseBoneName;                                  // 0x01D0 (0x0008) [0x0000000000000021] (CPF_Edit | CPF_Net)
	class TArray<class AActor*>                        Attached;                                      // 0x01D8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	struct FVector                                     RelativeLocation;                              // 0x01E8 (0x000C) [0x0000000000000022] (CPF_Const | CPF_Net)
	struct FRotator                                    RelativeRotation;                              // 0x01F4 (0x000C) [0x0000000000000022] (CPF_Const | CPF_Net)
	class UPrimitiveComponent*                         CollisionComponent;                            // 0x0200 (0x0008) [0x00000000040A0009] (CPF_Edit | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	int32_t                                            OverlapTag;                                    // 0x0208 (0x0004) [0x0000000000001000] (CPF_Native)  
	struct FRotator                                    RotationRate;                                  // 0x020C (0x000C) [0x0000000000000001] (CPF_Edit)    
	class TArray<class USequenceEvent*>                GeneratedEvents;                               // 0x0218 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<class USeqAct_Latent*>                LatentActions;                                 // 0x0228 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              MostRecentDamageTaken;                         // 0x0238 (0x0004) [0x4000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Actor");
		}

		return uClassPointer;
	};

	void ClientDrawDebugLine(const struct FVector& Start, const struct FVector& End, int32_t R, int32_t G, int32_t B, bool persistent, float Lifetime);
	class USpriteComponent* GetActorSpriteComponent();
	static void SetSkelMeshDebugging(bool bNewDebugging);
	static bool IsSkelMeshDebugging();
	bool IsWaterVolume();
	void DamageResult_KilledNeutral(class UObject* KilledObject, int32_t DamageTags);
	void DamageResult_KilledFriendly(class UObject* KilledObject, int32_t DamageTags);
	void DamageResult_KilledEnemy(class UObject* KilledObject, int32_t DamageTags);
	void DamageResult_DamagedNeutral(class UObject* DamageTaker, bool bWasCrit, float HealthDamage, float ShieldDamage, int32_t DamageTags);
	void DamageResult_DamagedFriendly(class UObject* DamageTaker, float DamageAmount, int32_t DamageTags);
	void DamageResult_DamagedEnemy(class UObject* DamageTaker, bool bWasCrit, float HealthDamage, float ShieldDamage, int32_t DamageTags);
	class AController* GetControllerResponsibleForDamage();
	class AActor* GetInstigator();
	float GetInstigatorSelfDamageScale();
	float GetFireIntervalChanceModifier();
	void WaitingForAttachmentBase();
	void Behavior_ChangeScale3D(const struct FVector& InScale3D);
	void Behavior_ChangeScale(float InScale);
	void Behavior_ChangeVisibility(bool bVisible);
	void Behavior_ToggleVisibility();
	void Behavior_ChangeCollisionSize(float NewRadius, float NewHeight);
	void Behavior_ChangeCollision(uint8_t NewCollisionType);
	struct FVector GetDamageVector();
	class UMeshComponent* GetRigidBodyMesh();
	void ClientConsoleCommand(const class FString& Command);
	void Behavior_ClientConsoleCommand(const class FString& Command);
	void Behavior_ConsoleCommand(const class FString& Command);
	void Behavior_Destroy();
	static void ClearResourcePoolReference(struct FResourcePoolReference& PoolReference);
	static float GetResourcePoolCurrentValueOrDefault(float DefaultValue, struct FResourcePoolReference& PoolReference);
	static bool IsResourcePoolValid(struct FResourcePoolReference& PoolReference);
	bool WorldBodyAttachComponent(class UActorComponent* Attachment, const struct FVector& optionalAttachmentRelativeLocation, const struct FRotator& optionalAttachmentRelativeRotation, const struct FName& optionalAttachmentPointName);
	bool WorldBodyAttachActor(class AActor* Attachment, const struct FVector& optionalAttachmentRelativeLocation, const struct FRotator& optionalAttachmentRelativeRotation, const struct FName& optionalAttachmentPointName);
	bool WorldBodyAttachTo(class UIWorldBody* OtherWorldBody, const struct FVector& optionalAttachmentRelativeLocation, const struct FRotator& optionalAttachmentRelativeRotation, const struct FName& optionalAttachmentPointName);
	class UIWorldBody* GetWorldBodyFirstPersonAttachmentBase();
	class UIWorldBody* GetWorldBodyAttachmentBase();
	struct FName GetWorldBodyAttachmentBoneForComponent(class UActorComponent* AttachedComponent);
	bool GetWorldBodyAttachmentLocationAndRotation(const struct FName& AttachmentPointName, struct FVector& OutLocation, struct FRotator& OutRotation);
	bool GetWorldBodyAttachmentRotation(const struct FName& AttachmentPointName, struct FRotator& OutRotation);
	bool GetWorldBodyAttachmentLocation(const struct FName& AttachmentPointName, struct FVector& OutLocation);
	struct FVector GetWorldBodyVelocity();
	struct FRotator GetWorldBodyRotation();
	struct FVector GetWorldBodyLocation();
	class AActor* GetSpawnOwner();
	int32_t GetActorMetrics(EActorMetricsType MetricsType);
	bool WillOverlap(const struct FVector& PosA, const struct FVector& VelA, const struct FVector& PosB, const struct FVector& VelB, float StepSize, float Radius, float& Time);
	void eventReplicationEnded();
	void eventPostDemoRewind();
	void eventAnimTreeUpdated(class USkeletalMeshComponent* SkelMesh);
	bool SupportsKismetModification(class USequenceOp* AskingOp, class FString& Reason);
	void eventTrailsNotifyEnd(class UAnimNotify_Trails* AnimNotifyData);
	void eventTrailsNotifyTick(class UAnimNotify_Trails* AnimNotifyData);
	void eventTrailsNotify(class UAnimNotify_Trails* AnimNotifyData);
	bool eventCreateForceField(class UAnimNotify_ForceField* AnimNotifyData);
	bool eventPlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	bool IsInPersistentLevel(bool optionalBIncludeLevelStreamingPersistent);
	void eventOnRigidBodySpringOverextension(class URB_BodyInstance* BodyInstance);
	static struct FGuid GetPackageGuid(const struct FName& PackageName);
	void eventPostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void eventTraceTouch(class AActor* Other, class UComponent* ComponentHit, const struct FVector& TouchLocation, const struct FVector& TouchNormal, const struct FVector& End, const struct FVector& Start, const struct FVector& Extent, const struct FQWord& TraceFlags, float TouchTime);
	void eventRootMotionExtracted(class USkeletalMeshComponent* SkelComp, struct FBoneAtom& ExtractedRootMotionDelta);
	void eventRootMotionProcessed(class USkeletalMeshComponent* SkelComp);
	void eventRootMotionModeChanged(class USkeletalMeshComponent* SkelComp);
	void eventPostRenderFor(class APlayerController* PC, class UCanvas* Canvas, const struct FVector& CameraPosition, const struct FVector& CameraDir);
	void NativePostRenderFor(class APlayerController* PC, class UCanvas* Canvas, const struct FVector& CameraPosition, const struct FVector& CameraDir);
	void SetHUDLocation(const struct FVector& NewHUDLocation);
	void eventOnRanOver(class ASVehicle* Vehicle, class UPrimitiveComponent* RunOverComponent, int32_t WheelIndex);
	void eventRigidBodyCollision(class UPrimitiveComponent* HitComponent, class UPrimitiveComponent* OtherComponent, int32_t ContactIndex, struct FCollisionImpactData& RigidCollisionData);
	void eventInterpolationChanged(class USeqAct_Interp* InterpAction);
	void eventInterpolationFinished(class USeqAct_Interp* InterpAction);
	void eventInterpolationStarted(class USeqAct_Interp* InterpAction, class UInterpGroupInst* GroupInst);
	void eventSpawnedByKismet();
	struct FVector GetTargetLocation(class AActor* optionalRequestedBy, bool optionalBRequestAlternateLoc);
	uint8_t eventScriptGetTeamNum();
	uint8_t GetTeamNum();
	void PawnBaseDied();
	bool IsPlayerOwned();
	struct FVector eventGetSpotOthersShouldLookAt();
	void GetActorEyesViewPoint(struct FVector& out_Location, struct FRotator& out_Rotation);
	class UFaceFXAsset* eventGetActorFaceFXAsset();
	bool CanActorPlayFaceFXAnim();
	bool IsActorPlayingFaceFXAnim();
	void eventTickSkelControl(float DeltaTime, class USkeletalMeshComponent* SkelComp, class USkelControlBase* SkelCtrl);
	void eventSetSkelControlScale(const struct FName& SkelControlName, float Scale);
	void eventSetMorphWeight(const struct FName& MorphNodeName, float MorphWeight);
	void eventStopActorFaceFXAnim();
	bool eventPlayActorFaceFXAnim(class UFaceFXAnimSet* AnimSet, const class FString& GroupName, const class FString& SeqName, class UAkEvent* AkEventToPlay);
	void eventFinishAnimControl(class UInterpGroup* InInterpGroup);
	void LastMatineeAnimFinished();
	void eventSetAnimPosition(const struct FName& SlotName, int32_t ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion);
	void eventBeginAnimControl(class UInterpGroup* InInterpGroup);
	void eventOnAnimPlay(class UAnimNodeSequence* SeqNode);
	void eventOnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void DoKismetAttachment(class AActor* Attachment, class USeqAct_AttachToActor* Action);
	void OnAttachToActor(class USeqAct_AttachToActor* Action);
	void OnToggleHidden(class USeqAct_ToggleHidden* Action);
	void OnChangeCollision(class USeqAct_ChangeCollision* Action);
	void OnSetPhysics(class USeqAct_SetPhysics* Action);
	void OnSetBlockRigidBody(class USeqAct_SetBlockRigidBody* Action);
	void OnSetVelocity(class USeqAct_SetVelocity* Action);
	void OnTeleport(class USeqAct_Teleport* Action);
	void eventModifyHealth(bool bHeal, float DamageAmount, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition, class UImpactDefinition* ImpactDefinition);
	void OnModifyHealth(class USeqAct_ModifyHealth* Action);
	void PrestreamTextures(float Seconds, bool bEnableStreaming, const struct FQWord& CinematicTextureGroups);
	void eventShutDown();
	void SetNetUpdateTime(float NewUpdateTime);
	void eventForceNetRelevant();
	void OnDestroy(class USeqAct_Destroy* Action);
	void ClearLatentAction(class UClass* actionClass, bool optionalBAborted, class USeqAct_Latent* optionalExceptionAction);
	bool FindEventsOfClass(class UClass* EventClass, bool optionalBIncludeDisabled, class TArray<class USequenceEvent*>& out_EventList);
	bool ActivateEventClass(class UClass* InClass, class AActor* InInstigator, bool optionalBTest, class TArray<class USequenceEvent*>& EventList, class TArray<int32_t>& ActivateIndices, class TArray<class USequenceEvent*>& ActivatedEvents);
	bool TriggerGlobalEventClass(class UClass* InEventClass, class AActor* InInstigator, int32_t optionalActivateIndex);
	void eventReceivedNewEvent(class USequenceEvent* Evt);
	bool TriggerEventClass(class UClass* InEventClass, class AActor* InInstigator, int32_t optionalActivateIndex, bool optionalBTest, class TArray<class USequenceEvent*>& ActivatedEvents);
	void eventDebugMessagePlayer(const class FString& msg);
	bool ImpactEffectIsRelevant(class APawn* EffectInstigator, const struct FVector& SpawnLocation, bool bForceDedicated, float optionalVisibleCullDistance, float optionalHiddenCullDistance, bool optionalBSkipLOSCheck, class AActor* optionalHitActor);
	bool ActorEffectIsRelevant(class APawn* EffectInstigator, bool bForceDedicated, float optionalVisibleCullDistance, float optionalHiddenCullDistance);
	bool EffectIsRelevant(const struct FVector& SpawnLocation, bool bForceDedicated, float optionalVisibleCullDistance, float optionalHiddenCullDistance, class AActor* optionalHitActor);
	class UImpactDefinition* GetTraceImpact();
	class UImpactDefinition* GetUntouchImpact();
	class UImpactDefinition* GetTouchImpact();
	bool CanSplash();
	void PlayTeleportEffect(bool bOut, bool bSound);
	void eventReset();
	class FString GetPhysicsName();
	void SwitchDisplayDebugPage(const struct FName& ActiveDebugCategory, bool Forward);
	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	void MatchStarting();
	static class FString GetLocalString(int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01);
	static class FString ReplaceHTMLMarkup(class FString& S);
	static void ReplaceText(const class FString& Replace, const class FString& With, class FString& Text);
	void eventEndViewTarget(class APlayerController* PC);
	void eventBecomeViewTarget(class APlayerController* PC);
	bool CheckForErrors();
	void eventDebugFreezeGame(class AActor* optionalActorToLookAt);
	float GetGravityZ();
	void CheckHitInfo(class UPrimitiveComponent* FallBackComponent, const struct FVector& Dir, bool optionalBPreferSkeletalMesh, struct FTraceHitInfo& HitInfo, struct FVector& out_HitLocation);
	void TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class UIDamageCauser* DamageCauser, float optionalDamageFalloffExponent, class UDamagePipeline* optionalPipeline);
	bool eventHealDamage(float Amount, class AController* Healer, class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition, bool optionalBIsShieldRestore);
	void eventTakeDamage(float DamageAmount, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& HitDirection, class UClass* DamageType, const struct FTraceHitInfo& optionalHitInfo, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline);
	void ActorTakeDamageInner(float DamageAmount, class AController* EventInstigator, class UClass* DamageType, class UDamagePipeline* Pipeline, struct FVector& HitLocation);
	static class UImpactDefinition* GetPipelineImpactDefinition(class UGBXPipeline* Pipeline);
	static class UDamageTypeDefinition* GetPipelineDamageType(class UGBXPipeline* Pipeline);
	static int32_t GetPipelineDamageTags(class UGBXPipeline* Pipeline);
	static void ReleaseDamagePipeline(class UDamagePipeline* Pipeline);
	static class UDamagePipeline* GetDamagePipeline(class UDamageTypeDefinition* optionalInDamageTypeDef, class UImpactDefinition* optionalInImpactDef, bool optionalInCanHitFriendly, class UObject* optionalInHitObject, bool optionalInCanHitInstigator);
	void KilledBy(class APawn* EventInstigator);
	bool HurtRadius(float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, class AController* optionalInstigatedByController, bool optionalBDoFullDamage, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline, bool optionalBSkipTraceTest, EOpinion optionalAllegianceFilter, class TArray<class AActor*>& IgnoredActors, class TArray<class AActor*>& ActorsHurt);
	bool CanWorldGeometryBecomeDynamic();
	bool StopsProjectile(class AProjectile* P);
	void eventNotifySkelControlBeyondLimit(class USkelControlLookAt* LookAt);
	void eventConstraintBrokenNotify(class AActor* ConOwner, class URB_ConstraintSetup* ConSetup, class URB_ConstraintInstance* ConInstance);
	void eventSetInitialState();
	void eventPostBeginPlay();
	void eventBroadcastLocalizedTeamMessage(int32_t TeamIndex, class UClass* InMessageClass, int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	void eventBroadcastLocalizedMessage(class UClass* InMessageClass, int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	void eventPreBeginPlay();
	class APlayerController* GetALocalPlayerController();
	struct FVector GetDestination(class AController* C);
	bool CalculateMinSpeedTrajectory(const struct FVector& End, const struct FVector& Start, float MaxTossSpeed, float MinTossSpeed, const struct FVector& optionalCollisionSize, float optionalTerminalVelocity, float optionalGravityZ, bool optionalBOnlyTraceUp, struct FVector& out_Velocity);
	bool SuggestTossVelocity(const struct FVector& Destination, const struct FVector& Start, float TossSpeed, float optionalBaseTossZ, float optionalDesiredZPct, const struct FVector& optionalCollisionSize, float optionalTerminalVelocity, float optionalOverrideGravityZ, bool optionalBOnlyTraceUp, struct FVector& TossVelocity);
	class UAkComponent* GetDefaultAkComponent();
	void PostAkTriggerObject(class UAkTrigger* Trigger);
	void SetAkSwitchObject(class UAkSwitch* Switch);
	void SetRTPCObjectValue(class UAkRtpc* InRtpc, float TargetValue, int32_t optionalRampTimeInMs);
	struct FAkPlayingInfo PostAkEvent(class UAkEvent* InAkEvent, bool optionalBStopWhenOwnerDestroyed, bool optionalBNotifyEventComplete);
	void OnAkEventCompleted(class UAkComponent* SourceComponent, class UAkEvent* SourceEvent, int32_t EventInstanceId);
	struct FAkPlayingInfo PlayAkEvent(class UAkEvent* InSoundCue, bool optionalBNotReplicated, bool optionalBNoRepToOwner, bool optionalBStopWhenOwnerDestroyed, bool optionalBNoRepToRelevant);
	void ResetTimerTimeDilation(const struct FName& TimerName, class UObject* optionalInObj);
	void ModifyTimerTimeDilation(const struct FName& TimerName, float InTimerTimeDilation, class UObject* optionalInObj);
	float GetRemainingTimeForTimer(const struct FName& optionalTimerFuncName, class UObject* optionalInObj);
	float GetTimerRate(const struct FName& optionalTimerFuncName, class UObject* optionalInObj);
	float GetTimerCount(const struct FName& optionalInTimerFunc, class UObject* optionalInObj);
	bool IsTimerActive(const struct FName& optionalInTimerFunc, class UObject* optionalInObj);
	void PauseTimer(bool bPause, const struct FName& optionalInTimerFunc, class UObject* optionalInObj);
	void ClearAllTimers(class UObject* optionalInObj);
	void ClearTimer(const struct FName& optionalInTimerFunc, class UObject* optionalInObj);
	void SetTimer(float InRate, bool optionalInbLoop, const struct FName& optionalInTimerFunc, class UObject* optionalInObj);
	void eventTornOff();
	bool Destroy();
	class AActor* SpawnForMap(class UClass* SpawnClass, class AActor* optionalSpawnOwner, const struct FName& optionalSpawnTag, const struct FVector& optionalSpawnLocation, const struct FRotator& optionalSpawnRotation, class AActor* optionalActorTemplate, bool optionalBNoCollisionFail);
	class AActor* Spawn(class UClass* SpawnClass, class AActor* optionalSpawnOwner, const struct FName& optionalSpawnTag, const struct FVector& optionalSpawnLocation, const struct FRotator& optionalSpawnRotation, class AActor* optionalActorTemplate, bool optionalBNoCollisionFail);
	bool IsBlockedBy(class AActor* Other);
	void GetBoundingCylinder(float& CollisionRadius, float& CollisionHeight);
	void GetComponentsBoundingBox(struct FBox& ActorBox);
	bool IsOverlapping(class AActor* A);
	bool ContainsPoint(const struct FVector& Spot);
	bool FindSpot(const struct FVector& BoxExtent, struct FVector& SpotLocation);
	bool TraceAllPhysicsAssetInteractions(class USkeletalMeshComponent* SkelMeshComp, const struct FVector& EndTrace, const struct FVector& StartTrace, const struct FVector& optionalExtent, class TArray<struct FImpactInfo>& out_Hits);
	bool FastTrace(const struct FVector& TraceEnd, const struct FVector& optionalTraceStart, const struct FVector& optionalBoxExtent, bool optionalBTraceBullet);
	bool PointCheckComponent(class UPrimitiveComponent* InComponent, const struct FVector& PointLocation, const struct FVector& PointExtent);
	bool TraceComponent(class UPrimitiveComponent* InComponent, const struct FVector& TraceEnd, const struct FVector& optionalTraceStart, const struct FVector& optionalExtent, bool optionalBComplexCollision, struct FVector& HitLocation, struct FVector& HitNormal, struct FTraceHitInfo& HitInfo);
	class AActor* Trace(const struct FVector& TraceEnd, const struct FVector& optionalTraceStart, bool optionalBTraceActors, const struct FVector& optionalExtent, int32_t optionalExtraTraceFlags, bool optionalBTraceBulletListeners, class AActor* optionalBulletListenerSource, struct FVector& HitLocation, struct FVector& HitNormal, struct FTraceHitInfo& HitInfo);
	void VolumeBasedDestroy(class APhysicsVolume* PV);
	bool eventOutsideWorldBounds();
	void eventFellOutOfWorld(class UClass* dmgType);
	bool CancelUsedBy(class APawn* User);
	bool UsedBy(class APawn* User, bool optionalBSimulateUnuse);
	bool eventOverRotated(struct FRotator& out_Desired, struct FRotator& out_Actual);
	bool ClampRotation(const struct FRotator& rBase, const struct FRotator& rUpperLimits, const struct FRotator& rLowerLimits, struct FRotator& out_Rot);
	void eventOnSleepRBPhysics();
	void eventOnWakeRBPhysics();
	void eventRanInto(class AActor* Other);
	void eventEncroachedBy(class AActor* Other);
	bool eventEncroachingOn(class AActor* Other);
	void eventCollisionChanged();
	class AActor* eventSpecialHandling(class APawn* Other);
	void eventDetach(class AActor* Other);
	void eventAttach(class AActor* Other);
	void eventBaseChange();
	void eventBump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal);
	void eventUnTouch(class AActor* Other);
	void eventPostTouch(class AActor* Other);
	void eventTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void eventPhysicsVolumeChange(class APhysicsVolume* NewVolume);
	void eventLanded(const struct FVector& HitNormal, class AActor* FloorActor);
	void eventFalling();
	void eventHitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void eventTimer();
	void eventTick(float DeltaTime);
	void eventLostChild(class AActor* Other);
	void eventGainedChild(class AActor* Other);
	void eventDestroyed();
	void SetTickIsDisabled(bool bInDisabled);
	void SetTickGroup(ETickingGroup NewTickGroup);
	void ReattachComponent(class UActorComponent* ComponentToReattach);
	void DetachComponent(class UActorComponent* ExComponent);
	void AttachComponent(class UActorComponent* NewComponent);
	void UnClock(float& Time);
	void Clock(float& Time);
	void SetPhysics(EPhysics newPhysics);
	void SetHidden(bool bNewHidden);
	void ChartData(const class FString& DataName, float DataValue);
	static void FlushDebugStrings();
	static void DrawDebugFrustrum(uint8_t R, uint8_t G, uint8_t B, bool optionalBPersistentLines, struct FMatrix& FrustumToWorld);
	static void DrawDebugString(const struct FVector& TextLocation, const class FString& Text, class AActor* optionalTestBaseActor, const struct FColor& optionalTextColor, float optionalDuration);
	static void DrawDebugCone(const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32_t NumSides, const struct FColor& DrawColor, bool optionalBPersistentLines, float optionalLifetime);
	static void DrawDebugCylinder(const struct FVector& Start, const struct FVector& End, float Radius, int32_t Segments, uint8_t R, uint8_t G, uint8_t B, bool optionalBPersistentLines, float optionalLifetime);
	static void DrawDebugSphere(const struct FVector& Center, float Radius, int32_t Segments, uint8_t R, uint8_t G, uint8_t B, bool optionalBPersistentLines, float optionalLifetime);
	static void DrawDebugCoordinateSystem(const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, bool optionalBPersistentLines, float optionalLifetime);
	static void DrawDebugStar(const struct FVector& Position, float Size, uint8_t R, uint8_t G, uint8_t B, bool optionalBPersistentLines, float optionalLifetime);
	static void DrawDebugBox(const struct FVector& Center, const struct FVector& Extent, uint8_t R, uint8_t G, uint8_t B, bool optionalBPersistentLines, float optionalLifetime);
	static void DrawDebugPoint(const struct FVector& Position, float Size, const struct FLinearColor& PointColor, bool optionalBPersistentLines);
	static void DrawDebugLine(const struct FVector& LineStart, const struct FVector& LineEnd, uint8_t R, uint8_t G, uint8_t B, bool optionalBPersistentLines, float optionalLifetime);
	static void FlushPersistentDebugLines();
	static struct FVector GetBasedPosition(const struct FBasedPosition& BP);
	static void SetBasedPosition(const struct FVector& Pos, class AActor* optionalForcedBase, struct FBasedPosition& BP);
	static struct FVector BP2Vect(const struct FBasedPosition& BP);
	static void Vect2BP(const struct FVector& Pos, class AActor* optionalForcedBase, struct FBasedPosition& BP);
	void SetForcedInitialReplicatedProperty(class UProperty* PropToReplicate, bool bAdd);
	void eventReplicatedArrayEvent(const struct FName& VarName, int32_t ArrayIndex);
	void eventReplicatedEvent(const struct FName& VarName);
	struct FVector GetAggregateBaseVelocity(class AActor* optionalTestBase);
	bool IsOwnedBy(class AActor* TestActor);
	class AActor* GetBaseMost();
	bool IsBasedOn(class AActor* TestActor);
	void SearchForBaseBelow(float HeightBelow, class AActor*& NewBase, struct FVector& HitNormal);
	void FindBase();
	void SetOwner(class AActor* NewOwner);
	void SetBase(class AActor* NewBase, const struct FVector& optionalNewFloor, class USkeletalMeshComponent* optionalSkelComp, const struct FName& optionalAttachName);
	float GetTerminalVelocity();
	void AutonomousPhysics(float DeltaSeconds);
	bool MoveSmooth(const struct FVector& Delta);
	int32_t fixedTurn(int32_t Current, int32_t Desired, int32_t DeltaRate);
	void SetHardAttach(bool optionalBNewHardAttach);
	bool SetRelativeLocation(const struct FVector& NewLocation);
	bool SetRelativeRotation(const struct FRotator& NewRotation);
	void SetZone(bool bForceRefresh);
	EMoveDir MovingWhichWay(float& Amount);
	bool SetRotation(const struct FRotator& NewRotation);
	bool SetLocation(const struct FVector& NewLocation);
	bool Move(const struct FVector& Delta);
	void SetCollisionAndCollisionType(ECollisionType NewCollisionType);
	void SetDrawScale3D(const struct FVector& NewScale3D);
	void SetDrawScale(float NewScale);
	void SetCollisionType(ECollisionType NewCollisionType);
	void SetCollisionSize(float NewRadius, float NewHeight);
	void SetCollision(bool optionalBNewColActors, bool optionalBNewBlockActors, bool optionalBNewIgnoreEncroachers);
	void Sleep(float Seconds);
	class FString ConsoleCommand(const class FString& Command, bool optionalBWriteToLog);
	void ForceUpdateComponents(bool optionalBCollisionUpdate, bool optionalBTransformOnly);
};

// Class Engine.ApexDestructibleActor
// 0x0068 (0x0240 - 0x02A8)
class AApexDestructibleActor : public AActor
{
public:
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                              // 0x0240 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	uint32_t                                           bFractureMaterialOverride : 1;                 // 0x0248 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class TArray<class UFractureMaterial*>             FractureMaterials;                             // 0x0250 (0x0010) [0x0000000000400043] (CPF_Edit | CPF_Const | CPF_EditConstArray | CPF_NeedCtorLink)
	class UApexStaticDestructibleComponent*            StaticDestructibleComponent;                   // 0x0260 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	int32_t                                            LOD;                                           // 0x0268 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<uint8_t>                              VisibilityFactors;                             // 0x0270 (0x0010) [0x0000000000500000] (CPF_NeedCtorLink)
	class TArray<class UParticleSystem*>               FractureParticleEffects;                       // 0x0280 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	struct FPointer                                    EnqueuedFractureParametersCriticalSection;     // 0x0290 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)
	class TArray<struct FSpawnFractureEmitterParameters> EnqueuedFractureParameters;                    // 0x0298 (0x0010) [0x0000000000003000] (CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ApexDestructibleActor");
		}

		return uClassPointer;
	};

	void OnSetMaterial(class USeqAct_SetMaterial* Action);
	void TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class UIDamageCauser* DamageCauser, float optionalDamageFalloffExponent, class UDamagePipeline* optionalPipeline);
	void TakeDamage(float Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& HitDirection, class UClass* DamageType, const struct FTraceHitInfo& optionalHitInfo, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalDamagePipeline);
	void eventPostBeginPlay();
	void CacheFractureEffects();
	void eventSpawnFractureEmitter(class UParticleSystem* EmitterTemplate, const struct FVector& SpawnLocation, const struct FVector& SpawnDirection);
};

// Class Engine.ApexDestructibleActorSpawnable
// 0x0000 (0x02A8 - 0x02A8)
class AApexDestructibleActorSpawnable : public AApexDestructibleActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ApexDestructibleActorSpawnable");
		}

		return uClassPointer;
	};

};

// Class Engine.Brush
// 0x0030 (0x0240 - 0x0270)
class ABrush : public AActor
{
public:
	ECsgOper                                           CsgOper;                                       // 0x0240 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FColor                                      BrushColor;                                    // 0x0244 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            PolyFlags;                                     // 0x0248 (0x0004) [0x0000000000000000]               
	uint32_t                                           bColored : 1;                                  // 0x024C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bSolidWhenSelected : 1;                        // 0x024C (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bPlaceableFromClassBrowser : 1;                // 0x024C (0x0004) [0x0000000000000000] [0x00000004] 
	class UModel*                                      Brush;                                         // 0x0250 (0x0008) [0x000000000000000A] (CPF_Const | CPF_ExportObject)
	class UBrushComponent*                             BrushComponent;                                // 0x0258 (0x0008) [0x00000000040A000A] (CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	class TArray<struct FGeomSelection>                SavedSelections;                               // 0x0260 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Brush");
		}

		return uClassPointer;
	};

};

// Class Engine.BrushShape
// 0x0000 (0x0270 - 0x0270)
class ABrushShape : public ABrush
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BrushShape");
		}

		return uClassPointer;
	};

};

// Class Engine.Volume
// 0x0018 (0x0270 - 0x0288)
class AVolume : public ABrush
{
public:
	class TArray<class AActor*>                        AssociatedActors;                              // 0x0270 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bForcePawnWalk : 1;                            // 0x0280 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bProcessAllActors : 1;                         // 0x0280 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bPawnsOnly : 1;                                // 0x0280 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Volume");
		}

		return uClassPointer;
	};

	void eventProcessActorSetVolume(class AActor* Other);
	void eventCollisionChanged();
	void OnToggle(class USeqAct_Toggle* Action);
	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	void eventSetInitialState();
	void eventPostBeginPlay();
	void AssociateActor(class AActor* ActorToAssociate);
	bool EncompassesPoint(const struct FVector& Loc);
	bool Encompasses(class AActor* Other);
};

// Class Engine.BlockingVolume
// 0x0008 (0x0288 - 0x0290)
class ABlockingVolume : public AVolume
{
public:
	uint32_t                                           bBlockCamera : 1;                              // 0x0288 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bBlockProjectiles : 1;                         // 0x0288 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BlockingVolume");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* Action);
};

// Class Engine.DynamicBlockingVolume
// 0x0008 (0x0290 - 0x0298)
class ADynamicBlockingVolume : public ABlockingVolume
{
public:
	uint32_t                                           bEnabled : 1;                                  // 0x0290 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DynamicBlockingVolume");
		}

		return uClassPointer;
	};

	void ApplyCheckpointRecord(struct FDynamicBlockingVolumeCheckpointRecord& Record);
	void CreateCheckpointRecord(struct FDynamicBlockingVolumeCheckpointRecord& Record);
	void eventPostBeginPlay();
};

// Class Engine.ColorScaleVolume
// 0x0010 (0x0288 - 0x0298)
class AColorScaleVolume : public AVolume
{
public:
	struct FVector                                     ColorScale;                                    // 0x0288 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              InterpTime;                                    // 0x0294 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ColorScaleVolume");
		}

		return uClassPointer;
	};

	void eventUnTouch(class AActor* Other);
	void eventTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};

// Class Engine.CullDistanceVolume
// 0x0018 (0x0288 - 0x02A0)
class ACullDistanceVolume : public AVolume
{
public:
	class TArray<struct FCullDistanceSizePair>         CullDistances;                                 // 0x0288 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bEnabled : 1;                                  // 0x0298 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CullDistanceVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.EnvironmentMapSelectorVolume
// 0x0018 (0x0288 - 0x02A0)
class AEnvironmentMapSelectorVolume : public AVolume
{
public:
	float                                              LerpDepth;                                     // 0x0288 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UTextureCube*                                LocalEnvironmentMap;                           // 0x0290 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UDrawBoxComponent*                           InnerLerpMarginBox;                            // 0x0298 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EnvironmentMapSelectorVolume");
		}

		return uClassPointer;
	};

	void eventUnTouch(class AActor* Other);
	void eventTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};

// Class Engine.LevelGridVolume
// 0x00F8 (0x0288 - 0x0380)
class ALevelGridVolume : public AVolume
{
public:
	class FString                                      LevelGridVolumeName;                           // 0x0288 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	ELevelGridCellShape                                CellShape;                                     // 0x0298 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            Subdivisions[0x3];                             // 0x029C (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LoadingDistance;                               // 0x02A8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              KeepLoadedRange;                               // 0x02AC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FKConvexElem                                CellConvexElem;                                // 0x02B0 (0x00D0) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LevelGridVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.LevelStreamingVolume
// 0x0020 (0x0288 - 0x02A8)
class ALevelStreamingVolume : public AVolume
{
public:
	class TArray<class ULevelStreaming*>               StreamingLevels;                               // 0x0288 (0x0010) [0x0000000001420003] (CPF_Edit | CPF_Const | CPF_EditConst | CPF_NeedCtorLink)
	uint32_t                                           bEditorPreVisOnly : 1;                         // 0x0298 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDisabled : 1;                                 // 0x0298 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bTestDistanceToVolume : 1;                     // 0x0298 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	EStreamingVolumeUsage                              StreamingUsage;                                // 0x029C (0x0001) [0x0000000000000001] (CPF_Edit)    
	EStreamingVolumeUsage                              Usage;                                         // 0x029D (0x0001) [0x0000000020000000]  CPF_Deprecated)
	ECurrentVisibility                                 CurrentVisibility;                             // 0x029E (0x0001) [0x0000000000000000]               
	float                                              TestVolumeDistance;                            // 0x02A0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LevelStreamingVolume");
		}

		return uClassPointer;
	};

	void ApplyCheckpointRecord(struct FLevelStreamingVolumeCheckpointRecord& Record);
	void CreateCheckpointRecord(struct FLevelStreamingVolumeCheckpointRecord& Record);
	void OnToggle(class USeqAct_Toggle* Action);
};

// Class Engine.LightmassCharacterIndirectDetailVolume
// 0x0000 (0x0288 - 0x0288)
class ALightmassCharacterIndirectDetailVolume : public AVolume
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LightmassCharacterIndirectDetailVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.LightmassImportanceVolume
// 0x0000 (0x0288 - 0x0288)
class ALightmassImportanceVolume : public AVolume
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LightmassImportanceVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshBoundsVolume
// 0x0000 (0x0288 - 0x0288)
class ANavMeshBoundsVolume : public AVolume
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshBoundsVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.NxGenericForceFieldBrush
// 0x00E0 (0x0288 - 0x0368)
class ANxGenericForceFieldBrush : public AVolume
{
public:
	int32_t                                            ExcludeChannel;                                // 0x0288 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRBCollisionChannelContainer                CollideWithChannels;                           // 0x028C (0x0004) [0x0000000000000001] (CPF_Edit)    
	ERBCollisionChannel                                RBChannel;                                     // 0x0290 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EFFB_ForceFieldCoordinates                         Coordinates;                                   // 0x0291 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Constant;                                      // 0x0294 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierX;                           // 0x02A0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierY;                           // 0x02AC (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierZ;                           // 0x02B8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionTarget;                                // 0x02C4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierX;                           // 0x02D0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierY;                           // 0x02DC (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierZ;                           // 0x02E8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityTarget;                                // 0x02F4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Noise;                                         // 0x0300 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     FalloffLinear;                                 // 0x030C (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     FalloffQuadratic;                              // 0x0318 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              TorusRadius;                                   // 0x0324 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    ForceField;                                    // 0x0328 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      ConvexMeshes;                                  // 0x0330 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      ExclusionShapes;                               // 0x0340 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      ExclusionShapePoses;                           // 0x0350 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    LinearKernel;                                  // 0x0360 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxGenericForceFieldBrush");
		}

		return uClassPointer;
	};

	bool StopsProjectile(class AProjectile* P);
	void eventPostBeginPlay();
};

// Class Engine.PathBlockingVolume
// 0x0000 (0x0288 - 0x0288)
class APathBlockingVolume : public AVolume
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PathBlockingVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.PhysicsVolume
// 0x0088 (0x0288 - 0x0310)
class APhysicsVolume : public AVolume
{
public:
	struct FPointer                                    VfTable_IIGearboxCollisionGridVolume;          // 0x0288 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FVector                                     ZoneVelocity;                                  // 0x0290 (0x000C) [0x0000000200000001] (CPF_Edit)    
	uint32_t                                           bVelocityAffectsWalking : 1;                   // 0x029C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bPainCausing : 1;                              // 0x029C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bAIShouldIgnorePain : 1;                       // 0x029C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bEntryPain : 1;                                // 0x029C (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           BACKUP_bPainCausing : 1;                       // 0x029C (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bDestructive : 1;                              // 0x029C (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bNoInventory : 1;                              // 0x029C (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bMoveProjectiles : 1;                          // 0x029C (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bBounceVelocity : 1;                           // 0x029C (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bNeutralZone : 1;                              // 0x029C (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bCrowdAgentsPlayDeathAnim : 1;                 // 0x029C (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	uint32_t                                           bPhysicsOnContact : 1;                         // 0x029C (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bWaterVolume : 1;                              // 0x029C (0x0004) [0x0000000000000000] [0x00001000] 
	float                                              GroundFriction;                                // 0x02A0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TerminalVelocity;                              // 0x02A4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DamagePerSec;                                  // 0x02A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UClass*                                      DamageType;                                    // 0x02B0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UDamageTypeDefinition*                       DamageTypeDefinition;                          // 0x02B8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UImpactDefinition*                           ImpactDefinition;                              // 0x02C0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Priority;                                      // 0x02C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FluidFriction;                                 // 0x02CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              PainInterval;                                  // 0x02D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RigidBodyDamping;                              // 0x02D4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxDampingForce;                               // 0x02D8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class AInfo*                                       PainTimer;                                     // 0x02E0 (0x0008) [0x0000000000000000]               
	class AController*                                 DamageInstigator;                              // 0x02E8 (0x0008) [0x0000000000000000]               
	class APhysicsVolume*                              NextPhysicsVolume;                             // 0x02F0 (0x0008) [0x0000000000000000]               
	int32_t                                            CollisionGridVolumeIndex;                      // 0x02F8 (0x0004) [0x0000000000000000]               
	struct FGuid                                       CollisionGridVolumeGuid;                       // 0x02FC (0x0010) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PhysicsVolume");
		}

		return uClassPointer;
	};

	void ApplyCheckpointRecord(struct FPhysicsVolumeCheckpointRecord& Record);
	void CreateCheckpointRecord(struct FPhysicsVolumeCheckpointRecord& Record);
	bool ShouldSaveForCheckpoint();
	void OnSetDamageInstigator(class USeqAct_SetDamageInstigator* Action);
	void NotifyPawnBecameViewTarget(class APawn* P, class APlayerController* PC);
	void ModifyPlayer(class APawn* PlayerPawn);
	void CausePainTo(class AActor* Other);
	void eventTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TimerPop(class AVolumeTimer* T);
	void eventCollisionChanged();
	void OnToggle(class USeqAct_Toggle* inAction);
	void eventPawnLeavingVolume(class APawn* Other);
	void eventPawnEnteredVolume(class APawn* Other);
	void eventActorLeavingVolume(class AActor* Other);
	void eventActorEnteredVolume(class AActor* Other);
	void eventPhysicsChangedFor(class AActor* Other);
	void Reset();
	void eventPostBeginPlay();
	struct FVector GetZoneVelocityForActor(class AActor* TheActor);
	float GetGravityZ();
};

// Class Engine.DefaultPhysicsVolume
// 0x0000 (0x0310 - 0x0310)
class ADefaultPhysicsVolume : public APhysicsVolume
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DefaultPhysicsVolume");
		}

		return uClassPointer;
	};

	void eventDestroyed();
};

// Class Engine.DynamicPhysicsVolume
// 0x0008 (0x0310 - 0x0318)
class ADynamicPhysicsVolume : public APhysicsVolume
{
public:
	uint32_t                                           bEnabled : 1;                                  // 0x0310 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DynamicPhysicsVolume");
		}

		return uClassPointer;
	};

	void eventPostBeginPlay();
};

// Class Engine.GravityVolume
// 0x0008 (0x0310 - 0x0318)
class AGravityVolume : public APhysicsVolume
{
public:
	float                                              GravityZ;                                      // 0x0310 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GravityVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.LadderVolume
// 0x0038 (0x0310 - 0x0348)
class ALadderVolume : public APhysicsVolume
{
public:
	struct FRotator                                    WallDir;                                       // 0x0310 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     LookDir;                                       // 0x031C (0x000C) [0x0000000000000000]               
	struct FVector                                     ClimbDir;                                      // 0x0328 (0x000C) [0x0000000000000000]               
	uint32_t                                           bNoPhysicalLadder : 1;                         // 0x0334 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAutoPath : 1;                                 // 0x0334 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bAllowLadderStrafing : 1;                      // 0x0334 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	class APawn*                                       PendingClimber;                                // 0x0338 (0x0008) [0x0000000000000000]               
	class UArrowComponent*                             WallDirArrow;                                  // 0x0340 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LadderVolume");
		}

		return uClassPointer;
	};

	void eventPhysicsChangedFor(class AActor* Other);
	void eventPawnLeavingVolume(class APawn* P);
	void eventPawnEnteredVolume(class APawn* P);
	bool InUse(class APawn* Ignored);
	void eventPostBeginPlay();
};

// Class Engine.WaterVolume
// 0x0010 (0x0310 - 0x0320)
class AWaterVolume : public APhysicsVolume
{
public:
	class UClass*                                      EntryActor;                                    // 0x0310 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UClass*                                      ExitActor;                                     // 0x0318 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WaterVolume");
		}

		return uClassPointer;
	};

	void PlayExitSplash(class AActor* Other);
	void eventUnTouch(class AActor* Other);
	void PlayEntrySplash(class AActor* Other);
	void eventTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};

// Class Engine.PortalVolume
// 0x0000 (0x0288 - 0x0288)
class APortalVolume : public AVolume
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PortalVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.PostProcessVolume
// 0x0130 (0x0288 - 0x03B8)
class APostProcessVolume : public AVolume
{
public:
	float                                              Priority;                                      // 0x0288 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FPostProcessSettings                        Settings;                                      // 0x0290 (0x0118) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class APostProcessVolume*                          NextLowerPriorityVolume;                       // 0x03A8 (0x0008) [0x0000000001002002] (CPF_Const | CPF_Transient)
	uint32_t                                           bEnabled : 1;                                  // 0x03B0 (0x0004) [0x0000000000000021] [0x00000001] (CPF_Edit | CPF_Net)
	uint32_t                                           bIgnoredBySpectators : 1;                      // 0x03B0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PostProcessVolume");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* Action);
};

// Class Engine.PrecomputedVisibilityOverrideVolume
// 0x0020 (0x0288 - 0x02A8)
class APrecomputedVisibilityOverrideVolume : public AVolume
{
public:
	class TArray<class AActor*>                        OverrideVisibleActors;                         // 0x0288 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class AActor*>                        OverrideInvisibleActors;                       // 0x0298 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PrecomputedVisibilityOverrideVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.PrecomputedVisibilityVolume
// 0x0000 (0x0288 - 0x0288)
class APrecomputedVisibilityVolume : public AVolume
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PrecomputedVisibilityVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_ForceFieldExcludeVolume
// 0x0008 (0x0288 - 0x0290)
class ARB_ForceFieldExcludeVolume : public AVolume
{
public:
	int32_t                                            ForceFieldChannel;                             // 0x0288 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_ForceFieldExcludeVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.TriggerVolume
// 0x0028 (0x0288 - 0x02B0)
class ATriggerVolume : public AVolume
{
public:
	struct FPointer                                    VfTable_IIGearboxCollisionGridVolume;          // 0x0288 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IITeleportAware;                       // 0x0290 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	int32_t                                            CollisionGridVolumeIndex;                      // 0x0298 (0x0004) [0x0000000000000000]               
	struct FGuid                                       CollisionGridVolumeGuid;                       // 0x029C (0x0010) [0x0000000000000000]               
	uint32_t                                           bTeleportThroughAware : 1;                     // 0x02AC (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TriggerVolume");
		}

		return uClassPointer;
	};

	bool StopsProjectile(class AProjectile* P);
	void eventPostBeginPlay();
};

// Class Engine.DynamicTriggerVolume
// 0x0008 (0x02B0 - 0x02B8)
class ADynamicTriggerVolume : public ATriggerVolume
{
public:
	uint32_t                                           bEnabled : 1;                                  // 0x02B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DynamicTriggerVolume");
		}

		return uClassPointer;
	};

	void eventPostBeginPlay();
};

// Class Engine.Camera
// 0x02C0 (0x0240 - 0x0500)
class ACamera : public AActor
{
public:
	class APlayerController*                           PCOwner;                                       // 0x0240 (0x0008) [0x0000000000000000]               
	struct FName                                       CameraStyle;                                   // 0x0248 (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	float                                              DefaultFOV;                                    // 0x0250 (0x0004) [0x0000000000004000] (CPF_Config)  
	uint32_t                                           bLockedFOV : 1;                                // 0x0254 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bConstrainAspectRatio : 1;                     // 0x0254 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bEnableFading : 1;                             // 0x0254 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bForceDisableTemporalAA : 1;                   // 0x0254 (0x0004) [0x0000000000002000] [0x00000008] (CPF_Transient)
	uint32_t                                           bEnableColorScaling : 1;                       // 0x0254 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bEnableColorScaleInterp : 1;                   // 0x0254 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              LockedFOV;                                     // 0x0258 (0x0004) [0x0000000000000000]               
	float                                              ConstrainedAspectRatio;                        // 0x025C (0x0004) [0x0000000000000000]               
	float                                              DefaultAspectRatio;                            // 0x0260 (0x0004) [0x0000000000000000]               
	float                                              OffAxisYawAngle;                               // 0x0264 (0x0004) [0x0000000000000000]               
	float                                              OffAxisPitchAngle;                             // 0x0268 (0x0004) [0x0000000000000000]               
	struct FColor                                      FadeColor;                                     // 0x026C (0x0004) [0x0000000000000000]               
	float                                              FadeAmount;                                    // 0x0270 (0x0004) [0x0000000000000000]               
	float                                              CamOverridePostProcessAlpha;                   // 0x0274 (0x0004) [0x0000000000000000]               
	struct FPostProcessSettings                        CamPostProcessSettings;                        // 0x0278 (0x0118) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FRenderingPerformanceOverrides              RenderingOverrides;                            // 0x0390 (0x0004) [0x0000000000000000]               
	struct FVector                                     ColorScale;                                    // 0x0394 (0x000C) [0x0000000000000000]               
	struct FVector                                     DesiredColorScale;                             // 0x03A0 (0x000C) [0x0000000000000000]               
	struct FVector                                     OriginalColorScale;                            // 0x03AC (0x000C) [0x0000000000000000]               
	float                                              ColorScaleInterpDuration;                      // 0x03B8 (0x0004) [0x0000000000000000]               
	float                                              ColorScaleInterpStartTime;                     // 0x03BC (0x0004) [0x0000000000000000]               
	struct FTCameraCache                               CameraCache;                                   // 0x03C0 (0x0020) [0x0000000000000000]               
	struct FTCameraCache                               LastFrameCameraCache;                          // 0x03E0 (0x0020) [0x0000000000000000]               
	struct FTViewTarget                                ViewTarget;                                    // 0x0400 (0x0038) [0x0000000000000000]               
	struct FTViewTarget                                PendingViewTarget;                             // 0x0438 (0x0038) [0x0000000000000000]               
	float                                              BlendTimeToGo;                                 // 0x0470 (0x0004) [0x0000000000000000]               
	struct FVector2D                                   FadeAlpha;                                     // 0x0474 (0x0008) [0x0000000000000000]               
	float                                              FadeTime;                                      // 0x047C (0x0004) [0x0000000000000000]               
	float                                              FadeTimeRemaining;                             // 0x0480 (0x0004) [0x0000000000000000]               
	class TArray<class AEmitterCameraLensEffectBase*>  CameraLensEffects;                             // 0x0488 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class UCameraAnimInst*                             AnimInstPool[0x8];                             // 0x0498 (0x0040) [0x0000000000000000]               
	class TArray<class UCameraAnimInst*>               ActiveAnims;                                   // 0x04D8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<class UCameraAnimInst*>               FreeAnims;                                     // 0x04E8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class ADynamicCameraActor*                         AnimCameraActor;                               // 0x04F8 (0x0008) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Camera");
		}

		return uClassPointer;
	};

	void StopCameraAnim(class UCameraAnimInst* AnimInst, bool optionalBImmediate);
	void StopAllCameraAnimsByType(class UCameraAnim* Anim, bool optionalBImmediate);
	void StopAllCameraAnims(bool optionalBImmediate);
	class UCameraAnimInst* PlayCameraAnim(class UCameraAnim* Anim, float optionalRate, float optionalScale, float optionalBlendInTime, float optionalBlendOutTime, bool optionalBLoop, bool optionalBRandomStartTime, float optionalDuration, bool optionalBSingleInstance, EAxis optionalMirrorAxes);
	void ClearAllCameraShakes();
	void StopCameraShake(class UCameraShake* Shake);
	void PlayCameraShake(class UCameraShake* Shake, float Scale, ECameraAnimPlaySpace optionalPlaySpace, const struct FRotator& optionalUserPlaySpaceRot);
	void ClearCameraLensEffects();
	void RemoveCameraLensEffect(class AEmitterCameraLensEffectBase* Emitter);
	void AddCameraLensEffect(class UClass* LensEffectEmitterClass);
	class AEmitterCameraLensEffectBase* FindCameraLensEffect(class UClass* LensEffectEmitterClass);
	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	void ProcessViewRotation(float DeltaTime, struct FRotator& OutViewRotation, struct FRotator& OutDeltaRot);
	void SetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& optionalTransitionParams);
	void UpdateViewTarget(float DeltaTime, struct FTViewTarget& OutVT);
	void FillCameraCache(struct FTPOV& NewPOV);
	void eventUpdateCamera(float DeltaTime);
	void SetDesiredColorScale(const struct FVector& NewColorScale, float InterpTime);
	struct FRotator GetCameraRotation();
	void GetCameraViewPoint(struct FVector& OutCamLoc, struct FRotator& OutCamRot);
	void SetFOV(float NewFOV);
	float GetFOVAngle();
	void InitializeFor(class APlayerController* PC);
	void UpdateCameraAnimations(float DeltaTime, struct FTPOV& OutPOV);
	void eventDestroyed();
	void PostBeginPlay();
};

// Class Engine.CameraActor
// 0x0148 (0x0240 - 0x0388)
class ACameraActor : public AActor
{
public:
	uint32_t                                           bConstrainAspectRatio : 1;                     // 0x0240 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bCamOverridePostProcess : 1;                   // 0x0240 (0x0004) [0x0000000020000000] [0x00000002]  CPF_Deprecated)
	float                                              AspectRatio;                                   // 0x0244 (0x0004) [0x0000000200000021] (CPF_Edit | CPF_Net)
	float                                              FOVAngle;                                      // 0x0248 (0x0004) [0x0000000200000021] (CPF_Edit | CPF_Net)
	float                                              CamOverridePostProcessAlpha;                   // 0x024C (0x0004) [0x0000000200000001] (CPF_Edit)    
	struct FPostProcessSettings                        CamOverridePostProcess;                        // 0x0250 (0x0118) [0x0000000200400001] (CPF_Edit | CPF_NeedCtorLink)
	class UDrawFrustumComponent*                       DrawFrustum;                                   // 0x0368 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	class UStaticMeshComponent*                        MeshComp;                                      // 0x0370 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	class TArray<class ACamera*>                       AssociatedCameras;                             // 0x0378 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CameraActor");
		}

		return uClassPointer;
	};

	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	void GetCameraView(float DeltaTime, struct FTPOV& OutPOV);
};

// Class Engine.DynamicCameraActor
// 0x0000 (0x0388 - 0x0388)
class ADynamicCameraActor : public ACameraActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DynamicCameraActor");
		}

		return uClassPointer;
	};

};

// Class Engine.Controller
// 0x00F0 (0x0240 - 0x0330)
class AController : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;           // 0x0240 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class APlayerStateInfo*                            PSI;                                           // 0x0248 (0x0008) [0x0000000000000000]               
	class UClass*                                      PlayerStateInfoClass;                          // 0x0250 (0x0008) [0x0000000000000000]               
	class APawn*                                       Pawn;                                          // 0x0258 (0x0008) [0x0000000104000020] (CPF_Net | CPF_EditInline)
	class APlayerReplicationInfo*                      PlayerReplicationInfo;                         // 0x0260 (0x0008) [0x0000000004000000] (CPF_EditInline)
	class APlayerStateInfo*                            ClientPendingPSI;                              // 0x0268 (0x0008) [0x0000000100000020] (CPF_Net)     
	class APlayerReplicationInfo*                      ClientPendingPRI;                              // 0x0270 (0x0008) [0x0000000100000020] (CPF_Net)     
	uint32_t                                           bClientAckInfoClasses : 1;                     // 0x0278 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bIsPlayer : 1;                                 // 0x0278 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bIsHumanPlayer : 1;                            // 0x0278 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bShowControllerInfo : 1;                       // 0x0278 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bGodMode : 1;                                  // 0x0278 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bNonCheatGodMode : 1;                          // 0x0278 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bDontTargetMode : 1;                           // 0x0278 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bSoaking : 1;                                  // 0x0278 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bSlowerZAcquire : 1;                           // 0x0278 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bNotifyPostLanded : 1;                         // 0x0278 (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bNotifyApex : 1;                               // 0x0278 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bPauseNavigationUpdate : 1;                    // 0x0278 (0x0004) [0x0000000000000000] [0x00000800] 
	uint32_t                                           bNotifyFallingHitWall : 1;                     // 0x0278 (0x0004) [0x0000000000000000] [0x00001000] 
	uint32_t                                           bPreciseDestination : 1;                       // 0x0278 (0x0004) [0x0000000000000000] [0x00002000] 
	uint32_t                                           bSeeFriendly : 1;                              // 0x0278 (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bServerIsAutomatedTesting : 1;                 // 0x0278 (0x0004) [0x0000000000000000] [0x00008000] 
	int32_t                                            CombatantID;                                   // 0x027C (0x0004) [0x0000000000000000]               
	class AController*                                 NextController;                                // 0x0280 (0x0008) [0x0000000000000002] (CPF_Const)   
	struct FRotator                                    PrevRotation;                                  // 0x0288 (0x000C) [0x0000000000002000] (CPF_Transient)
	uint8_t                                            bFire;                                         // 0x0294 (0x0001) [0x0000000000000004] (CPF_Input)   
	uint8_t                                            bAltFire;                                      // 0x0295 (0x0001) [0x0000000000000004] (CPF_Input)   
	struct FName                                       MatchEndedStateName;                           // 0x0298 (0x0008) [0x0000000000000000]               
	float                                              MinHitWall;                                    // 0x02A0 (0x0004) [0x0000000000000000]               
	class UClass*                                      NavigationHandleClass;                         // 0x02A8 (0x0008) [0x0000000000000000]               
	class UNavigationHandle*                           NavigationHandle;                              // 0x02B0 (0x0008) [0x0000000004000000] (CPF_EditInline)
	struct FBasedPosition                              FocalPosition;                                 // 0x02B8 (0x0038) [0x0000000000000000]               
	class AActor*                                      Focus;                                         // 0x02F0 (0x0008) [0x0000000000000000]               
	class AActor*                                      StartSpot;                                     // 0x02F8 (0x0008) [0x0000000000000000]               
	class APawn*                                       Enemy;                                         // 0x0300 (0x0008) [0x0000000000000000]               
	class TArray<struct FVisiblePortalInfo>            VisiblePortals;                                // 0x0308 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FRotator                                    OldBasedRotation;                              // 0x0318 (0x000C) [0x0000000000000002] (CPF_Const)   
	struct FVector                                     NavMeshPath_SearchExtent_Modifier;             // 0x0324 (0x000C) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Controller");
		}

		return uClassPointer;
	};

	void ClientSetAutomatedTestingFlag(bool bIsTesting);
	bool IsUsingVehicleEx(bool IncludeAttachedRiders, class AVehicle*& TheVehicleOrWeaponPawn);
	bool IsUsingVehicle(bool IncludeAttachedRiders);
	bool eventRemoveInstanceData(const struct FName& DataName);
	bool eventGetInstanceData(const struct FName& DataName, class TArray<struct FInstanceDataItem2>& InstanceData);
	bool eventGetUniqueInstanceData(const struct FName& DataName, class TArray<struct FInstanceDataItem2>& InstanceData);
	bool eventSetInstanceData(const struct FInstanceDataItem2& InstanceData, bool optionalBAllowDuplicateNames);
	class APawn* GetInstanceDataPawn();
	bool ShouldSwitchToBestWeapon();
	class APawn* GetWorldPawn();
	void AddAccuracyImpulse(float Delta, bool bOffHand);
	bool eventGeneratePathToLocation(const struct FVector& Goal, float optionalWithinDistance, bool optionalBAllowPartialPath);
	bool eventGeneratePathToActor(class AActor* Goal, float optionalWithinDistance, bool optionalBAllowPartialPath);
	void eventInterpolationFinished(class USeqAct_Interp* InterpAction);
	void eventInterpolationStarted(class USeqAct_Interp* InterpAction, class UInterpGroupInst* GroupInst);
	void DisplayDebugResourcePoolManager(class AResourcePoolManager* PoolManager, const class FString& ManagerDescription, class AHUD* HUD, float& out_YL, float& out_YPos);
	void DisplayDebugResourcePools(class AHUD* HUD, float& out_YL, float& out_YPos);
	class UIResourcePoolProvider* GetResourcePoolProvider();
	class UCharacterClassDefinition* GetCharacterClass();
	float GetDestinationOffset();
	void InitNavigationHandle();
	void ReadyForLift();
	void SendMessageW(class APlayerReplicationInfo* Recipient, const struct FName& MessageType, float Wait, class UClass* optionalDamageType);
	void eventCurrentLevelUnloaded();
	bool eventIsInCombat(bool optionalBForceCheck);
	bool eventIsSpectating();
	void OnToggleHidden(class USeqAct_ToggleHidden* Action);
	void NotifyAddInventory(class AInventory* NewItem);
	void OnModifyHealth(class USeqAct_ModifyHealth* Action);
	bool NotifyCoverClaimViolation(class AController* NewClaim, class ACoverLink* Link, int32_t SlotIdx);
	void eventNotifyCoverAdjusted();
	void NotifyCoverDisabled(class ACoverLink* Link, int32_t SlotIdx, bool optionalBAdjacentIdx);
	void OnSetVelocity(class USeqAct_SetVelocity* Action);
	void OnSetPhysics(class USeqAct_SetPhysics* Action);
	bool GetNonCheatGodMode();
	void SetNonCheatGodMode(bool NewMode);
	bool GetGodMode();
	void SetGodMode(bool NewMode);
	bool InGodMode();
	void OnToggleGodMode(class USeqAct_ToggleGodMode* inAction);
	void OnTeleport(class USeqAct_Teleport* Action);
	bool IsDead();
	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	void StopLatentExecution();
	bool InLatentExecution(int32_t LatentActionNumber);
	void eventReachedPreciseDestination();
	void eventNotifyMissedJump();
	void eventNotifyJumpApex();
	bool eventNotifyBump(class AActor* Other, const struct FVector& HitNormal);
	void eventNotifyFallingHitWall(const struct FVector& HitNormal, class AActor* Wall);
	bool eventNotifyHitWall(const struct FVector& HitNormal, class AActor* Wall);
	bool eventNotifyLanded(const struct FVector& HitNormal, class AActor* FloorActor);
	bool eventNotifyHeadVolumeChange(class APhysicsVolume* NewVolume);
	void eventNotifyPhysicsVolumeChange(class APhysicsVolume* NewVolume);
	bool LandingShake();
	bool IsAimingAt(class AActor* ATarget, float Epsilon);
	void GetActorEyesViewPoint(struct FVector& out_Location, struct FRotator& out_Rotation);
	void GetPlayerViewPoint(bool optionalBMustBeCurrent, struct FVector& out_Location, struct FRotator& out_Rotation);
	bool eventMoverFinished();
	void WaitForMover(class AInterpActor* M);
	bool eventAllowDetourTo(class ANavigationPoint* N);
	void eventMayFall(bool bFloor, const struct FVector& FloorNormal);
	void EndClimbLadder();
	void eventLongFall();
	void WaitForLanding(float optionalWaitDuration);
	void FinishRotation();
	void eventEnemyNotVisible();
	void eventSeeMonster(class APawn* Seen);
	void eventSeePlayer(class APawn* Seen);
	class APawn* PickTarget(class UClass* TargetClass, const struct FVector& FireDir, const struct FVector& projStart, float MaxRange, float& bestAim, float& bestDist);
	void NotifyChangedWeapon(class AWeapon* PrevWeapon, class AWeapon* NewWeapon, bool bOffHandWeapon);
	void ClientSwitchToBestWeapon(bool optionalBForceNewWeapon);
	void SwitchToBestWeapon(bool optionalBForceNewWeapon);
	bool CanHoldWeapon(class APawn* Holder, class AWeapon* TestWeapon, bool bHoldInOffHand);
	void ReceiveProjectileWarning(class AProjectile* Proj);
	void ReceiveWarning(class APawn* shooter, float projSpeed, const struct FVector& FireDir);
	void InstantWarnTarget(class AActor* InTarget, class AWeapon* FiredWeapon, const struct FVector& FireDir);
	struct FRotator GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc);
	void UnTouchedPickupable(class UIPickupable* Pickup);
	void TouchedPickupable(class UIPickupable* Pickup);
	void HandlePickup(class AInventory* Inv);
	void eventStopFiring();
	bool FireWeaponAt(class AActor* inActor);
	float eventRatePickup(class AActor* PickupHolder, class UClass* inPickup);
	void WarnProjExplode(class AProjectile* Proj);
	void NotifyProjLanded(class AProjectile* Proj);
	void NotifyKilled(class AController* Killer, class AController* Killed, class APawn* KilledPawn, class UClass* damageTyp);
	void SetCharacter(const class FString& inCharacter);
	void ServerGivePawn();
	void ServerRestartPlayer();
	uint8_t GetTeamNum();
	void NotifyRecentDamage(float DamageAmount, class AActor* DamagedActor, class UDamageTypeDefinition* DamageTypeDefinition, const struct FVector& DamageLoc, int32_t optionalDamageEventFlags);
	void NotifyTakeHit(class AController* InstigatedBy, class APawn* HitPawn, const struct FVector& HitLocation, float Damage, class UClass* DamageType, const struct FVector& Momentum, class UDamagePipeline* optionalPipeline);
	void EnemyJustTeleported();
	bool BeyondFogDistance(const struct FVector& ViewPoint, const struct FVector& OtherPoint);
	void SpawningProcessComplete();
	void Restart(bool bVehicleTransition);
	void ClientAckInfoClassInitialization();
	void CleanupPRI();
	void eventDestroyed();
	void eventNotifyPostLanded();
	bool GamePlayEndedState();
	void PawnDied(class APawn* inPawn);
	void eventUnPossess();
	void eventPossess(class APawn* inPawn, bool bVehicleTransition);
	void OnPossess(class USeqAct_Possess* inAction);
	void eventReplicatedEvent(const struct FName& VarName);
	void ClientSetRotation(const struct FRotator& NewRotation, bool optionalBResetCamera);
	void ClientSetLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation);
	void Reset();
	void eventPostBeginPlay();
	void eventSetSkelControlScale(const struct FName& SkelControlName, float Scale);
	void eventSetMorphWeight(const struct FName& MorphNodeName, float MorphWeight);
	void eventStopActorFaceFXAnim();
	bool eventPlayActorFaceFXAnim(class UFaceFXAnimSet* AnimSet, const class FString& GroupName, const class FString& SeqName, class UAkEvent* AkEventToPlay);
	void eventFinishAnimControl(class UInterpGroup* InInterpGroup);
	void eventSetAnimPosition(const struct FName& SlotName, int32_t ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion);
	void eventBeginAnimControl(class UInterpGroup* InInterpGroup);
	struct FVector GetDestinationPosition();
	struct FVector GetFocalPoint();
	void SetFocalPoint(const struct FVector& FP, bool optionalBOffsetFromBase);
	bool IsLocalController();
	bool IsLocalPlayerController();
};

// Class Engine.AIController
// 0x0000 (0x0330 - 0x0330)
class AAIController : public AController
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AIController");
		}

		return uClassPointer;
	};

	void GetPlayerViewPoint(bool optionalBMustBeCurrent, struct FVector& out_Location, struct FRotator& out_Rotation);
	void eventSetTeam(int32_t inTeamIdx);
};

// Class Engine.PlayerController
// 0x02F8 (0x0330 - 0x0628)
class APlayerController : public AController
{
public:
	struct FPointer                                    VfTable_IIPlayerInputObserver;                 // 0x0330 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class UPlayer*                                     Player;                                        // 0x0338 (0x0008) [0x0000000000000002] (CPF_Const)   
	class ACamera*                                     PlayerCamera;                                  // 0x0340 (0x0008) [0x0000000004000001] (CPF_Edit | CPF_EditInline)
	class UClass*                                      CameraClass;                                   // 0x0348 (0x0008) [0x0000000000000002] (CPF_Const)   
	uint32_t                                           bFrozen : 1;                                   // 0x0350 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bPressedJump : 1;                              // 0x0350 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bDoubleJump : 1;                               // 0x0350 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bUpdatePosition : 1;                           // 0x0350 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bUpdating : 1;                                 // 0x0350 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bNeverSwitchOnPickup : 1;                      // 0x0350 (0x0004) [0x0000000000044000] [0x00000020] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bCheatFlying : 1;                              // 0x0350 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bCameraPositionLocked : 1;                     // 0x0350 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bShortConnectTimeOut : 1;                      // 0x0350 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bPendingDestroy : 1;                           // 0x0350 (0x0004) [0x0000000000000002] [0x00000200] (CPF_Const)
	uint32_t                                           bWasSaturated : 1;                             // 0x0350 (0x0004) [0x0000000000000002] [0x00000400] (CPF_Const)
	uint32_t                                           bAimingHelp : 1;                               // 0x0350 (0x0004) [0x0000000000044000] [0x00000800] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bCameraCut : 1;                                // 0x0350 (0x0004) [0x0000000000002000] [0x00001000] (CPF_Transient)
	uint32_t                                           bResolvingMovementTimeDiscrepancy : 1;         // 0x0350 (0x0004) [0x0000000000000000] [0x00002000] 
	uint32_t                                           bCinematicMode : 1;                            // 0x0350 (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bCinematicSplitScreen : 1;                     // 0x0350 (0x0004) [0x0000000000000000] [0x00008000] 
	uint32_t                                           bKismetEnabledCinematicMode : 1;               // 0x0350 (0x0004) [0x0000000000000000] [0x00010000] 
	uint32_t                                           bCinematicBlockScreenParticles : 1;            // 0x0350 (0x0004) [0x0000000000000000] [0x00020000] 
	uint32_t                                           bCinematicEnabledGodMode : 1;                  // 0x0350 (0x0004) [0x0000000000000000] [0x00040000] 
	uint32_t                                           bCinematicNoTarget : 1;                        // 0x0350 (0x0004) [0x0000000000000000] [0x00080000] 
	uint32_t                                           bInteractiveMode : 1;                          // 0x0350 (0x0004) [0x0000000000000000] [0x00100000] 
	uint32_t                                           bCinemaDisableInputMove : 1;                   // 0x0350 (0x0004) [0x0000000000000000] [0x00200000] 
	uint32_t                                           bCinemaDisableInputLook : 1;                   // 0x0350 (0x0004) [0x0000000000000000] [0x00400000] 
	uint32_t                                           bCinemaDisableInputButton : 1;                 // 0x0350 (0x0004) [0x0000000000000000] [0x00800000] 
	uint32_t                                           bCinematicModeHidePlayer : 1;                  // 0x0350 (0x0004) [0x0000000000000000] [0x01000000] 
	uint32_t                                           bIgnoreNetworkMessages : 1;                    // 0x0350 (0x0004) [0x0000000000000000] [0x02000000] 
	uint32_t                                           bReplicateAllPawns : 1;                        // 0x0350 (0x0004) [0x0000000000000000] [0x04000000] 
	uint32_t                                           bIsUsingStreamingVolumes : 1;                  // 0x0350 (0x0004) [0x0000000000000000] [0x08000000] 
	uint32_t                                           bIsExternalUIOpen : 1;                         // 0x0350 (0x0004) [0x0000000000000000] [0x10000000] 
	uint32_t                                           bIsControllerConnected : 1;                    // 0x0350 (0x0004) [0x0000000000000000] [0x20000000] 
	uint32_t                                           bCheckSoundOcclusion : 1;                      // 0x0350 (0x0004) [0x0000000000000000] [0x40000000] 
	uint32_t                                           bDebugCameraAnims : 1;                         // 0x0350 (0x0004) [0x0000000000000000] [0x80000000] 
	uint32_t                                           bFreeCamera : 1;                               // 0x0354 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bBlockCameraAnimsFromOverridingPostProcess : 1;// 0x0354 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bCheckRelevancyThroughPortals : 1;             // 0x0354 (0x0004) [0x0000000000044000] [0x00000004] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bDebugClientAdjustPosition : 1;                // 0x0354 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bIsInHolding : 1;                              // 0x0354 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bOverrideOnlineProfileName : 1;                // 0x0354 (0x0004) [0x0000000000044000] [0x00000020] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bEnableAnalogMovement : 1;                     // 0x0354 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bStatusMenuOpen : 1;                           // 0x0354 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bWantsCensoredContent : 1;                     // 0x0354 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bIsWarmupPaused : 1;                           // 0x0354 (0x0004) [0x0000000000002000] [0x00000200] (CPF_Transient)
	uint32_t                                           bHasPausedGame : 1;                            // 0x0354 (0x0004) [0x0000000000000000] [0x00000400] 
	float                                              MaxResponseTime;                               // 0x0358 (0x0004) [0x0000000000000000]               
	float                                              WaitDelay;                                     // 0x035C (0x0004) [0x0000000000000000]               
	class APawn*                                       AcknowledgedPawn;                              // 0x0360 (0x0008) [0x0000000000000000]               
	EDoubleClickDir                                    DoubleClickDir;                                // 0x0368 (0x0001) [0x0000000000000000]               
	uint8_t                                            LastAckedAnalogPct;                            // 0x0369 (0x0001) [0x0000000000000000]               
	uint8_t                                            bIgnoreMoveInput;                              // 0x036A (0x0001) [0x0000000000000000]               
	uint8_t                                            bIgnoreLookInput;                              // 0x036B (0x0001) [0x0000000000000000]               
	uint8_t                                            bIgnoreButtonInput;                            // 0x036C (0x0001) [0x0000000000000000]               
	uint8_t                                            bIgnoreOutlines;                               // 0x036D (0x0001) [0x0000000000000000]               
	uint8_t                                            LastModeTokenId;                               // 0x036E (0x0001) [0x0000000000000000]               
	uint8_t                                            bRun;                                          // 0x036F (0x0001) [0x0000000000000004] (CPF_Input)   
	uint8_t                                            bDuck;                                         // 0x0370 (0x0001) [0x0000000000000004] (CPF_Input)   
	uint8_t                                            NetPlayerIndex;                                // 0x0371 (0x0001) [0x0000000000200002] (CPF_Const)   
	class AActor*                                      ViewTarget;                                    // 0x0378 (0x0008) [0x0000000000000002] (CPF_Const)   
	class APlayerReplicationInfo*                      RealViewTarget;                                // 0x0380 (0x0008) [0x0000000000000000]               
	float                                              FOVAngle;                                      // 0x0388 (0x0004) [0x0000000000000000]               
	float                                              DesiredFOV;                                    // 0x038C (0x0004) [0x8000000000002000] (CPF_Transient)
	float                                              DesiredFOVBaseValue;                           // 0x0390 (0x0004) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            DesiredFOVModifierStack;                       // 0x0398 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              DefaultFOV;                                    // 0x03A8 (0x0004) [0x0000000000000000]               
	float                                              ForegroundFOVAngle;                            // 0x03AC (0x0004) [0x0000000000000000]               
	float                                              LODDistanceFactor;                             // 0x03B0 (0x0004) [0x0000000000000002] (CPF_Const)   
	struct FRotator                                    TargetViewRotation;                            // 0x03B4 (0x000C) [0x0000000000000020] (CPF_Net)     
	float                                              TargetEyeHeight;                               // 0x03C0 (0x0004) [0x0000000000000020] (CPF_Net)     
	struct FRotator                                    BlendedTargetViewRotation;                     // 0x03C4 (0x000C) [0x0000000000000000]               
	class AHUD*                                        myHUD;                                         // 0x03D0 (0x0008) [0x0000000000000000]               
	class UClass*                                      SavedMoveClass;                                // 0x03D8 (0x0008) [0x0000000000000000]               
	class USavedMove*                                  SavedMoves;                                    // 0x03E0 (0x0008) [0x0000000000000000]               
	class USavedMove*                                  FreeMoves;                                     // 0x03E8 (0x0008) [0x0000000000000000]               
	class USavedMove*                                  PendingMove;                                   // 0x03F0 (0x0008) [0x0000000000000000]               
	struct FVector                                     LastAckedAccel;                                // 0x03F8 (0x000C) [0x0000000000000000]               
	float                                              CurrentTimeStamp;                              // 0x0404 (0x0004) [0x0000000000000000]               
	float                                              LastUpdateTime;                                // 0x0408 (0x0004) [0x0000000000000000]               
	float                                              ServerTimeStamp;                               // 0x040C (0x0004) [0x0000000000000000]               
	float                                              ServerTimeStampLastServerMove;                 // 0x0410 (0x0004) [0x0000000000000000]               
	float                                              ClientUpdateTime;                              // 0x0414 (0x0004) [0x0000000000000000]               
	float                                              LastActiveTime;                                // 0x0418 (0x0004) [0x0000000000000000]               
	float                                              MovementLifetimeRawTimeDiscrepancy;            // 0x041C (0x0004) [0x0000000000000000]               
	float                                              MovementTimeDiscrepancy;                       // 0x0420 (0x0004) [0x0000000000000000]               
	float                                              MovementTimeDiscrepancyResolutionMoveDeltaOverride;// 0x0424 (0x0004) [0x0000000000000000]               
	float                                              MovementTimeDiscrepancyAccumulatedClientDeltasSinceLastServerTick;// 0x0428 (0x0004) [0x0000000000000000]               
	int32_t                                            ClientCap;                                     // 0x042C (0x0004) [0x0000000000000000]               
	float                                              DynamicPingThreshold;                          // 0x0430 (0x0004) [0x0000000020000000]  CPF_Deprecated)
	float                                              LastPingUpdate;                                // 0x0434 (0x0004) [0x0000000000000000]               
	struct FClientAdjustment                           PendingAdjustment;                             // 0x0438 (0x0038) [0x0000000000000000]               
	int32_t                                            GroundPitch;                                   // 0x0470 (0x0004) [0x0000000000000000]               
	class UObject*                                     CheatManagerObject;                            // 0x0478 (0x0008) [0x0000000000002000] (CPF_Transient)
	class FString                                      CheatClassName;                                // 0x0480 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class UPlayerInput*                                PlayerInput;                                   // 0x0490 (0x0008) [0x0000000004002001] (CPF_Edit | CPF_Transient | CPF_EditInline)
	class UClass*                                      InputClass;                                    // 0x0498 (0x0008) [0x0000000000000000]               
	struct FVector                                     FailedPathStart;                               // 0x04A0 (0x000C) [0x0000000000000002] (CPF_Const)   
	class UCylinderComponent*                          CylinderComponent;                             // 0x04B0 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	class FString                                      ForceFeedbackManagerClassName;                 // 0x04B8 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UForceFeedbackManager*                       ForceFeedbackManager;                          // 0x04C8 (0x0008) [0x0000000000002000] (CPF_Transient)
	class TArray<class UInteraction*>                  Interactions;                                  // 0x04D0 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class UOnlineSubsystem*                            OnlineSub;                                     // 0x04E0 (0x0008) [0x0000000000000000]               
	class UOnlineVoiceInterface*                       VoiceInterface_Object;                         // 0x04E8 (0x0008) [0x0000000000000000] 
	class UOnlineVoiceInterface*                       VoiceInterface_Interface;                      // 0x04F0 (0x0008) [0x0000000000000000]               
	float                                              InteractDistance;                              // 0x04F8 (0x0004) [0x0000000000004000] (CPF_Config)  
	class TArray<struct FCinematicModeOptions>         CinematicModeStack;                            // 0x0500 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FCinematicModeOptions                       AppliedCinematicModeOptions;                   // 0x0510 (0x0008) [0x0000000000000000]               
	struct FName                                       DelayedJoinSessionName;                        // 0x0518 (0x0008) [0x0000000000000000]               
	class FString                                      LastPresenceStatusUpdateString;                // 0x0520 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      LastLocationStatusUpdateString;                // 0x0530 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FInputMatchRequest>            InputRequests;                                 // 0x0540 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              LastBroadcastTime;                             // 0x0550 (0x0004) [0x0000000000000000]               
	class FString                                      LastBroadcastString[0x4];                      // 0x0558 (0x0040) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FName>                         PendingMapChangeLevelNames;                    // 0x0598 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FDebugTextInfo>                DebugTextList;                                 // 0x05A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              SpectatorCameraSpeed;                          // 0x05B8 (0x0004) [0x0000000000000000]               
	class UNetConnection*                              PendingSwapConnection;                         // 0x05C0 (0x0008) [0x0000000000200002] (CPF_Const)   
	float                                              MinRespawnDelay;                               // 0x05C8 (0x0004) [0x0000000000000000]               
	float                                              LastSpectatorStateSynchTime;                   // 0x05CC (0x0004) [0x0000000000000000]               
	struct FVector                                     HoldingDest;                                   // 0x05D0 (0x000C) [0x0000000000000000]               
	struct FRotator                                    HoldingRotation;                               // 0x05DC (0x000C) [0x0000000000000000]               
	class AActor*                                      HoldingDestActor;                              // 0x05E8 (0x0008) [0x0000000000000000]               
	class TArray<struct FName>                         LoadingMovieLoadedLevelNames;                  // 0x05F0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FAudioListener                              SecondaryAudioListener;                        // 0x0600 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FScriptDelegate                             __CanUnpause__Delegate;                        // 0x0608 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __InputMatchDelegate__Delegate;                // 0x0618 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PlayerController");
		}

		return uClassPointer;
	};

	void ClientSetSlomo(bool bSlomoEnable, bool bForce);
	void Walk();
	void Ghost();
	void RefreshAFKTime();
	static void KeepPlayingLoadingMovie();
	void eventWarmupPause(bool bDesiredPauseState);
	bool CanUnpauseWarmup();
	void eventNotifyUIRefresh();
	void eventPreTransitionCleanup();
	void ServerDestroy();
	bool CanDrop(class AWillowInventory* Inv);
	uint8_t GetDLCPackageMask();
	void PreOnGameInviteAccepted();
	bool AllDestinationLevelsAreVisible(const struct FVector& DestLoc);
	bool eventReleaseHolding();
	void SetGlobalVolumeMultiplier(float F);
	void NativeSetGlobalVolumeMultiplier(float F);
	bool eventNotifyDisconnect(const class FString& Command);
	void ReceivedGameClass(class UClass* GameClass);
	void LogOutBugItAIGoToLogFile(const class FString& InScreenShotDesc, const class FString& InGoString, const class FString& InLocString);
	void LogOutBugItGoToLogFile(const class FString& InScreenShotDesc, const class FString& InGoString, const class FString& InLocString);
	void DisableDebugAI();
	void ToggleAnimThreading();
	void DumpFriendsList();
	void DrawOnlineVoiceState();
	void DrawOnlineSessionState();
	void DumpVoiceRegistration();
	void DumpOnlineSessionState();
	void DebugLogPRIs();
	void eventOnEngineInitialTick();
	void BugItAI(const class FString& optionalScreenShotDescription);
	void LogLoc();
	void BugIt(const class FString& optionalScreenShotDescription);
	void BugItWorker(const struct FVector& TheLocation, const struct FRotator& TheRotation);
	void BugItGoString(const class FString& TheLocation, const class FString& TheRotation);
	void BugItGo(const class FString& LocationAndRotation);
	void eventClientSpawnCameraLensEffect(class UClass* LensEffectEmitterClass);
	void DebugCameraAnims();
	void eventClientStopCameraAnim(class UCameraAnim* AnimToStop, bool optionalBStopImmediately);
	void eventClientPlayCameraAnim(class UCameraAnim* AnimToPlay, float optionalScale, float optionalRate, float optionalBlendInTime, float optionalBlendOutTime, bool optionalBLoop, bool optionalBRandomStartTime, ECameraAnimPlaySpace optionalSpace, const struct FRotator& optionalCustomPlaySpace, uint8_t optionalMirrorAxes);
	void ClientStopCameraShake(class UCameraShake* Shake);
	void ClientPlayCameraShake(class UCameraShake* Shake, float optionalScale, bool optionalBTryForceFeedback, ECameraAnimPlaySpace optionalPlaySpace, const struct FRotator& optionalUserPlaySpaceRot);
	void DoForceFeedbackForScreenShake(class UCameraShake* ShakeData, float ShakeScale);
	void TestMovieStop();
	void TestMovie(const class FString& MovieName);
	void NativeTestMovieStop();
	void NativeTestMovie(const class FString& MovieName);
	void InputMatchDelegate();
	void Sentinel_PostAcquireTravelTheWorldPoints();
	void Sentinel_PreAcquireTravelTheWorldPoints();
	void Sentinel_SetupForGamebasedTravelTheWorld();
	void OnFlyThroughHasEnded(class USeqAct_FlyThroughHasEnded* inAction);
	bool eventGetAchievementProgression(int32_t AchievementId, float& CurrentValue, float& MaxValue);
	static class FString GetPartyGameTypeName();
	static class FString GetPartyMapName();
	bool IsPartyLeader();
	void eventClientAddTextureStreamingLoc(const struct FVector& InLoc, float Duration, bool bOverrideLocation);
	void eventClientPrestreamTextures(class AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, const struct FQWord& CinematicTextureGroups);
	void eventClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material, float ForceDuration, const struct FQWord& CinematicTextureGroups);
	void ClientControlMovieTexture(class UTextureMovie* MovieTexture, EMovieControlType Mode);
	int32_t GetSplitscreenPlayerCount();
	class APlayerReplicationInfo* GetSplitscreenPlayerByIndex(int32_t optionalPlayerIndex);
	bool IsSplitscreenPlayer(int32_t& out_SplitscreenPlayerIndex);
	bool IsPrimaryPlayer();
	void ServerNotifyPartyHostLeaving(const struct FUniqueNetId& PartyHostPlayerId);
	void ClientNotifyPartyHostLeaving(const struct FUniqueNetId& PartyHostPlayerId);
	void ClientReturnToParty(const struct FUniqueNetId& RequestingPlayerId);
	void OnJoinTravelToSessionComplete(const struct FName& SessionName, EOnlineSubsystemResult Result);
	void PreJoinUpdateGameSettings(const struct FName& SessionName, class UOnlineGameSettings* GameSettings);
	void ClientTravelToSession(const struct FName& SessionName, class UClass* SearchClass, const struct FPlatformSessionData& PlatformSpecificInfo);
	void PathClear();
	void PathChild(int32_t optionalCnt);
	void PathStep(int32_t optionalCnt);
	bool ShouldCheckRemoteControlCheckbox(uint8_t CheckBoxName, class AHUD* optionalHUD);
	void NotifyGameUnPaused();
	void NotifyGamePaused();
	void eventSoakPause(class APawn* P);
	void IncrementNumberOfMatchesPlayed();
	bool CanViewUserCreatedContent();
	void ClientEndOnlineGame();
	void ClientStartOnlineGame();
	void eventRemoveAllDebugStrings();
	void eventRemoveDebugText(class AActor* SrcActor);
	void eventAddDebugText(const class FString& DebugText, class AActor* optionalSrcActor, float optionalDuration, const struct FVector& optionalOffset, const struct FVector& optionalDesiredOffset, const struct FColor& optionalTextColor, bool optionalBSkipOverwriteCheck, bool optionalBAbsoluteLocation, bool optionalBKeepAttachedToActor, class UFont* optionalInFont);
	void eventDrawDebugTextList(class UCanvas* Canvas, float RenderDelta);
	void SendToConsole(const class FString& Command);
	void ConsoleKey(const struct FName& Key);
	void OnDestroy(class USeqAct_Destroy* Action);
	void ClientStartNetworkedVoice(bool bFromPushToTalk);
	void ClientStopNetworkedVoice();
	void ClientSetHostUniqueId(const struct FUniqueNetId& InHostId);
	void ClientWriteLeaderboardStats(class UClass* OnlineStatsWriteClass, bool optionalBIsIncomplete);
	void ClientWriteOnlinePlayerScores(int32_t LeaderboardId);
	class FString ModifyClientURL(const class FString& URL);
	void eventClientWasKicked();
	bool IsShowingSubtitles();
	void SetShowSubtitles(bool bValue);
	static class APlayerController* GetPlayerControllerFromNetId(const struct FUniqueNetId& PlayerNetId);
	void ClientSetOnlineStatus();
	void SeamlessTravelFrom(class APlayerController* OldPC);
	void SeamlessTravelTo(class APlayerController* NewPC);
	void eventGetSeamlessTravelActorList(bool bToEntry, class TArray<class AActor*>& ActorList);
	bool IsPlayerMuted(struct FUniqueNetId& Sender);
	class UUIInteraction* GetUIController();
	void SaveActorConfig(const struct FName& actorName);
	void SaveClassConfig(const class FString& ClassName);
	void ClientWaitForLevelsVisible(class USeqAct_WaitForLevelsVisible* inAction);
	void eventClientSetBlockOnAsyncLoading();
	void eventClientFlushLevelStreaming();
	void eventClientCancelPendingMapChange();
	void eventClientCommitMapChange();
	void DelayedPrepareMapChange();
	void eventClientPrepareMapChange(const struct FName& LevelName, bool bFirst, bool bLast);
	void eventClientFindPlayMovie(const struct FName& LevelName);
	void eventServerCheckForHoldingRelease(bool bTimerExpired);
	void eventServerUpdateLevelVisibility(const struct FName& PackageName, bool bIsVisible);
	void ClientUpdateLevelStreamingStatus(const struct FName& PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad);
	void eventLevelStreamingStatusChanged(class ULevelStreaming* LevelObject, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad);
	void eventClientForceGarbageCollection();
	void OnConsoleCommand(class USeqAct_ConsoleCommand* inAction);
	void ResetPlayerMovementInput();
	bool eventIsButtonInputIgnored();
	void IgnoreButtonInput(bool bNewButtonInput);
	bool IsLookInputIgnored();
	void IgnoreLookInput(bool bNewLookInput);
	bool IsMoveInputIgnored();
	void IgnoreMoveInput(bool bNewMoveInput);
	void ClientSetCinematicMode(const struct FCinematicModeOptions& Options);
	int32_t SetCinematicMode(const struct FCinematicModeOptions& Options, bool optionalBIsRestoringMode);
	void OnToggleCinematicMode(class USeqAct_ToggleCinematicMode* Action);
	bool IsForceFeedbackAllowed();
	void eventClientStopForceFeedbackWaveform(class UForceFeedbackWaveform* optionalFFWaveform);
	void ClientPlayForceFeedbackWaveform(class UForceFeedbackWaveform* FFWaveform, class AActor* optionalFFWaveformInstigator, float optionalScale, bool optionalForWeaponFiring);
	bool IsShotForceFeedbackAllowedByPlayerProfile();
	void eventPlayRumble(class UAnimNotify_Rumble* TheAnimNotify);
	void OnForceFeedback(class USeqAct_ForceFeedback* Action);
	void NotifyTakeHit(class AController* InstigatedBy, class APawn* HitPawn, const struct FVector& HitLocation, float Damage, class UClass* DamageType, const struct FVector& Momentum, class UDamagePipeline* optionalPipeline);
	void ShowGameState();
	void ShowPlayerState();
	void ServerRemoteEvent(const struct FName& EventName);
	void RE(const struct FName& optionalEventName);
	void RemoteEvent(const struct FName& optionalEventName);
	void ListCE();
	void ListConsoleEvents();
	void CE(const struct FName& optionalEventName);
	void CauseEvent(const struct FName& optionalEventName);
	void ServerCauseEvent(const struct FName& EventName);
	void OnToggleHUD(class USeqAct_ToggleHUD* inAction);
	void OnSetCameraTarget(class USeqAct_SetCameraTarget* inAction);
	void ClientClearKismetText(const struct FVector2D& MessageOffset);
	void ClientDrawKismetText(const struct FKismetDrawTextInfo& DrawTextInfo, float DisplayTime);
	void OnDrawTextW(class USeqAct_DrawText* inAction);
	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	void ClientIgnoreLookInput(bool bIgnore);
	void ClientIgnoreMoveInput(bool bIgnore);
	void OnToggleInput(class USeqAct_ToggleInput* inAction);
	void DrawHUD(class AHUD* H);
	bool CanRestartPlayer();
	void ServerViewSelf(const struct FViewTargetTransitionParams& optionalTransitionParams);
	void ViewAPlayer(int32_t Dir);
	class APlayerReplicationInfo* GetNextViewablePlayer(int32_t Dir);
	void ServerViewPrevPlayer();
	void ServerViewNextPlayer();
	void ServerSetSpectatorLocation(const struct FVector& NewLoc);
	bool IsSpectating();
	void AdjustPlayerWalkingMoveAccel(struct FVector& newAccel);
	void CheckJumpOrDuck();
	struct FRotator eventLimitViewRotation(const struct FRotator& ViewRotation, float ViewPitchMin, float ViewPitchMax);
	void ProcessViewRotation(float DeltaTime, const struct FRotator& DeltaRot, struct FRotator& out_ViewRotation);
	void UpdateRotation(float DeltaTime);
	void ViewShake(float DeltaTime);
	void eventSpawnPlayerCamera();
	bool IsLocalController();
	bool IsLocalPlayerController();
	float eventGetFOVAngle();
	void AdjustFOV(float DeltaTime);
	bool eventNotifyLanded(const struct FVector& HitNormal, class AActor* FloorActor);
	float AimHelpDot(bool bInstantHit);
	struct FRotator GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc);
	void eventCameraLookAtFinished(class USeqAct_CameraLookAt* Action);
	bool AimingHelp(bool bInstantHit);
	void PlayerMove(float DeltaTime);
	void eventPlayerTick(float DeltaTime);
	void ClientRestart(class APawn* NewPawn);
	void EnterStartState();
	void ForceSingleNetUpdateFor(class AActor* Target);
	bool HasClientLoadedCurrentWorld();
	void eventNotifyLoadedWorld(const struct FName& WorldPackageName, bool bFinalDest);
	void eventServerNotifyLoadedWorld(const struct FName& WorldPackageName);
	void Restart(bool bVehicleTransition);
	void eventClientSetProgressMessage(EProgressMessageType MessageType, const class FString& Message, const class FString& optionalTitle, bool optionalBIgnoreFutureNetworkMessages);
	void SwitchLevel(const class FString& URL);
	void ServerChangeTeam(int32_t N);
	void SwitchTeam();
	void ServerChangeName(const class FString& S);
	void SetName(const class FString& S);
	void ServerSuicide();
	void Suicide();
	bool TriggerCanceled();
	bool TriggerInteracted();
	bool FindVehicleToDrive();
	bool PerformedCancelUseAction();
	bool PerformedUseAction();
	void ServerCancelUse();
	void CancelUse();
	void ServerUse();
	void Use();
	void GetTriggerUseList(float interactDistanceToCheck, float crosshairDist, float minDot, bool bUsuableOnly, class TArray<class ATrigger*>& out_useList);
	void StopAltFire(uint8_t optionalFireModeNum);
	void StartAltFire(uint8_t optionalFireModeNum);
	void StopFire(uint8_t optionalFireModeNum);
	void StartFire(uint8_t optionalFireModeNum);
	void NextWeapon();
	void PrevWeapon();
	void ServerThrowWeapon();
	void ThrowWeapon();
	void UTrace();
	void ServerUTrace();
	void eventConditionalPause(bool bDesiredPauseState);
	void ServerPause();
	void Pause();
	bool IsPaused();
	bool SetPause(bool bPause, const struct FScriptDelegate& optionalCanUnpauseDelegate);
	bool CanUnpauseDefault();
	bool CanUnpause();
	void ClientPauseRumble(bool bShouldPauseRumble);
	void PauseRumbleForAllPlayers(bool optionalBShouldPauseRumble);
	void LocalTravel(const class FString& URL);
	void RestartLevel();
	void ServerSpeech(const struct FName& Type, int32_t Index, const class FString& Callsign);
	void Speech(const struct FName& Type, int32_t Index, const class FString& Callsign);
	void ServerRestartGame();
	void HandleWalking();
	void CallServerMove(class USavedMove* NewMove, const struct FVector& ClientLoc, uint8_t ClientRoll, int32_t View, class USavedMove* OldMove);
	void ReplicateMove(float DeltaTime, const struct FVector& newAccel, EDoubleClickDir DoubleClickMove, const struct FRotator& DeltaRot, uint8_t AnalogPct);
	int32_t CompressAccel(int32_t C);
	class USavedMove* GetFreeMove();
	void ClientUpdatePosition();
	void ClearAckedMoves();
	void ServerUpdatePing(int32_t NewPing);
	void UpdateStateFromAdjustment(const struct FName& NewState);
	void LongClientAdjustPosition(float TimeStamp, const struct FName& NewState, EPhysics newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase, float NewFloorX, float NewFloorY, float NewFloorZ);
	bool SkipPositionUpdateForRM();
	void UpdatePing(float TimeStamp);
	void ClientAdjustPosition(float TimeStamp, const struct FName& NewState, EPhysics newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase);
	void ClientAckGoodMove(float TimeStamp);
	void ClientCapBandwidth(int32_t Cap);
	void ShortClientAdjustPosition(float TimeStamp, const struct FName& NewState, EPhysics newPhysics, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase);
	void VeryShortClientAdjustPosition(float TimeStamp, float NewLocX, float NewLocY, float NewLocZ, class AActor* NewBase);
	void eventMoveAutonomous(float DeltaTime, uint8_t CompressedFlags, const struct FVector& newAccel, const struct FRotator& DeltaRot, uint8_t AnalogPct);
	void ProcessMove(float DeltaTime, const struct FVector& newAccel, EDoubleClickDir DoubleClickMove, const struct FRotator& DeltaRot, uint8_t AnalogPct);
	float UncompressAnalogMovePct(uint8_t InAnalogPct);
	uint8_t CompressAnalogMovePct(float InAnalogPct);
	void ProcessDrive(float InForward, float InStrafe, float InUp, bool InJump);
	void ServerDrive(float InForward, float InStrafe, float aUp, bool InJump, int32_t View);
	void eventSendClientAdjustment();
	void ServerMove(float TimeStamp, const struct FVector& InAccel, const struct FVector& ClientLoc, uint8_t MoveFlags, uint8_t ClientRoll, int32_t View, uint8_t AnalogPct);
	void PCServerMoveInner(float TimeStamp, const struct FVector& InAccel, const struct FVector& ClientLoc, uint8_t MoveFlags, uint8_t ClientRoll, int32_t View, uint8_t AnalogPct);
	void OldServerMove(float OldTimeStamp, uint8_t OldAccelX, uint8_t OldAccelY, uint8_t OldAccelZ, uint8_t OldMoveFlags, uint8_t OldAnalogPct);
	void DualServerMove(float TimeStamp0, const struct FVector& InAccel0, uint8_t PendingFlags, int32_t view0, uint8_t AnalogPct0, float TimeStamp, const struct FVector& InAccel, const struct FVector& ClientLoc, uint8_t NewFlags, uint8_t ClientRoll, int32_t View, uint8_t AnalogPct);
	void ForceDeathUpdate();
	bool UsingFirstPersonCamera();
	void eventClientSetCameraFade(bool bEnableFading, const struct FColor& optionalFadeColor, float optionalFadeOpacity, float optionalFadeTime);
	void ResetCameraMode(bool optionalBCutToDefaultMode);
	void SetCameraMode(const struct FName& ModeName, float optionalBlendTimeOverride, bool optionalBTeleport, bool optionalBForceResetMode);
	void Camera(const struct FName& NewMode);
	void eventPreClientTravel(const class FString& PendingURL, ETravelType TravelType, bool bIsSeamlessTravel);
	void TeamSay(const class FString& msg);
	void ClientAdminMessage(const class FString& msg);
	void Say(const class FString& msg);
	bool AllowTextMessage(const class FString& msg);
	void FOV(float F);
	void ResetFOV();
	void SetFOV(float NewFOV);
	void FixFOV();
	void eventDestroyed();
	void CleanupPawn();
	void PlayBeepSound();
	void eventTeamMessage(class APlayerReplicationInfo* PRI, const class FString& S, const struct FName& Type, float optionalMsgLifeTime);
	void TeamTalk();
	void Talk();
	bool CanCommunicate();
	void eventClientMessage(const class FString& S, const struct FName& optionalType, float optionalMsgLifeTime);
	void ClientPlayActorFaceFXAnim(class AActor* SourceActor, class UFaceFXAnimSet* AnimSet, const class FString& GroupName, const class FString& SeqName, class UAkEvent* AkEventToPlay);
	bool IsClosestLocalPlayerToActor(class AActor* TheActor);
	void ClientStopSound(class UAkEvent* InAkEvent, class AActor* SourceActor, float optionalFadeDuration);
	struct FAkPlayingInfo eventWwiseClientHearSoundReliable(class UAkEvent* ASound, class AActor* SourceActor, const struct FVector& SourceLocation, bool bStopWhenOwnerDestroyed, bool optionalBIsOccluded, class UAkSwitch* optionalInSwitch);
	struct FAkPlayingInfo eventWwiseClientHearSound(class UAkEvent* ASound, class AActor* SourceActor, const struct FVector& SourceLocation, bool bStopWhenOwnerDestroyed, bool optionalBIsOccluded, class UAkSwitch* optionalInSwitch);
	struct FAkPlayingInfo eventClientPlayAkEvent(class UAkEvent* Event, class UAkSwitch* optionalInSwitch);
	void eventClearHUDMessage(ELocalMessageType MsgType);
	void eventDisplayHUDMessage(ELocalMessageType MsgType, const class FString& MessageString, float Duration, const struct FColor& DrawColor, class UClass* optionalInMessageClass, int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class UObject* optionalOptionalObject);
	void eventReceiveLocalizedMessage(class UClass* Message, int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	void CleanupPRI();
	void HandlePickup(class AInventory* Inv);
	void ClientNotifyPostInitialize();
	void ClientSetHUD(class UClass* newHUDType);
	void PawnDied(class APawn* P);
	void eventUnPossess();
	void ServerAcknowledgePossession(class APawn* P);
	void AcknowledgePossession(class APawn* P);
	void eventPossess(class APawn* aPawn, bool bVehicleTransition);
	void GivePawn(class APawn* NewPawn);
	void AskForPawn();
	void ClientGotoState(const struct FName& NewState, const struct FName& optionalNewLabel);
	bool IsMouseAvailable();
	bool IsKeyboardAvailable();
	void SetRumbleScale(float ScaleBy);
	void UnregisterStandardPlayerDataStores();
	void UnregisterPlayerDataStores();
	void RegisterStandardPlayerDataStores();
	void RegisterCustomPlayerDataStores();
	void RegisterPlayerDataStores();
	void ClientInitializeDataStores();
	void eventInitInputSystem();
	class UOnlineSubsystem* GetOnlineSubsystem();
	void PostUserIdChange();
	void PreUserIdChange();
	void CleanOutSavedMoves();
	void ClientReset();
	void Reset();
	void SpawnDefaultHUD();
	void EnableCheats();
	void eventNotifyIdle();
	void eventKickWarning();
	void ServerGivePawn();
	void ServerShortTimeout();
	class UClass* GetCurrentSearchClass();
	void GetRegisteredPlayersInSession(const struct FName& SessionName, class TArray<struct FUniqueNetId>& OutRegisteredPlayers);
	void eventReceivedPlayer();
	void eventPostBeginPlay();
	bool CanUnpauseControllerConnected();
	void OnControllerChanged(const struct FPlatformUserId& UserId, bool bIsConnected);
	bool CanUnpauseExternalUI();
	void OnExternalUIChanged(bool bIsOpening);
	void ForceClearUnpauseDelegates();
	struct FLinearColor GetTeamColorNeutral(ETeamRelativeColorCategory Category);
	struct FLinearColor GetTeamColorEnemy(ETeamRelativeColorCategory Category);
	struct FLinearColor GetTeamColorAllied(ETeamRelativeColorCategory Category);
	void DisableActorHeadTracking(class AActor* TargetActor);
	void EnableActorHeadTracking(class AActor* TargetActor, const struct FName& TrackControllerName, class UClass* ActorClassesToLookAt, bool bLookAtPawns, float MinLookAtTime, float MaxLookAtTime, float MaxInterestTime, float LookAtActorRadius, const struct FName& TargetBoneNames);
	void eventFellOutOfWorld(class UClass* dmgType);
	void eventServerProcessConvolve(const class FString& C, int32_t H);
	void eventClientConvolve(const class FString& C, int32_t H);
	void OnUsingGamepadChanged(class UPlayerInput* InPlayerInput);
	void SetAllowMatureLanguage(bool bAllowMatureLanguge);
	class FString PasteFromClipboard();
	void CopyToClipboard(const class FString& Text);
	class FString GetDefaultURL(const class FString& Option);
	void UpdateURL(const class FString& NewOption, const class FString& NewValue, bool bSave1Default);
	void eventClientTravel(const class FString& URL, ETravelType TravelType, bool optionalBSeamless, const struct FGuid& optionalMapPackageGuid);
	class FString ConsoleCommand(const class FString& Command, bool optionalBWriteToLog);
	class FString GetServerNetworkAddress();
	class FString GetPlayerNetworkAddress();
	void SetNetSpeed(int32_t NewSpeed);
};

// Class Engine.Admin
// 0x0000 (0x0628 - 0x0628)
class AAdmin : public APlayerController
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Admin");
		}

		return uClassPointer;
	};

	void ServerSwitch(const class FString& URL);
	void Switch(const class FString& URL);
	void ServerRestartMap();
	void RestartMap();
	void PlayerList();
	void ServerKick(const class FString& S);
	void Kick(const class FString& S);
	void ServerKickBan(const class FString& S);
	void KickBan(const class FString& S);
	void ServerAdmin(const class FString& CommandLine);
	void Admin(const class FString& CommandLine);
	void eventPostBeginPlay();
};

// Class Engine.DebugCameraController
// 0x0048 (0x0628 - 0x0670)
class ADebugCameraController : public APlayerController
{
public:
	struct FName                                       PrimaryKey;                                    // 0x0628 (0x0008) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FName                                       SecondaryKey;                                  // 0x0630 (0x0008) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FName                                       UnselectKey;                                   // 0x0638 (0x0008) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bShowSelectedInfo : 1;                         // 0x0640 (0x0004) [0x0000000000044000] [0x00000001] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bIsFrozenRendering : 1;                        // 0x0640 (0x0004) [0x0000000000000000] [0x00000002] 
	class APlayerController*                           OryginalControllerRef;                         // 0x0648 (0x0008) [0x0000000000000000]               
	class UPlayer*                                     OryginalPlayer;                                // 0x0650 (0x0008) [0x0000000000000000]               
	class UDrawFrustumComponent*                       DrawFrustum;                                   // 0x0658 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	class AActor*                                      SelectedActor;                                 // 0x0660 (0x0008) [0x0000000000000000]               
	class UPrimitiveComponent*                         SelectedComponent;                             // 0x0668 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DebugCameraController");
		}

		return uClassPointer;
	};

	class FString ConsoleCommand(const class FString& Command, bool optionalBWriteToLog);
	void ShowDebugSelectedInfo();
	bool NativeInputKey(const struct FPlatformUserId& UserId, const struct FName& Key, EInputEvent Event, float optionalAmountDepressed, bool optionalBGamepad);
	void DisableDebugCamera();
	void NormalSpeed();
	void MoreSpeed();
	void SetFreezeRendering();
	void OnDeactivate(class APlayerController* PC);
	void OnActivate(class APlayerController* PC);
	void eventPostBeginPlay();
	void Unselect();
	void SecondarySelect(const struct FVector& HitLoc, const struct FVector& HitNormal, const struct FTraceHitInfo& HitInfo);
	void PrimarySelect(const struct FVector& HitLoc, const struct FVector& HitNormal, const struct FTraceHitInfo& HitInfo);
};

// Class Engine.DecalActorBase
// 0x0008 (0x0240 - 0x0248)
class ADecalActorBase : public AActor
{
public:
	class UDecalComponent*                             Decal;                                         // 0x0240 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DecalActorBase");
		}

		return uClassPointer;
	};

};

// Class Engine.DecalActor
// 0x0000 (0x0248 - 0x0248)
class ADecalActor : public ADecalActorBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DecalActor");
		}

		return uClassPointer;
	};

};

// Class Engine.DecalActorMovable
// 0x0000 (0x0248 - 0x0248)
class ADecalActorMovable : public ADecalActorBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DecalActorMovable");
		}

		return uClassPointer;
	};

};

// Class Engine.DecalManager
// 0x0068 (0x0240 - 0x02A8)
class ADecalManager : public AActor
{
public:
	class UDecalComponent*                             DecalTemplate;                                 // 0x0240 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	class TArray<class UDecalComponent*>               PoolDecals;                                    // 0x0248 (0x0010) [0x0000000004480008] (CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	int32_t                                            MaxActiveDecals;                               // 0x0258 (0x0004) [0x0000000000000000]               
	int32_t                                            MaxActiveDecalsLow;                            // 0x025C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            MaxActiveDecalsHigh;                           // 0x0260 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            MaxActiveDecalsSplitScreen;                    // 0x0264 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              DecalLifeSpan;                                 // 0x0268 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FVector2D                                   DecalBlendRange;                               // 0x026C (0x0008) [0x0000000000000000]               
	int32_t                                            MaxFadingDecals;                               // 0x0274 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              FadingLifeSpan;                                // 0x0278 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FName                                       FadeParameterName;                             // 0x027C (0x0008) [0x0000000000000000]               
	class TArray<struct FActiveDecalInfo>              ActiveDecals;                                  // 0x0288 (0x0010) [0x0000000000480000] (CPF_Component | CPF_NeedCtorLink)
	class TArray<struct FActiveDecalInfo>              FadingDecals;                                  // 0x0298 (0x0010) [0x0000000000480000] (CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DecalManager");
		}

		return uClassPointer;
	};

	void ClearAllPoolComponents();
	void ClearDecals();
	class UDecalComponent* eventSpawnDecal(class UMaterialInterface* DecalMaterial, const struct FVector& DecalLocation, const struct FRotator& DecalOrientation, float Width, float Height, float Thickness, bool bNoClip, float optionalDecalRotation, class UPrimitiveComponent* optionalHitComponent, bool optionalBProjectOnTerrain, bool optionalBProjectOnSkeletalMeshes, const struct FName& optionalHitBone, int32_t optionalHitNodeIndex, int32_t optionalHitLevelIndex, float optionalInDecalLifeSpan, const struct FVector2D& optionalInBlendRange, bool optionalBDontAttach);
	class UDecalComponent* GetPooledComponent();
	static void SetDecalParameters(class UDecalComponent* TheDecal, class UMaterialInterface* DecalMaterial, const struct FVector& DecalLocation, const struct FRotator& DecalOrientation, float Width, float Height, float Thickness, bool bNoClip, float DecalRotation, class UPrimitiveComponent* HitComponent, bool bProjectOnTerrain, bool bProjectOnSkeletalMeshes, const struct FName& HitBone, int32_t HitNodeIndex, int32_t HitLevelIndex, const struct FVector2D& BlendRange);
	bool CanSpawnDecals();
	void eventDecalFinished(class UDecalComponent* Decal);
	static bool AreDynamicDecalsEnabled();
	void PostBeginPlay();
	void SetNumberOfDecals();
};

// Class Engine.DirectionalLightShaftHelper
// 0x0008 (0x0240 - 0x0248)
class ADirectionalLightShaftHelper : public AActor
{
public:
	class ADirectionalLight*                           Light;                                         // 0x0240 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DirectionalLightShaftHelper");
		}

		return uClassPointer;
	};

};

// Class Engine.DynamicSMActor
// 0x0050 (0x0240 - 0x0290)
class ADynamicSMActor : public AActor
{
public:
	class UStaticMeshComponent*                        StaticMeshComponent;                           // 0x0240 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                              // 0x0248 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	class UStaticMesh*                                 ReplicatedMesh;                                // 0x0250 (0x0008) [0x0000000100002020] (CPF_Net | CPF_Transient)
	class UMaterialInterface*                          ReplicatedMaterial0;                           // 0x0258 (0x0008) [0x0000000100000020] (CPF_Net)     
	class UMaterialInterface*                          ReplicatedMaterial1;                           // 0x0260 (0x0008) [0x0000000100000020] (CPF_Net)     
	uint32_t                                           bForceStaticDecals : 1;                        // 0x0268 (0x0004) [0x0000000100000020] [0x00000001] (CPF_Net)
	uint32_t                                           bPawnCanBaseOn : 1;                            // 0x0268 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bSafeBaseIfAsleep : 1;                         // 0x0268 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	struct FVector                                     ReplicatedMeshTranslation;                     // 0x026C (0x000C) [0x0000000100000020] (CPF_Net)     
	struct FRotator                                    ReplicatedMeshRotation;                        // 0x0278 (0x000C) [0x0000000100000020] (CPF_Net)     
	struct FVector                                     ReplicatedMeshScale3D;                         // 0x0284 (0x000C) [0x0000000100000020] (CPF_Net)     

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DynamicSMActor");
		}

		return uClassPointer;
	};

	void SetLightEnvironmentToNotBeDynamic();
	void eventDetach(class AActor* Other);
	void eventAttach(class AActor* Other);
	bool CanBasePawn(class APawn* P);
	void SetStaticMesh(class UStaticMesh* NewMesh, const struct FVector& optionalNewTranslation, const struct FRotator& optionalNewRotation, const struct FVector& optionalNewScale3D);
	void OnSetMaterial(class USeqAct_SetMaterial* Action);
	void OnSetMesh(class USeqAct_SetMesh* Action);
	void eventReplicatedEvent(const struct FName& VarName);
	void eventPostBeginPlay();
};

// Class Engine.DynamicSMActor_Spawnable
// 0x0000 (0x0290 - 0x0290)
class ADynamicSMActor_Spawnable : public ADynamicSMActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DynamicSMActor_Spawnable");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpActor
// 0x0020 (0x0290 - 0x02B0)
class AInterpActor : public ADynamicSMActor
{
public:
	uint32_t                                           bShouldSaveForCheckpoint : 1;                  // 0x0290 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bMonitorMover : 1;                             // 0x0290 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bMonitorZVelocity : 1;                         // 0x0290 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bDestroyProjectilesOnEncroach : 1;             // 0x0290 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bContinueOnEncroachPhysicsObject : 1;          // 0x0290 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bStopOnEncroach : 1;                           // 0x0290 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bCrushPawnsWhenEncroaching : 1;                // 0x0290 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bCrushPawnsWhenGoingDown : 1;                  // 0x0290 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bCrushPawnsWhenGoingUp : 1;                    // 0x0290 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bCrushVehiclesWhenGoingDown : 1;               // 0x0290 (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bCrushVehiclesWhenGoingUp : 1;                 // 0x0290 (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	uint32_t                                           bTreatAsStaticForGBXNavMeshBuilding : 1;       // 0x0290 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bIsLift : 1;                                   // 0x0290 (0x0004) [0x0000000000000000] [0x00001000] 
	class ANavigationPoint*                            MyMarker;                                      // 0x0298 (0x0008) [0x0000000000000000]               
	float                                              MaxZVelocity;                                  // 0x02A0 (0x0004) [0x0000000000000000]               
	float                                              StayOpenTime;                                  // 0x02A4 (0x0004) [0x0000000000000000]               
	float                                              BeforeStoppingVelocityZ;                       // 0x02A8 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpActor");
		}

		return uClassPointer;
	};

	void ApplyCheckpointRecord(struct FInterpActorCheckpointRecord& Record);
	void CreateCheckpointRecord(struct FInterpActorCheckpointRecord& Record);
	bool ShouldSaveForCheckpoint();
	void ShutDown();
	void eventInterpolationChanged(class USeqAct_Interp* InterpAction);
	void eventInterpolationFinished(class USeqAct_Interp* InterpAction);
	void eventInterpolationStarted(class USeqAct_Interp* InterpAction, class UInterpGroupInst* GroupInst);
	void PlayMovingSound(bool bClosing);
	void FinishedOpen();
	void Restart();
	void eventDetach(class AActor* Other);
	void eventAttach(class AActor* Other);
	void eventRigidBodyCollision(class UPrimitiveComponent* HitComponent, class UPrimitiveComponent* OtherComponent, int32_t ContactIndex, struct FCollisionImpactData& RigidCollisionData);
	void eventRanInto(class AActor* Other);
	bool eventEncroachingOn(class AActor* Other);
	bool ChildEncroachingOn(class AInterpActor* Child, class AActor* Other);
	bool StopOnEncroach();
	void eventPostBeginPlay();
};

// Class Engine.InterpActor_ForCinematic
// 0x0000 (0x02B0 - 0x02B0)
class AInterpActor_ForCinematic : public AInterpActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpActor_ForCinematic");
		}

		return uClassPointer;
	};

};

// Class Engine.KActor
// 0x00E0 (0x0290 - 0x0370)
class AKActor : public ADynamicSMActor
{
public:
	uint32_t                                           bDamageAppliesImpulse : 1;                     // 0x0290 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bWakeOnLevelStart : 1;                         // 0x0290 (0x0004) [0x0000000100000021] [0x00000002] (CPF_Edit | CPF_Net)
	uint32_t                                           bCurrentSlide : 1;                             // 0x0290 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bSlideActive : 1;                              // 0x0290 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bEnableStayUprightSpring : 1;                  // 0x0290 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bLimitMaxPhysicsVelocity : 1;                  // 0x0290 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bNeedsRBStateReplication : 1;                  // 0x0290 (0x0004) [0x0000000000002000] [0x00000040] (CPF_Transient)
	uint32_t                                           bDisableClientSidePawnInteractions : 1;        // 0x0290 (0x0004) [0x0000000000000000] [0x00000080] 
	class UParticleSystemComponent*                    ImpactEffectComponent;                         // 0x0298 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              LastImpactTime;                                // 0x02A0 (0x0004) [0x0000000000000000]               
	struct FPhysEffectInfo                             ImpactEffectInfo;                              // 0x02A8 (0x0018) [0x0000000000000000]               
	class UParticleSystemComponent*                    SlideEffectComponent;                          // 0x02C0 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              LastSlideTime;                                 // 0x02C8 (0x0004) [0x0000000000000000]               
	struct FPhysEffectInfo                             SlideEffectInfo;                               // 0x02D0 (0x0018) [0x0000000000000000]               
	float                                              StayUprightTorqueFactor;                       // 0x02E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StayUprightMaxTorque;                          // 0x02EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxPhysicsVelocity;                            // 0x02F0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              NetRelevantDistanceSquared;                    // 0x02F4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData00[0x8];                            // 0x02F8 (0x0008) MISSED OFFSET
	struct FRigidBodyState                             RBState;                                       // 0x0300 (0x0040) [0x0000000000001022] (CPF_Const | CPF_Net | CPF_Native)
	float                                              AngErrorAccumulator;                           // 0x0340 (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FVector                                     ReplicatedDrawScale3D;                         // 0x0344 (0x000C) [0x0000000100000020] (CPF_Net)     
	struct FVector                                     InitialLocation;                               // 0x0350 (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FRotator                                    InitialRotation;                               // 0x035C (0x000C) [0x0000000000002000] (CPF_Transient)
	uint8_t                                           UnknownData01[0x8];                            // 0x0368 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.KActor");
		}

		return uClassPointer;
	};

	void Reset();
	void OnTeleport(class USeqAct_Teleport* inAction);
	void OnToggle(class USeqAct_Toggle* Action);
	void TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class UIDamageCauser* DamageCauser, float optionalDamageFalloffExponent, class UDamagePipeline* optionalPipeline);
	void eventTakeDamage(float Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& HitDirection, class UClass* DamageType, const struct FTraceHitInfo& optionalHitInfo, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline);
	void eventApplyImpulse(const struct FVector& ImpulseDir, float ImpulseMag, const struct FVector& HitLocation, const struct FTraceHitInfo& optionalHitInfo, class UClass* optionalDamageType);
	void eventReplicatedEvent(const struct FName& VarName);
	void eventSpawnedByKismet();
	void SetPhysicalCollisionProperties();
	void eventFellOutOfWorld(class UClass* dmgType);
	void eventPostBeginPlay();
	void ResolveRBState();
	class UPhysicalMaterial* GetKActorPhysMaterial();
};

// Class Engine.KActorFromStatic
// 0x0010 (0x0370 - 0x0380)
class AKActorFromStatic : public AKActor
{
public:
	class AActor*                                      MyStaticMeshActor;                             // 0x0370 (0x0008) [0x0000000000000000]               
	float                                              MaxImpulseSpeed;                               // 0x0378 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.KActorFromStatic");
		}

		return uClassPointer;
	};

	void TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class UIDamageCauser* DamageCauser, float optionalDamageFalloffExponent, class UDamagePipeline* optionalPipeline);
	void eventTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void eventBump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal);
	void ReceiveImpulse(class APawn* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void eventApplyImpulse(const struct FVector& ImpulseDir, float ImpulseMag, const struct FVector& HitLocation, const struct FTraceHitInfo& optionalHitInfo, class UClass* optionalDamageType);
	static class AKActorFromStatic* MakeDynamic(class UStaticMeshComponent* MovableMesh);
	static void MakeStatic();
	void BecomeStatic();
	void eventOnWakeRBPhysics();
	void eventOnSleepRBPhysics();
	void DisablePrecomputedLighting();
};

// Class Engine.KActorSpawnable
// 0x0010 (0x0370 - 0x0380)
class AKActorSpawnable : public AKActor
{
public:
	struct FPointer                                    VfTable_IITeamAffiliated;                      // 0x0370 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	uint32_t                                           bRecycleScaleToZero : 1;                       // 0x0378 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bScalingToZero : 1;                            // 0x0378 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bNotifyRigidBodyCollision : 1;                 // 0x0378 (0x0004) [0x0000000100002020] [0x00000004] (CPF_Net | CPF_Transient)
	int32_t                                            TeamIndex;                                     // 0x037C (0x0004) [0x0000000000000020] (CPF_Net)     

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.KActorSpawnable");
		}

		return uClassPointer;
	};

	void ResetComponents();
	void eventRecycleInternal();
	void Recycle();
	void Initialize();
	void eventReplicatedEvent(const struct FName& VarName);
	void ForceColorRefresh();
	class UGBXDefinition* GetTeamDefinition();
	void SetTeamInfo(class ATeamInfo* InTeamInfo);
	class ATeamInfo* GetTeamInfo();
};

// Class Engine.KActorPizazz
// 0x0000 (0x0380 - 0x0380)
class AKActorPizazz : public AKActorSpawnable
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.KActorPizazz");
		}

		return uClassPointer;
	};

};

// Class Engine.EffectNetworkManager
// 0x0000 (0x0240 - 0x0240)
class AEffectNetworkManager : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EffectNetworkManager");
		}

		return uClassPointer;
	};

};

// Class Engine.Emitter
// 0x0018 (0x0240 - 0x0258)
class AEmitter : public AActor
{
public:
	class UParticleSystemComponent*                    ParticleSystemComponent;                       // 0x0240 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                              // 0x0248 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	uint32_t                                           bDestroyOnSystemFinish : 1;                    // 0x0250 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bPostUpdateTickGroup : 1;                      // 0x0250 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bAudioEnabled : 1;                             // 0x0250 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bCurrentlyActive : 1;                          // 0x0250 (0x0004) [0x0000000100000020] [0x00000008] (CPF_Net)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Emitter");
		}

		return uClassPointer;
	};

	void Behavior_Destroy();
	void HideSelf();
	void ApplyCheckpointRecord(struct FEmitterCheckpointRecord& Record);
	void CreateCheckpointRecord(struct FEmitterCheckpointRecord& Record);
	bool ShouldSaveForCheckpoint();
	void OnSetParticleSysParam(class USeqAct_SetParticleSysParam* Action);
	void SetActorParameter(const struct FName& ParameterName, class AActor* Param);
	void SetColorParameter(const struct FName& ParameterName, const struct FColor& Param);
	void SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param);
	void SetFloatParameter(const struct FName& ParameterName, float Param);
	void ShutDown();
	void OnParticleEventGenerator(class USeqAct_ParticleEventGenerator* Action);
	void OnToggle(class USeqAct_Toggle* Action);
	void OnSimulatedSystemFinished();
	void OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent);
	void OnRep_bCurrentlyActive(bool bPreviouslyActive);
	void eventPostBeginPlay();
	void eventSetTemplate(class UParticleSystem* NewTemplate, bool optionalBDestroyOnFinish);
};

// Class Engine.EmitterCameraLensEffectBase
// 0x0038 (0x0258 - 0x0290)
class AEmitterCameraLensEffectBase : public AEmitter
{
public:
	class UParticleSystem*                             PS_CameraEffect;                               // 0x0258 (0x0008) [0x0000000000000000]               
	class UParticleSystem*                             PS_CameraEffectNonExtremeContent;              // 0x0260 (0x0008) [0x0000000000000000]               
	float                                              BaseFOV;                                       // 0x0268 (0x0004) [0x0000000000000000]               
	float                                              DistFromCamera;                                // 0x026C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bAllowMultipleInstances : 1;                   // 0x0270 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	class TArray<class UClass*>                        EmittersToTreatAsSame;                         // 0x0278 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class ACamera*                                     BaseCamera;                                    // 0x0288 (0x0008) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EmitterCameraLensEffectBase");
		}

		return uClassPointer;
	};

	void UpdateLocation(float CamFOVDeg, struct FVector& CamLoc, struct FRotator& CamRot);
	void ActivateLensEffect();
	void PostBeginPlay();
	void NotifyRetriggered();
	void RegisterCamera(class ACamera* C);
	void Destroyed();
};

// Class Engine.EmitterSpawnable
// 0x0008 (0x0258 - 0x0260)
class AEmitterSpawnable : public AEmitter
{
public:
	class UParticleSystem*                             ParticleTemplate;                              // 0x0258 (0x0008) [0x0000000100000020] (CPF_Net)     

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EmitterSpawnable");
		}

		return uClassPointer;
	};

	void eventReplicatedEvent(const struct FName& VarName);
	void eventSetTemplate(class UParticleSystem* NewTemplate, bool optionalBDestroyOnFinish);
};

// Class Engine.EmitterPool
// 0x0060 (0x0240 - 0x02A0)
class AEmitterPool : public AActor
{
public:
	class UParticleSystemComponent*                    PSCTemplate;                                   // 0x0240 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	class TArray<class UParticleSystemComponent*>      PoolComponents;                                // 0x0248 (0x0010) [0x000000000448200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UParticleSystemComponent*>      ActiveComponents;                              // 0x0258 (0x0010) [0x0000000004482008] (CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	int32_t                                            MaxActiveEffects;                              // 0x0268 (0x0004) [0x0000000000000000]               
	uint32_t                                           bLogPoolOverflow : 1;                          // 0x026C (0x0004) [0x0000000000044000] [0x00000001] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bLogPoolOverflowList : 1;                      // 0x026C (0x0004) [0x0000000000044000] [0x00000002] (CPF_Config | CPF_GlobalConfig)
	class TArray<struct FEmitterBaseInfo>              RelativePSCs;                                  // 0x0270 (0x0010) [0x0000000000482000] (CPF_Transient | CPF_Component | CPF_NeedCtorLink)
	float                                              SMC_MIC_ReductionTime;                         // 0x0280 (0x0004) [0x0000000000000000]               
	float                                              SMC_MIC_CurrentReductionTime;                  // 0x0284 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            IdealStaticMeshComponents;                     // 0x0288 (0x0004) [0x0000000000000000]               
	class TArray<class UStaticMeshComponent*>          FreeSMComponents;                              // 0x0290 (0x0010) [0x000000000448200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EmitterPool");
		}

		return uClassPointer;
	};

	class UParticleSystemComponent* SpawnEmitterCustomLifetime(class UParticleSystem* EmitterTemplate, bool optionalBSkipAutoActivate, bool optionalBCanBeReclaimed);
	class UParticleSystemComponent* SpawnEmitterMeshAttachment(class UParticleSystem* EmitterTemplate, class USkeletalMeshComponent* Mesh, const struct FName& AttachPointName, bool optionalBAttachToSocket, const struct FVector& optionalRelativeLoc, const struct FRotator& optionalRelativeRot, bool optionalBCanBeReclaimed);
	class UParticleSystemComponent* SpawnEmitter(class UParticleSystem* EmitterTemplate, const struct FVector& SpawnLocation, const struct FRotator& optionalSpawnRotation, class AActor* optionalAttachToActor, class AActor* optionalInInstigator, int32_t optionalMaxDLEPooledReuses, bool optionalBInheritScaleFromBase, bool optionalBCanBeReclaimed, ETickingGroup optionalTickGroupToUse, bool optionalBDontActivate);
	class UParticleSystemComponent* GetPooledComponent(class UParticleSystem* EmitterTemplate, bool bAutoActivate, bool optionalBCanBeReclaimed);
	class UStaticMeshComponent* GetFreeStaticMeshComponent(bool optionalBCreateNewObject);
	void FreeStaticMeshComponents(class UParticleSystemComponent* PSC);
	void ReturnToPool(class UParticleSystemComponent* PSC);
	void ClearAllPoolComponents();
	void ClearPoolComponents(bool optionalBClearActive);
	void OnParticleSystemFinished(class UParticleSystemComponent* PSC);
};

// Class Engine.GBXInfluenceMap
// 0x00B0 (0x0240 - 0x02F0)
class AGBXInfluenceMap : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;           // 0x0240 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	float                                              DesiredNodeSize;                               // 0x0248 (0x0004) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	struct FVector2D                                   NodeSize;                                      // 0x024C (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	struct FVector2D                                   Origin;                                        // 0x0254 (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	int32_t                                            NumNodesX;                                     // 0x025C (0x0004) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	int32_t                                            NumNodesY;                                     // 0x0260 (0x0004) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	class TArray<int32_t>                              PointLookup;                                   // 0x0268 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FInfluenceLookupList>          PointLists;                                    // 0x0278 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FBox                                        BoundingBox;                                   // 0x0288 (0x001C) [0x0000000000000000]               
	uint8_t                                            NumLayers;                                     // 0x02A4 (0x0001) [0x0000000000000000]               
	class TArray<struct FGBXInfluencePoint>            InfluencePoints;                               // 0x02A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class UGBXInfluenceInfo*                           BufferInfo;                                    // 0x02B8 (0x0008) [0x0000000000000000]               
	class AGBXInfluenceMap*                            NextMap;                                       // 0x02C0 (0x0008) [0x0000000000002000] (CPF_Transient)
	class TArray<class UGBXInfluenceInfo*>             InfluenceInfo;                                 // 0x02C8 (0x0010) [0x0000000004420001] (CPF_Edit | CPF_EditConst | CPF_NeedCtorLink | CPF_EditInline)
	int32_t                                            InfluenceInfoVersion;                          // 0x02D8 (0x0004) [0x0000000000000000]               
	class UGBXInfluenceMapRenderingComponent*          RenderComponent;                               // 0x02E0 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              MinNodeSize;                                   // 0x02E8 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXInfluenceMap");
		}

		return uClassPointer;
	};

	void eventNotifyPathChanged();
	static void SetDebug(const struct FName& optionalInfoName);
	static void SetDebugValues();
	void PostBeginPlay();
	void RemoveFromList();
	void AddToList();
	int32_t GetInfoIdxByClass(class UClass* InfoClass, const struct FName& optionalInfoName);
	class UGBXInfluenceInfo* GetInfoByClass(class UClass* InfoClass, const struct FName& optionalInfoName);
	class UGBXInfluenceInfo* GetInfoByIndex(int32_t InfoIdx);
	class UGBXInfluenceInfo* GetInfoByName(const struct FName& InfoName);
	struct FVector GetPointLocation(int32_t PointIdx);
	void InitializeInfluenceInfo();
	void CacheInfluenceInfo();
	void ClearInfluenceInfo();
	int32_t GetNodeRadiusFromUnitRadius(float UnitRadius);
	bool GetPointsInNodeRadius(int32_t NodeRadius, struct FVector& Loc, class TArray<int32_t>& OutPoints);
	bool GetXYZFromPointIdx(int32_t PointIdx, int32_t& XIndex, int32_t& YIndex, int32_t& ZIndex);
	struct FVector GetDefaultPointLocation(int32_t PointIdx);
	struct FVector GetDefaultLocation(struct FVector& InLoc);
	int32_t GetPointForXYZ(int32_t XIndex, int32_t YIndex, int32_t ZIndex);
	bool GetPointsAtLookupIdx(int32_t LookupIdx, class TArray<int32_t>& OutPoints);
	void GetLocationForLookupIndex(int32_t LookupIdx, struct FVector& Loc);
	int32_t GetLookupIdxForLocation(struct FVector& Loc);
	void GetXYFromLookupIndex(int32_t Index, int32_t& XIndex, int32_t& YIndex);
	int32_t GetLookupIndexFromXY(int32_t XIndex, int32_t YIndex);
	int32_t GetNodeIndexY(float Y, bool optionalBClamp);
	int32_t GetNodeIndexX(float X, bool optionalBClamp);
};

// Class Engine.GBXNavMesh
// 0x01B0 (0x0240 - 0x03F0)
class AGBXNavMesh : public AActor
{
public:
	int32_t                                            BuildVersion;                                  // 0x0240 (0x0004) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	struct FGuid                                       BuildGUID;                                     // 0x0244 (0x0010) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	int32_t                                            MeshID;                                        // 0x0254 (0x0004) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	class TArray<struct FGBXConnectedNavMesh>          ConnectedMeshes;                               // 0x0258 (0x0010) [0x0000000000420001] (CPF_Edit | CPF_EditConst | CPF_NeedCtorLink)
	class TArray<struct FGBXNavMeshVertex>             Vertices;                                      // 0x0268 (0x0010) [0x0000000000021001] (CPF_Edit | CPF_Native | CPF_EditConst)
	class TArray<struct FGBXNavMeshPoly>               Polys;                                         // 0x0278 (0x0010) [0x0000000000021001] (CPF_Edit | CPF_Native | CPF_EditConst)
	class TArray<struct FGBXNavMeshPolyData>           PolyData;                                      // 0x0288 (0x0010) [0x0000000000021001] (CPF_Edit | CPF_Native | CPF_EditConst)
	class TArray<struct FGBXNavMeshPathSize>           PathSizes;                                     // 0x0298 (0x0010) [0x0000000000021001] (CPF_Edit | CPF_Native | CPF_EditConst)
	class TArray<struct FGBXNavMeshObstacleData>       Obstacles;                                     // 0x02A8 (0x0010) [0x0000000000021001] (CPF_Edit | CPF_Native | CPF_EditConst)
	class TArray<class UGBXCrossLevelReferenceContainer*> SpecialMovers;                                 // 0x02B8 (0x0010) [0x0000000000021001] (CPF_Edit | CPF_Native | CPF_EditConst)
	class AActor*                                      MeshBase;                                      // 0x02C8 (0x0008) [0x0000000000021001] (CPF_Edit | CPF_Native | CPF_EditConst)
	class AGBXInfluenceMap*                            MyInfluenceMap;                                // 0x02D0 (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	struct FGBXNavMeshPolyLookup                       PolyLookup;                                    // 0x02D8 (0x0040) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<struct FInfluenceLookupList>          InfluenceLists;                                // 0x0318 (0x0010) [0x0000000000021001] (CPF_Edit | CPF_Native | CPF_EditConst)
	uint8_t                                           UnknownData00[0x8];                            // 0x0328 (0x0008) MISSED OFFSET
	struct FMatrix                                     CachedLocalToWorld;                            // 0x0330 (0x0040) [0x0000000000002000] (CPF_Transient)
	struct FMatrix                                     CachedWorldToLocal;                            // 0x0370 (0x0040) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     CachedBaseLocation;                            // 0x03B0 (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FRotator                                    CachedBaseRotation;                            // 0x03BC (0x000C) [0x0000000000002000] (CPF_Transient)
	class AGBXNavMesh*                                 NextNavMesh;                                   // 0x03C8 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FPointer                                    BuildData;                                     // 0x03D0 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)
	uint32_t                                           bShowPolyDebugText : 1;                        // 0x03D8 (0x0004) [0x0000000800006001] [0x00000001] (CPF_Edit | CPF_Transient | CPF_Config)
	class UGBXNavMeshRenderingComponent*               RenderComponent;                               // 0x03E0 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	uint8_t                                           UnknownData01[0x8];                            // 0x03E8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXNavMesh");
		}

		return uClassPointer;
	};

	bool PolyContainsPoint(int32_t PolyIdx, const struct FVector& Point, bool optionalBDoHeightCheck, float optionalTolerance, bool optionalBWorldSpace, struct FVector& NearestPointOnPoly);
	void OnPotentiallyConnectedMeshRemoved(class AGBXNavMesh* NavMesh);
	void OnPotentiallyConnectedMeshAdded(class AGBXNavMesh* NavMesh);
	void FixupOldVersions();
	void eventDestroyed();
	void eventPostBeginPlay();
};

// Class Engine.GBXStaticActorStateReplicator
// 0x0118 (0x0240 - 0x0358)
class AGBXStaticActorStateReplicator : public AActor
{
public:
	uint8_t                                            ReplicatedActorStates[0x100];                  // 0x0240 (0x0100) [0x0000000100002020] (CPF_Net | CPF_Transient)
	class TArray<class AActor*>                        RegisteredActors;                              // 0x0340 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class AGBXStaticActorStateReplicator*              NextReplicator;                                // 0x0350 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXStaticActorStateReplicator");
		}

		return uClassPointer;
	};

	void OnActorStateChanged(int32_t ActorIndex);
	void eventReplicatedArrayEvent(const struct FName& VarName, int32_t ArrayIndex);
	static bool SetReplicatedActorState(uint8_t NewState, struct FStaticActorReplicationData& RepData);
};

// Class Engine.HUD
// 0x00C8 (0x0240 - 0x0308)
class AHUD : public AActor
{
public:
	struct FColor                                      WhiteColor;                                    // 0x0240 (0x0004) [0x0000000000000002] (CPF_Const)   
	struct FColor                                      GreenColor;                                    // 0x0244 (0x0004) [0x0000000000000002] (CPF_Const)   
	struct FColor                                      RedColor;                                      // 0x0248 (0x0004) [0x0000000000000002] (CPF_Const)   
	class APlayerController*                           PlayerOwner;                                   // 0x0250 (0x0008) [0x0000000000000000]               
	class AActor*                                      AnimDebugThis;                                 // 0x0258 (0x0008) [0x0000000000000000]               
	struct FName                                       AnimDebugStartingPoint;                        // 0x0260 (0x0008) [0x0000000000000000]               
	int32_t                                            AnimDebugAttachmentIndex;                      // 0x0268 (0x0004) [0x0000000000000000]               
	uint32_t                                           bLostFocusPaused : 1;                          // 0x026C (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)
	uint32_t                                           bShowHUD : 1;                                  // 0x026C (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bShowScores : 1;                               // 0x026C (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bShowDebugInfo : 1;                            // 0x026C (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bShowAnimDebug : 1;                            // 0x026C (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bShowBadConnectionAlert : 1;                   // 0x026C (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bMessageBeep : 1;                              // 0x026C (0x0004) [0x0000000000044000] [0x00000040] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bShowOverlays : 1;                             // 0x026C (0x0004) [0x0000000000000000] [0x00000080] 
	float                                              HudCanvasScale;                                // 0x0270 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	class TArray<class AActor*>                        PostRenderedActors;                            // 0x0278 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FConsoleMessage>               ConsoleMessages;                               // 0x0288 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FColor                                      ConsoleColor;                                  // 0x0298 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            ConsoleMessageCount;                           // 0x029C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            ConsoleFontSize;                               // 0x02A0 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            MessageFontOffset;                             // 0x02A4 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            MaxHUDAreaMessageCount;                        // 0x02A8 (0x0004) [0x0000000000000000]               
	float                                              ConsoleMessagePosX;                            // 0x02AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ConsoleMessagePosY;                            // 0x02B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UCanvas*                                     Canvas;                                        // 0x02B8 (0x0008) [0x0000000000000000]               
	float                                              LastHUDRenderTime;                             // 0x02C0 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              RenderDelta;                                   // 0x02C4 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              SizeX;                                         // 0x02C8 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              SizeY;                                         // 0x02CC (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              CenterX;                                       // 0x02D0 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              CenterY;                                       // 0x02D4 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              RatioX;                                        // 0x02D8 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              RatioY;                                        // 0x02DC (0x0004) [0x0000000000002000] (CPF_Transient)
	class TArray<struct FName>                         DebugDisplay;                                  // 0x02E0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	struct FName                                       ActiveDebugDisplay;                            // 0x02F0 (0x0008) [0x0000000000000000]               
	class TArray<struct FKismetDrawTextInfo>           KismetTextInfo;                                // 0x02F8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.HUD");
		}

		return uClassPointer;
	};

	bool eventGetShowZones();
	bool eventGetShowCoverNum();
	bool eventGetShowCoverVis();
	bool eventGetShowCoverRegions();
	void eventOnLostFocusPause(bool bEnable);
	void PlayerOwnerDied();
	void AddConsoleMessage(const class FString& M, class UClass* InMessageClass, class APlayerReplicationInfo* PRI, float optionalLifetime);
	void eventDisplayConsoleMessages();
	void Message(class APlayerReplicationInfo* PRI, const class FString& msg, const struct FName& MsgType, float optionalLifetime);
	void eventDisplayBadConnectionAlert();
	void DrawbShowHUDIsFalseHUD();
	void DrawHUD();
	void MakeActivePrevShowDebugGroup();
	void MakeActiveNextShowDebugGroup();
	void PrevShowDebugPage();
	void NextShowDebugPage();
	void DrawShowDebugHeader();
	void eventShowDebugInfo();
	void eventPostRender();
	void PreCalcValues();
	void DrawRoute(class APawn* Target);
	void ShowPawnAnimDebug(class UClass* aClass, const class FString& optionalStartingPoint);
	void ShowWeapAnimDebug(const class FString& optionalStartingPoint);
	void ShowAnimDebug(const class FString& optionalStartingPoint, int32_t optionalAttachmentIndex);
	void Epic_ShowDebugInfo(float& out_YL, float& out_YPos);
	void ShowDebug(const struct FName& optionalDebugType);
	bool ShouldDisplayDebug(const struct FName& DebugType);
	void SetShowScores(bool bNewValue);
	void ShowScores();
	void ShowHUD();
	void ToggleHUD();
	void AddPostRenderedActor(class AActor* A);
	void RemovePostRenderedActor(class AActor* A);
	void eventPostBeginPlay();
	void Draw2DLine(int32_t X1, int32_t Y1, int32_t X2, int32_t Y2, const struct FColor& LineColor);
	void Draw3DLine(const struct FVector& Start, const struct FVector& End, const struct FColor& LineColor);
};

// Class Engine.DebugCameraHUD
// 0x0000 (0x0308 - 0x0308)
class ADebugCameraHUD : public AHUD
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DebugCameraHUD");
		}

		return uClassPointer;
	};

	void eventPostRender();
	bool DisplayMaterials(float X, float DY, class UMeshComponent* MeshComp, float& Y);
	void eventPostBeginPlay();
};

// Class Engine.IDestructibleObject
// 0x0000 (0x0240 - 0x0240)
class AIDestructibleObject : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IDestructibleObject");
		}

		return uClassPointer;
	};

};

// Class Engine.Info
// 0x0000 (0x0240 - 0x0240)
class AInfo : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Info");
		}

		return uClassPointer;
	};

};

// Class Engine.AccessControl
// 0x0120 (0x0240 - 0x0360)
class AAccessControl : public AInfo
{
public:
	class TArray<class FString>                        IPPolicies;                                    // 0x0240 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class TArray<struct FUniqueNetId>                  BannedIDs;                                     // 0x0250 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class FString                                      IPBanned;                                      // 0x0260 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      WrongPassword;                                 // 0x0270 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      NeedPassword;                                  // 0x0280 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      SessionBanned;                                 // 0x0290 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      KickedMsg;                                     // 0x02A0 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      DefaultKickReason;                             // 0x02B0 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      IdleKickReason;                                // 0x02C0 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class UClass*                                      AdminClass;                                    // 0x02D0 (0x0008) [0x0000000000000000]               
	class FString                                      AdminPassword;                                 // 0x02D8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class FString                                      GamePassword;                                  // 0x02E8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class FString                                      ACDisplayText[0x3];                            // 0x02F8 (0x0030) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      ACDescText[0x3];                               // 0x0328 (0x0030) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	uint32_t                                           bDontAddDefaultAdmin : 1;                      // 0x0358 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bPendingPostSeamlessInit : 1;                  // 0x0358 (0x0004) [0x0000000000000000] [0x00000002] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AccessControl");
		}

		return uClassPointer;
	};

	void eventPreLogin(const class FString& Options, const class FString& Address, const struct FUniqueNetId& UniqueId, bool bSpectator, class FString& OutError);
	bool IsIDBanned(struct FUniqueNetId& NetId);
	bool CheckIPPolicy(const class FString& Address);
	bool ValidLogin(const class FString& UserName, const class FString& Password);
	bool ParseAdminOptions(const class FString& Options);
	void AdminExited(class APlayerController* P);
	void AdminEntered(class APlayerController* P);
	bool AdminLogout(class APlayerController* P);
	bool AdminLogin(class APlayerController* P, const class FString& Password);
	bool KickPlayer(class APlayerController* C, const class FString& KickReason);
	bool ForceKickPlayer(class APlayerController* C, const class FString& KickReason);
	void KickBan(const class FString& Target);
	void Kick(const class FString& Target);
	class AController* GetControllerFromString(const class FString& Target);
	bool RequiresPassword();
	void SetGamePassword(const class FString& P);
	bool SetAdminPassword(const class FString& P);
	bool IsAdmin(class APlayerController* P);
	void PostBeginPlay();
};

// Class Engine.AutoTestManager
// 0x0110 (0x0240 - 0x0350)
class AAutoTestManager : public AInfo
{
public:
	uint32_t                                           bAutomatedPerfTesting : 1;                     // 0x0240 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bAutoContinueToNextRound : 1;                  // 0x0240 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bUsingAutomatedTestingMapList : 1;             // 0x0240 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bExitOnCyclesComplete : 1;                     // 0x0240 (0x0004) [0x0000000000044000] [0x00000008] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bCheckingForFragmentation : 1;                 // 0x0240 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bCheckingForMemLeaks : 1;                      // 0x0240 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bDoingASentinelRun : 1;                        // 0x0240 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bSentinelStreamingLevelStillLoading : 1;       // 0x0240 (0x0004) [0x0000000000002000] [0x00000080] (CPF_Transient)
	uint32_t                                           bCanCollectStatsWhilePaused : 1;               // 0x0240 (0x0004) [0x0000000000004000] [0x00000100] (CPF_Config)
	uint32_t                                           bFinishedTraversal : 1;                        // 0x0240 (0x0004) [0x0000000000000000] [0x00000200] 
	int32_t                                            AutomatedPerfRemainingTime;                    // 0x0244 (0x0004) [0x0000000000000000]               
	int32_t                                            AutomatedTestingMapIndex;                      // 0x0248 (0x0004) [0x0000000000000000]               
	class TArray<class FString>                        AutomatedMapTestingList;                       // 0x0250 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class TArray<class FString>                        AutomatedMapDLC1TestingList;                   // 0x0260 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	int32_t                                            NumAutomatedMapTestingCycles;                  // 0x0270 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            TimeLimit;                                     // 0x0274 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            NumberOfMatchesPlayed;                         // 0x0278 (0x0004) [0x0000000000000000]               
	int32_t                                            NumMapListCyclesDone;                          // 0x027C (0x0004) [0x0000000000000000]               
	class FString                                      AutomatedTestingExecCommandToRunAtStartMatch;  // 0x0280 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      AutomatedMapTestingTransitionMap;              // 0x0290 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      SentinelTaskDescription;                       // 0x02A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      SentinelTaskParameter;                         // 0x02B0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      SentinelTagDesc;                               // 0x02C0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class APlayerController*                           SentinelPC;                                    // 0x02D0 (0x0008) [0x0000000000002000] (CPF_Transient)
	class TArray<struct FVector>                       SentinelTravelArray;                           // 0x02D8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	int32_t                                            SentinelNavigationIdx;                         // 0x02E8 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            SentinelIdx;                                   // 0x02EC (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            NumRotationsIncrement;                         // 0x02F0 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            TravelPointsIncrement;                         // 0x02F4 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            NumMinutesPerMap;                              // 0x02F8 (0x0004) [0x0000000000004000] (CPF_Config)  
	class TArray<class FString>                        CommandsToRunAtEachTravelTheWorldNode;         // 0x0300 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class FString                                      CommandStringToExec;                           // 0x0310 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class FString                                      SelectedCharacterClass;                        // 0x0320 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FName                                       StationDefName;                                // 0x0330 (0x0008) [0x0000000000000000]               
	class FString                                      AutomatedTestingTravelType;                    // 0x0338 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            NumOfDLCsToIncludeInRun;                       // 0x0348 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AutoTestManager");
		}

		return uClassPointer;
	};

	bool CheckForSentinelRun();
	void StartMatch();
	void StopTraversal();
	class FString GetNextAutomatedTestingMap();
	void IncrementNumberOfMatchesPlayed();
	void IncrementAutomatedTestingMapIndex();
	void CloseAutomatedMapTestTimer();
	void StartAutomatedMapTestTimerWorker();
	void eventStartAutomatedMapTestTimer();
	void eventStartMenuTimer();
	void DoSentinel_TakeManualMemSnapshot();
	void DoMemoryTracking();
	void DoTimeBasedSentinelStatGathering();
	void DoSentinel_PerfAtSpecificLocation(struct FVector& InLocation, struct FRotator& InRotation);
	void DoSentinel_MemoryAtSpecificLocation(const struct FVector& InLocation, const struct FRotator& InRotation);
	void GetTravelLocations(const struct FName& LevelName, class APlayerController* PC, class TArray<struct FVector>& TravelPoints);
	void HandlePerLoadedMapAudioStats();
	void DoSentinelActionPerLoadedMap();
	void DoAutomatedSmokeTest();
	void DoUIAutoMemTest();
	void DoTravelTheWorld();
	void EndSentinelRun(EAutomatedRunResult RunResult);
	void AddSentinelPerTimePeriodStats(const struct FVector& InLocation, const struct FRotator& InRotation);
	void BeginSentinelRun(const class FString& TaskDescription, const class FString& TaskParameter, const class FString& TagDesc, const class FString& MapFrom, const class FString& MapTo);
	void PopulateFullAutomatedTestingMapList();
	void InitializeOptions(const class FString& Options);
	void eventTimer();
	void eventPostBeginPlay();
};

// Class Engine.BroadcastHandler
// 0x0008 (0x0240 - 0x0248)
class ABroadcastHandler : public AInfo
{
public:
	int32_t                                            SentText;                                      // 0x0240 (0x0004) [0x0000000000000000]               
	uint32_t                                           bMuteSpectators : 1;                           // 0x0244 (0x0004) [0x0000000000004000] [0x00000001] (CPF_Config)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BroadcastHandler");
		}

		return uClassPointer;
	};

	void eventAllowBroadcastLocalizedTeam(int32_t TeamIndex, class AActor* Sender, class UClass* Message, int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	void eventAllowBroadcastLocalized(class AActor* Sender, class UClass* Message, int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	void BroadcastTeam(class AController* Sender, const class FString& msg, const struct FName& optionalType);
	void Broadcast(class AActor* Sender, const class FString& msg, const struct FName& optionalType);
	void BroadcastLocalized(class AActor* Sender, class APlayerController* Receiver, class UClass* Message, int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	void BroadcastText(class APlayerReplicationInfo* SenderPRI, class APlayerController* Receiver, const class FString& msg, const struct FName& optionalType);
	bool AllowsBroadcast(class AActor* broadcaster, int32_t InLen);
	void UpdateSentText();
};

// Class Engine.CoverGroup
// 0x0018 (0x0240 - 0x0258)
class ACoverGroup : public AInfo
{
public:
	class TArray<struct FActorReference>               CoverLinkRefs;                                 // 0x0240 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              AutoSelectRadius;                              // 0x0250 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AutoSelectHeight;                              // 0x0254 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CoverGroup");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* Action);
	void ToggleGroup();
	void DisableGroup();
	void EnableGroup();
};

// Class Engine.ExponentialHeightFog
// 0x0010 (0x0240 - 0x0250)
class AExponentialHeightFog : public AInfo
{
public:
	class UExponentialHeightFogComponent*              Component;                                     // 0x0240 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	uint32_t                                           bEnabled : 1;                                  // 0x0248 (0x0004) [0x0000000100000020] [0x00000001] (CPF_Net)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ExponentialHeightFog");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* Action);
	void eventReplicatedEvent(const struct FName& VarName);
	void eventPostBeginPlay();
};

// Class Engine.FileWriter
// 0x0020 (0x0240 - 0x0260)
class AFileWriter : public AInfo
{
public:
	struct FPointer                                    ArchivePtr;                                    // 0x0240 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	class FString                                      Filename;                                      // 0x0248 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	EFWFileType                                        FileType;                                      // 0x0258 (0x0001) [0x0000000000000002] (CPF_Const)   
	uint32_t                                           bFlushEachWrite : 1;                           // 0x025C (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bWantsAsyncWrites : 1;                         // 0x025C (0x0004) [0x0000000000000000] [0x00000002] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FileWriter");
		}

		return uClassPointer;
	};

	void eventDestroyed();
	void Logf(const class FString& logString);
	void CloseFile();
	bool OpenFile(const class FString& InFilename, EFWFileType optionalInFileType, const class FString& optionalInExtension, bool optionalBUnique, bool optionalBIncludeTimeStamp);
};

// Class Engine.FileLog
// 0x0000 (0x0260 - 0x0260)
class AFileLog : public AFileWriter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FileLog");
		}

		return uClassPointer;
	};

	void CloseLog();
	void OpenLog(const class FString& LogFilename, const class FString& optionalExtension, bool optionalBUnique);
};

// Class Engine.FogVolumeDensityInfo
// 0x0018 (0x0240 - 0x0258)
class AFogVolumeDensityInfo : public AInfo
{
public:
	class UFogVolumeDensityComponent*                  DensityComponent;                              // 0x0240 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	class UStaticMeshComponent*                        AutomaticMeshComponent;                        // 0x0248 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	uint32_t                                           bEnabled : 1;                                  // 0x0250 (0x0004) [0x0000000100000020] [0x00000001] (CPF_Net)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FogVolumeDensityInfo");
		}

		return uClassPointer;
	};

	void ApplyCheckpointRecord(struct FFogVolumeDensityInfoCheckpointRecord& Record);
	void CreateCheckpointRecord(struct FFogVolumeDensityInfoCheckpointRecord& Record);
	bool ShouldSaveForCheckpoint();
	void OnToggle(class USeqAct_Toggle* Action);
	void eventReplicatedEvent(const struct FName& VarName);
	void eventPostBeginPlay();
};

// Class Engine.FogVolumeConeDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeConeDensityInfo : public AFogVolumeDensityInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FogVolumeConeDensityInfo");
		}

		return uClassPointer;
	};

};

// Class Engine.FogVolumeConstantDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeConstantDensityInfo : public AFogVolumeDensityInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FogVolumeConstantDensityInfo");
		}

		return uClassPointer;
	};

};

// Class Engine.FogVolumeLinearHalfspaceDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeLinearHalfspaceDensityInfo : public AFogVolumeDensityInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FogVolumeLinearHalfspaceDensityInfo");
		}

		return uClassPointer;
	};

};

// Class Engine.FogVolumeSphericalDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeSphericalDensityInfo : public AFogVolumeDensityInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FogVolumeSphericalDensityInfo");
		}

		return uClassPointer;
	};

};

// Class Engine.GameInfo
// 0x01E8 (0x0240 - 0x0428)
class AGameInfo : public AInfo
{
public:
	uint32_t                                           bRestartLevel : 1;                             // 0x0240 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bTeamGame : 1;                                 // 0x0240 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bDelayedStart : 1;                             // 0x0240 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bChangeLevels : 1;                             // 0x0240 (0x0004) [0x0000000000044000] [0x00000008] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bAlreadyChanged : 1;                           // 0x0240 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bGameRestarted : 1;                            // 0x0240 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bLevelChange : 1;                              // 0x0240 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bKickLiveIdlers : 1;                           // 0x0240 (0x0004) [0x0000000000044000] [0x00000080] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bShutdownAIWhenIrrelevant : 1;                 // 0x0240 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bFixedPlayerStart : 1;                         // 0x0240 (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bOverrideEffectiveNumPlayers : 1;              // 0x0240 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bMovementTimeDiscrepancyDetection : 1;         // 0x0240 (0x0004) [0x0000000000044000] [0x00000800] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bMovementTimeDiscrepancyResolution : 1;        // 0x0240 (0x0004) [0x0000000000044000] [0x00001000] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bMovementTimeDiscrepancyForceCorrectionsDuringResolution : 1;// 0x0240 (0x0004) [0x0000000000044000] [0x00002000] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bUseSeamlessTravel : 1;                        // 0x0240 (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bHasNetworkError : 1;                          // 0x0240 (0x0004) [0x0000000000000000] [0x00008000] 
	uint32_t                                           bRequiresPushToTalk : 1;                       // 0x0240 (0x0004) [0x0000000000000002] [0x00010000] (CPF_Const)
	uint32_t                                           bIsStandbyCheckingEnabled : 1;                 // 0x0240 (0x0004) [0x0000000000004000] [0x00020000] (CPF_Config)
	uint32_t                                           bIsStandbyCheckingOn : 1;                      // 0x0240 (0x0004) [0x0000000000000000] [0x00040000] 
	uint32_t                                           bHasStandbyCheatTriggered : 1;                 // 0x0240 (0x0004) [0x0000000000000000] [0x00080000] 
	class FString                                      CauseEventCommand;                             // 0x0248 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      BugLocString;                                  // 0x0258 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      BugRotString;                                  // 0x0268 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              GameDifficulty;                                // 0x0278 (0x0004) [0x4000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            GoreLevel;                                     // 0x027C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              GameSpeed;                                     // 0x0280 (0x0004) [0x0000000000000000]               
	class UClass*                                      DefaultPawnClass;                              // 0x0288 (0x0008) [0x0000000000000000]               
	class UClass*                                      HUDType;                                       // 0x0290 (0x0008) [0x0000000000000000]               
	int32_t                                            MaxSpectators;                                 // 0x0298 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            MaxSpectatorsAllowed;                          // 0x029C (0x0004) [0x0000000000000000]               
	int32_t                                            NumSpectators;                                 // 0x02A0 (0x0004) [0x0000000000000000]               
	int32_t                                            MaxPlayers;                                    // 0x02A4 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            MaxPlayersAllowed;                             // 0x02A8 (0x0004) [0x0000000000000000]               
	int32_t                                            NumPlayers;                                    // 0x02AC (0x0004) [0x4000000000000000]               
	int32_t                                            EffectiveNumPlayers;                           // 0x02B0 (0x0004) [0x4000000000000000]               
	int32_t                                            NumBots;                                       // 0x02B4 (0x0004) [0x0000000000000000]               
	int32_t                                            NumTravellingPlayers;                          // 0x02B8 (0x0004) [0x0000000000000000]               
	int32_t                                            CurrentID;                                     // 0x02BC (0x0004) [0x0000000000000000]               
	class FString                                      DefaultPlayerName;                             // 0x02C0 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      GameName;                                      // 0x02D0 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	int32_t                                            GoalScore;                                     // 0x02E0 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            MaxLives;                                      // 0x02E4 (0x0004) [0x0000000000004000] (CPF_Config)  
	class UClass*                                      DeathMessageClass;                             // 0x02E8 (0x0008) [0x0000000000000000]               
	class UClass*                                      GameMessageClass;                              // 0x02F0 (0x0008) [0x0000000000000000]               
	class UClass*                                      AccessControlClass;                            // 0x02F8 (0x0008) [0x0000000000000000]               
	class AAccessControl*                              AccessControl;                                 // 0x0300 (0x0008) [0x0000000000000000]               
	class UClass*                                      BroadcastHandlerClass;                         // 0x0308 (0x0008) [0x0000000000000000]               
	class ABroadcastHandler*                           BroadcastHandler;                              // 0x0310 (0x0008) [0x0000000000000000]               
	class UClass*                                      AutoTestManagerClass;                          // 0x0318 (0x0008) [0x0000000000000000]               
	class AAutoTestManager*                            MyAutoTestManager;                             // 0x0320 (0x0008) [0x0000000000000000]               
	class UClass*                                      PlayerControllerClass;                         // 0x0328 (0x0008) [0x0000000000000000]               
	class UClass*                                      PlayerReplicationInfoClass;                    // 0x0330 (0x0008) [0x0000000000000000]               
	class UClass*                                      GameReplicationInfoClass;                      // 0x0338 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class AGameReplicationInfo*                        GameReplicationInfo;                           // 0x0340 (0x0008) [0x0000000000000000]               
	float                                              MaxIdleTime;                                   // 0x0348 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MaxIdleWarningTime;                            // 0x034C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MovementTimeDiscrepancyMaxTimeMargin;          // 0x0350 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MovementTimeDiscrepancyMinTimeMargin;          // 0x0354 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MovementTimeDiscrepancyResolutionRate;         // 0x0358 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MovementTimeDiscrepancyDriftAllowance;         // 0x035C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MovementTimeDiscrepancyHitchTime;              // 0x0360 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MovementTimeDiscrepancyHitchCooldown;          // 0x0364 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              StartReportingMovementDiscrepancyTime;         // 0x0368 (0x0004) [0x0000000000000000]               
	class UOnlineSubsystem*                            OnlineSub;                                     // 0x0370 (0x0008) [0x0000000000000000]               
	class UOnlineGameInterface*                        GameInterface_Object;                          // 0x0378 (0x0008) [0x0000000000000000] 
	class UOnlineGameInterface*                        GameInterface_Interface;                       // 0x0380 (0x0008) [0x0000000000000000]               
	class UClass*                                      OnlineStatsWriteClass;                         // 0x0388 (0x0008) [0x0000000000000000]               
	int32_t                                            LeaderboardId;                                 // 0x0390 (0x0004) [0x0000000000000000]               
	class UClass*                                      OnlineGameSettingsClass;                       // 0x0398 (0x0008) [0x0000000000000002] (CPF_Const)   
	class FString                                      ServerOptions;                                 // 0x03A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            AdjustedNetSpeed;                              // 0x03B0 (0x0004) [0x0000000000000000]               
	float                                              LastNetSpeedUpdateTime;                        // 0x03B4 (0x0004) [0x0000000000000000]               
	int32_t                                            TotalNetBandwidth;                             // 0x03B8 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            MinDynamicBandwidth;                           // 0x03BC (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            MaxDynamicBandwidth;                           // 0x03C0 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              StandbyRxCheatTime;                            // 0x03C4 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              StandbyTxCheatTime;                            // 0x03C8 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            BadPingThreshold;                              // 0x03CC (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              PercentMissingForRxStandby;                    // 0x03D0 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              PercentMissingForTxStandby;                    // 0x03D4 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              PercentForBadPing;                             // 0x03D8 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              JoinInProgressStandbyWaitTime;                 // 0x03DC (0x0004) [0x0000000000004000] (CPF_Config)  
	class TArray<struct FGameClassShortName>           GameInfoClassAliases;                          // 0x03E0 (0x0010) [0x0000000000404003] (CPF_Edit | CPF_Const | CPF_Config | CPF_NeedCtorLink)
	class FString                                      DefaultGameType;                               // 0x03F0 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class TArray<struct FGameTypePrefix>               DefaultMapPrefixes;                            // 0x0400 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class TArray<struct FGameTypePrefix>               CustomMapPrefixes;                             // 0x0410 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	int32_t                                            AnimTreePoolSize;                              // 0x0420 (0x0004) [0x0000000000004000] (CPF_Config)  

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GameInfo");
		}

		return uClassPointer;
	};

	void Beacon(class UClass* BeaconActorClass, uint8_t optionalRed, uint8_t optionalGreen, uint8_t optionalBlue);
	void CheckForDebugBeacon(class AActor* BeaconTestActor);
	void eventOnEngineHasLoaded();
	void eventStandbyCheatDetected(EStandbyType StandbyType);
	void EnableStandbyCheatDetection(bool bIsEnabled);
	void BeginBVT(const class FString& optionalTagDesc);
	bool CheckForSentinelRun();
	bool ShouldAutoContinueToNextRound();
	bool IsDoingASentinelRun();
	bool IsCheckingForMemLeaks();
	bool IsCheckingForFragmentation();
	bool IsAutomatedPerfTesting();
	void SetBandwidthLimit(float AsyncIOBandwidthLimit);
	void DoTravelTheWorld();
	static void DoGameSpecificPerformanceSettings(class AWorldInfo* TheWorldInfo);
	void TellClientsToTravelToSession(const struct FName& SessionName, class UClass* SearchClass, const struct FPlatformSessionData& PlatformSpecificInfo);
	void TellClientsPartyHostIsLeaving(const struct FUniqueNetId& PartyHostPlayerId);
	void TellClientsToReturnToPartyHost();
	void OnServerCreateComplete(const struct FName& SessionName, EOnlineSubsystemResult Result);
	void RegisterServer();
	void eventMatineeCancelled();
	bool MatchIsInProgress();
	void UpdateGameSettingsCounts();
	void SetSeamlessTravelViewTarget(class APlayerController* PC);
	void eventHandleSeamlessTravelPlayer(class AController*& C);
	void UpdateGameSettings();
	void eventPostSeamlessTravel();
	void SwapPlayerControllers(class APlayerController* OldPC, class APlayerController* NewPC);
	void eventGetSeamlessTravelActorList(bool bToEntry, class TArray<class AActor*>& ActorList);
	void OverridePRI(class APlayerController* PC, class APlayerReplicationInfo* OldPRI);
	void eventPostCommitMapChange();
	void eventPreCommitMapChange(const class FString& PreviousMapName, const class FString& NextMapName);
	bool PlayerCanRestart(class APlayerController* aPlayer);
	bool PlayerCanRestartGame(class APlayerController* aPlayer);
	void DriverLeftVehicle(class AVehicle* V, class APawn* P);
	bool CanLeaveVehicle(class AVehicle* V, class APawn* P);
	void DriverEnteredVehicle(class AVehicle* V, class APawn* P);
	void ModifyScoreKill(class AController* Killer, class AController* Other);
	void ScoreKill(class AController* Killer, class AController* Other);
	bool CheckScore(class APlayerReplicationInfo* Scorer);
	void ScoreObjective(class APlayerReplicationInfo* Scorer, int32_t Score);
	void AddObjectiveScore(class APlayerReplicationInfo* Scorer, int32_t Score);
	float RatePlayerStart(class APlayerStart* P, uint8_t Team, class AController* Player);
	class APlayerStart* eventChoosePlayerStart(class AController* Player, uint8_t optionalInTeam);
	class AActor* FindPlayerStart(class AController* Player, uint8_t optionalInTeam, const class FString& optionalIncomingName);
	bool ShouldSpawnAtStartSpot(class AController* Player);
	void EndLogging(const class FString& Reason);
	void GameEventsPoll();
	void EndOnlineGame();
	void PerformEndGameHandling();
	void EndGame(class APlayerReplicationInfo* Winner, const class FString& Reason);
	void WriteOnlinePlayerScores();
	void WriteOnlineStats();
	void eventBroadcastLocalizedTeam(int32_t TeamIndex, class AActor* Sender, class UClass* Message, int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	void eventBroadcastLocalized(class AActor* Sender, class UClass* Message, int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	void BroadcastTeam(class AController* Sender, const class FString& msg, const struct FName& optionalType);
	void eventBroadcast(class AActor* Sender, const class FString& msg, const struct FName& optionalType);
	void RestartGame();
	bool GetTravelType();
	class FString GetNextMap();
	void SendPlayer(class APlayerController* aPlayer, const class FString& URL);
	uint8_t PickTeam(uint8_t Current, const struct FUniqueNetId& UniqueId);
	bool ChangeTeam(class AController* Other, int32_t N, bool bNewTeam);
	void ChangeName(class AController* Other, const class FString& S, bool bNameChange);
	void DiscardInventory(class APawn* Other, class AController* optionalKiller);
	bool ShouldPawnDropWeaponOnDeath(class APawn* P);
	bool CheckRelevance(class AActor* Other);
	void ReduceDamage(class APawn* injured, class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* DamageType, class UIDamageCauser* DamageCauser, class UDamagePipeline* optionalPipeline, float& Damage, struct FVector& Momentum);
	class UDamageTypeDefinition* eventGetHealingDamageTypeDefinition();
	bool ConvertDamageToHealing(float Damage, class APawn* DamagedPawn, class AController* DamageInstigator, const struct FVector& HitLocation, class UClass* DamageSource, const struct FTraceHitInfo& optionalHitInfo, class UDamagePipeline* optionalPipeline);
	bool IsFriendlyFire(class APawn* injured, class UITargetable* InstigatingTargetable);
	bool CanSpectate(class APlayerController* Viewer, class APlayerReplicationInfo* ViewTarget);
	void KickBan(const class FString& S);
	void Kick(const class FString& S);
	void BroadcastDeathMessage(class AController* Killer, class AController* Other, class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition);
	bool PreventDeath(class APawn* KilledPawn, class AController* Killer, class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition, const struct FVector& HitLocation);
	void Killed(class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, class UClass* DamageType, class UDamagePipeline* Pipeline);
	void NotifyKilled(class AController* Killer, class AController* Killed, class APawn* KilledPawn, class UClass* DamageType, class UDamagePipeline* Pipeline);
	void SetPlayerDefaults(class APawn* PlayerPawn);
	void eventAddDefaultInventory(class APawn* P);
	void eventAcceptInventory(class APawn* PlayerPawn);
	void UnregisterPlayer(class APlayerController* PC);
	void Logout(class AController* Exiting);
	void eventPreExit();
	int32_t CalculatedNetSpeed();
	void UpdateNetSpeeds();
	void eventPostLogin(class APlayerController* NewPlayer);
	void GenericPlayerInitialization(class AController* C);
	void ReplicateStreamingStatus(class APlayerController* PC);
	class UClass* GetDefaultPlayerClass(class AController* C);
	class APawn* SpawnDefaultPawnFor(class AController* NewPlayer, class AActor* StartSpot);
	void InitiatePlayerPawnDataLoad(class AController* NewPlayer);
	void eventRestartPlayer(class AController* NewPlayer);
	void StartBots();
	void StartHumans();
	void OnStartOnlineGameComplete(const struct FName& SessionName, EOnlineSubsystemResult Result);
	void StartOnlineGame();
	class APlayerController* eventLogin(const class FString& Portal, const class FString& Options, const struct FUniqueNetId& UniqueId, class FString& ErrorMessage);
	class APlayerController* SpawnPlayerController(const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
	int32_t GetNextPlayerID();
	bool AtCapacity(bool bSpectator);
	void eventPreLogin(const class FString& Options, const class FString& Address, const struct FUniqueNetId& UniqueId, class FString& ErrorMessage);
	bool RequiresPassword();
	class APlayerController* ProcessClientTravel(const struct FGuid& NextMapGuid, bool bSeamless, bool bAbsolute, class FString& URL);
	void ProcessServerTravel(const class FString& URL, bool optionalBAbsolute);
	void eventNotifyPendingConnectionLost();
	void eventInitGame(const class FString& Options, class FString& ErrorMessage);
	static class UClass* eventSetGameType(const class FString& MapName, const class FString& Options, const class FString& Portal);
	static class FString eventGetDefaultGameClassPath(const class FString& MapName, const class FString& Options, const class FString& Portal);
	void SetGameSpeed(float T);
	int32_t GetNumPlayers();
	void InitGameReplicationInfo();
	void eventForceKickPlayer(class APlayerController* PC, const class FString& KickReason);
	void eventKickIdler(class APlayerController* PC);
	void eventGameEnding();
	void NotifyNavigationChanged(class ANavigationPoint* N);
	void eventTimer();
	void ResetLevel();
	bool ShouldReset(class AActor* ActorToReset);
	void Reset();
	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	void eventPostBeginPlay();
	void eventPreBeginPlay();
	bool GetMapCommonPackageName(class FString& InFilename, class FString& OutCommonPackageName);
	bool GetSupportedGameTypes(bool optionalBCheckExt, class FString& InFilename, struct FGameTypePrefix& OutGameType);
	bool IsPlayersOnly();
};

// Class Engine.HeightFog
// 0x0010 (0x0240 - 0x0250)
class AHeightFog : public AInfo
{
public:
	class UHeightFogComponent*                         Component;                                     // 0x0240 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	uint32_t                                           bEnabled : 1;                                  // 0x0248 (0x0004) [0x0000000100000020] [0x00000001] (CPF_Net)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.HeightFog");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* Action);
	void eventReplicatedEvent(const struct FName& VarName);
	void eventPostBeginPlay();
};

// Class Engine.MarkerPoint
// 0x0000 (0x0240 - 0x0240)
class AMarkerPoint : public AInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MarkerPoint");
		}

		return uClassPointer;
	};

};

// Class Engine.PotentialClimbWatcher
// 0x0000 (0x0240 - 0x0240)
class APotentialClimbWatcher : public AInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PotentialClimbWatcher");
		}

		return uClassPointer;
	};

	void eventTick(float DeltaTime);
};

// Class Engine.ReplicationInfo
// 0x0000 (0x0240 - 0x0240)
class AReplicationInfo : public AInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ReplicationInfo");
		}

		return uClassPointer;
	};

};

// Class Engine.GameReplicationInfo
// 0x00E0 (0x0240 - 0x0320)
class AGameReplicationInfo : public AReplicationInfo
{
public:
	struct FPointer                                    VfTable_IIResourcePoolProvider;                // 0x0240 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class UClass*                                      GameClass;                                     // 0x0248 (0x0008) [0x0000000100000020] (CPF_Net)     
	float                                              GameDifficulty;                                // 0x0250 (0x0004) [0x4000000000000020] (CPF_Net)     
	struct FReplicatedTimeData                         RemainingTime;                                 // 0x0254 (0x0010) [0x0000000100000020] (CPF_Net)     
	struct FReplicatedTimeData                         ElapsedTime;                                   // 0x0264 (0x0010) [0x0000000100000020] (CPF_Net)     
	int32_t                                            GoalScore;                                     // 0x0274 (0x0004) [0x0000000000000020] (CPF_Net)     
	int32_t                                            TimeLimit;                                     // 0x0278 (0x0004) [0x0000000000000020] (CPF_Net)     
	struct FReplicatedTimeData                         MatchDocumentActiveRemainingTime;              // 0x027C (0x0010) [0x0000000100000020] (CPF_Net)     
	class TArray<class ATeamInfo*>                     Teams;                                         // 0x0290 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      ServerName;                                    // 0x02A0 (0x0010) [0x0000000000444021] (CPF_Edit | CPF_Net | CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class AActor*                                      Winner;                                        // 0x02B0 (0x0008) [0x0000000000000020] (CPF_Net)     
	class TArray<class APlayerReplicationInfo*>        PRIArray;                                      // 0x02B8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class AResourcePoolManager*                        ResourcePoolManager;                           // 0x02C8 (0x0008) [0x0000000000000000]               
	struct FMusicStateInfo                             MusicInfo;                                     // 0x02D0 (0x0018) [0x0000000000002020] (CPF_Net | CPF_Transient)
	uint32_t                                           bAllInCinematicMode : 1;                       // 0x02E8 (0x0004) [0x0000000100002020] [0x00000001] (CPF_Net | CPF_Transient)
	uint32_t                                           bIgnoreMoveInput : 1;                          // 0x02E8 (0x0004) [0x0000000000002020] [0x00000002] (CPF_Net | CPF_Transient)
	uint32_t                                           bIgnoreLookInput : 1;                          // 0x02E8 (0x0004) [0x0000000000002020] [0x00000004] (CPF_Net | CPF_Transient)
	uint32_t                                           bIgnoreButtonInput : 1;                        // 0x02E8 (0x0004) [0x0000000000002020] [0x00000008] (CPF_Net | CPF_Transient)
	uint32_t                                           bServerInCinematicMode : 1;                    // 0x02E8 (0x0004) [0x0000000000002000] [0x00000010] (CPF_Transient)
	uint32_t                                           bReachedNetworkChannelLimit : 1;               // 0x02E8 (0x0004) [0x0000000100002020] [0x00000020] (CPF_Net | CPF_Transient)
	uint32_t                                           bPauseable : 1;                                // 0x02E8 (0x0004) [0x0000000000000000] [0x00000040] 
	class TArray<struct FPauserData>                   Pausers;                                       // 0x02F0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __CanUnpause__Delegate;                        // 0x0300 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnMatchDocumentActiveTimerExpired__Delegate; // 0x0310 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GameReplicationInfo");
		}

		return uClassPointer;
	};

	void OnMatchDocumentActiveTimerExpired();
	void DebugPause();
	void ForceClearUnpauseDelegates(class AActor* PauseActor);
	void eventClearPause(class APlayerController* PC);
	bool SetPause(class APlayerController* PC, const struct FScriptDelegate& optionalCanUnpauseDelegate);
	bool AllowPausing(class APlayerController* optionalPC);
	bool CanUnpauseDefault();
	bool CanUnpause();
	class AActor* GetResourcePoolProviderActor();
	void SetResourcePoolManager(class AResourcePoolManager* InManager);
	class AResourcePoolManager* GetResourcePoolManager();
	struct FResourcePoolReference GetResourcePoolForResourceDefinition(class UResourceDefinition* Resource, bool optionalBCreatePoolIfOneDoesntExist);
	bool eventShouldShowGore();
	bool IsCoopMultiplayerGame();
	bool IsMultiplayerGame();
	void EndGame();
	void StartMatch();
	void SetTeam(int32_t Index, class ATeamInfo* TI);
	void RemovePRI(class APlayerReplicationInfo* PRI);
	void AddPRI(class APlayerReplicationInfo* PRI);
	bool OnSameTeam(class AActor* A, class AActor* B);
	void eventTimer();
	void eventDestroyed();
	void Reset();
	void ReceivedGameClass();
	void eventReplicatedEvent(const struct FName& VarName);
	void eventPostBeginPlay();
};

// Class Engine.PlayerReplicationInfo
// 0x0148 (0x0240 - 0x0388)
class APlayerReplicationInfo : public AReplicationInfo
{
public:
	class APlayerStateInfo*                            PSI;                                           // 0x0240 (0x0008) [0x0000000000002000] (CPF_Transient)
	float                                              Score;                                         // 0x0248 (0x0004) [0x4000000000000000]               
	int32_t                                            Deaths;                                        // 0x024C (0x0004) [0x0000000000000020] (CPF_Net)     
	uint8_t                                            Ping;                                          // 0x0250 (0x0001) [0x0000000000000020] (CPF_Net)     
	EPlayerState                                       CurrentPlayerState;                            // 0x0251 (0x0001) [0x0000000100002020] (CPF_Net | CPF_Transient)
	int32_t                                            NumLives;                                      // 0x0254 (0x0004) [0x0000000000000000]               
	class FString                                      PlayerName;                                    // 0x0258 (0x0010) [0x0000000100400020] (CPF_Net | CPF_NeedCtorLink)
	class FString                                      PlayerNameHTML;                                // 0x0268 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      PlayerNameTruncated;                           // 0x0278 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      PlayerNameTruncatedHTML;                       // 0x0288 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bPlayerNameDirty : 1;                          // 0x0298 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bIsLocalPlayer : 1;                            // 0x0298 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bAdmin : 1;                                    // 0x0298 (0x0004) [0x0000000000000020] [0x00000004] (CPF_Net)
	uint32_t                                           bIsSpectator : 1;                              // 0x0298 (0x0004) [0x0000000000000020] [0x00000008] (CPF_Net)
	uint32_t                                           bOnlySpectator : 1;                            // 0x0298 (0x0004) [0x0000000000000020] [0x00000010] (CPF_Net)
	uint32_t                                           bOutOfLives : 1;                               // 0x0298 (0x0004) [0x0000000000000020] [0x00000020] (CPF_Net)
	uint32_t                                           bBot : 1;                                      // 0x0298 (0x0004) [0x0000000000000020] [0x00000040] (CPF_Net)
	uint32_t                                           bHasBeenWelcomed : 1;                          // 0x0298 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bFromPreviousLevel : 1;                        // 0x0298 (0x0004) [0x0000000000000020] [0x00000100] (CPF_Net)
	uint32_t                                           bPlayerAFK : 1;                                // 0x0298 (0x0004) [0x0000000100002020] [0x00000200] (CPF_Net | CPF_Transient)
	int32_t                                            PlayerID;                                      // 0x029C (0x0004) [0x0000000000000020] (CPF_Net)     
	class ATeamInfo*                                   Team;                                          // 0x02A0 (0x0008) [0x0000000104000020] (CPF_Net | CPF_EditInline)
	class ATeamInfo*                                   OldTeam;                                       // 0x02A8 (0x0008) [0x0000000000002000] (CPF_Transient)
	int32_t                                            StartTime;                                     // 0x02B0 (0x0004) [0x0000000000000020] (CPF_Net)     
	class FString                                      StringSpectating;                              // 0x02B8 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      StringUnknown;                                 // 0x02C8 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	int32_t                                            Kills;                                         // 0x02D8 (0x0004) [0x0000000000000020] (CPF_Net)     
	class UClass*                                      GameMessageClass;                              // 0x02E0 (0x0008) [0x0000000000000000]               
	float                                              ExactPing;                                     // 0x02E8 (0x0004) [0x0000000000000000]               
	class FString                                      SavedNetworkAddress;                           // 0x02F0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FUniqueNetId                                UniqueId;                                      // 0x0300 (0x0014) [0x0000000100000020] (CPF_Net)     
	struct FName                                       SessionName;                                   // 0x0314 (0x0008) [0x0000000000000002] (CPF_Const)   
	struct FAutomatedTestingDatum                      AutomatedTestingData;                          // 0x031C (0x0008) [0x0000000000000000]               
	int32_t                                            StatConnectionCounts;                          // 0x0324 (0x0004) [0x0000000000000000]               
	int32_t                                            StatPingTotals;                                // 0x0328 (0x0004) [0x0000000000000000]               
	int32_t                                            StatPingMin;                                   // 0x032C (0x0004) [0x0000000000000000]               
	int32_t                                            StatPingMax;                                   // 0x0330 (0x0004) [0x0000000000000000]               
	int32_t                                            StatPKLTotal;                                  // 0x0334 (0x0004) [0x0000000000000000]               
	int32_t                                            StatPKLMin;                                    // 0x0338 (0x0004) [0x0000000000000000]               
	int32_t                                            StatPKLMax;                                    // 0x033C (0x0004) [0x0000000000000000]               
	int32_t                                            StatMaxInBPS;                                  // 0x0340 (0x0004) [0x0000000000000000]               
	int32_t                                            StatAvgInBPS;                                  // 0x0344 (0x0004) [0x0000000000000000]               
	int32_t                                            StatMaxOutBPS;                                 // 0x0348 (0x0004) [0x0000000000000000]               
	int32_t                                            StatAvgOutBPS;                                 // 0x034C (0x0004) [0x0000000000000000]               
	class UTexture2D*                                  Avatar;                                        // 0x0350 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FUniqueNetId                                PlayingOnBehalfOfUniqueID;                     // 0x0358 (0x0014) [0x0000000000002000] (CPF_Transient)
	class APlayerReplicationInfo*                      PlayingOnBehalfOfPRI;                          // 0x0370 (0x0008) [0x0000000000002000] (CPF_Transient)
	class APlayerReplicationInfo*                      BeingPlayedOnBehalfByPRI;                      // 0x0378 (0x0008) [0x0000000000002000] (CPF_Transient)
	int32_t                                            PlayerDisplayNameTruncationLength;             // 0x0380 (0x0004) [0x0000000000004000] (CPF_Config)  

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PlayerReplicationInfo");
		}

		return uClassPointer;
	};

	void OnRep_CurrentPlayerState(EPlayerState OldPlayerState);
	void ServerAdvanceCurrentPlayerState(EPlayerState NewPlayerState);
	bool IsNPC();
	void OnRep_Team(class ATeamInfo* PreviousTeam);
	void SetPlayerAFK(bool bAFK);
	void HandlePlayerJoinWithValidName();
	void UnregisterPlayerFromSession();
	void RegisterPlayerWithSession();
	bool eventIsInvalidName();
	uint8_t GetTeamNum();
	void SetUniqueId(const struct FUniqueNetId& PlayerUniqueId);
	void SeamlessTravelTo(class APlayerReplicationInfo* NewPRI);
	void eventIncrementDeaths(int32_t optionalAmt);
	void CopyProperties(class APlayerReplicationInfo* PRI);
	void OverrideWith(class APlayerReplicationInfo* PRI);
	class APlayerReplicationInfo* Duplicate();
	void eventSetPlayerName(const class FString& S);
	void DisplayDebug(class AHUD* HUD, float& YL, float& YPos);
	void Reset();
	void eventDestroyed();
	bool ShouldBroadCastWelcomeMessage(bool optionalBExiting);
	void UpdatePing(float TimeStamp);
	void eventReplicatedEvent(const struct FName& VarName);
	void SetPlayerTeam(class ATeamInfo* NewTeam);
	void ClientInitialize(class AController* C);
	void eventPostBeginPlay();
};

// Class Engine.ResourcePoolManager
// 0x0458 (0x0240 - 0x0698)
class AResourcePoolManager : public AReplicationInfo
{
public:
	class UResourcePool*                               ResourcePools[0x10];                           // 0x0240 (0x0080) [0x0000000000000000]               
	uint8_t                                           UnknownData00[0x50];                           // 0x02C0 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.ResourcePoolManager.ResourcePoolMap
	uint8_t                                            NextPoolGUID;                                  // 0x0310 (0x0001) [0x0000000000000000]               
	ENetRelevantFor                                    NetRelevancy;                                  // 0x0311 (0x0001) [0x0000000000002000] (CPF_Transient)
	struct FResourcePoolIdentityState                  ReplicatedPoolIdentities[0x10];                // 0x0318 (0x0100) [0x0000000100000020] (CPF_Net)     
	struct FResourcePoolValueState                     ReplicatedValueStates[0x10];                   // 0x0418 (0x00C0) [0x0000000100000020] (CPF_Net)     
	float                                              ReplicatedMinValues[0x10];                     // 0x04D8 (0x0040) [0x0000000100000020] (CPF_Net)     
	float                                              ReplicatedMaxValues[0x10];                     // 0x0518 (0x0040) [0x0000000100000020] (CPF_Net)     
	struct FRarelyChangedPoolState                     ReplicatedRarelyChangedState[0x10];            // 0x0558 (0x0140) [0x0000000100000020] (CPF_Net)     

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ResourcePoolManager");
		}

		return uClassPointer;
	};

	void OnRep_ReplicatedRarelyChangedState(int32_t ArrayIndex, const struct FRarelyChangedPoolState& PreviousState);
	void OnRep_ReplicatedMaxValues(int32_t ArrayIndex, float PreviousValue);
	void OnRep_ReplicatedMinValues(int32_t ArrayIndex, float PreviousValue);
	void OnRep_ReplicatedValueStates(int32_t ArrayIndex, const struct FResourcePoolValueState& PreviousState);
	void OnRep_ReplicatedPoolIdentities(int32_t ArrayIndex, const struct FResourcePoolIdentityState& PreviousState);
	static void CreateResourcePoolManagerIfNecessary(class UIResourcePoolProvider* ResourcePoolProvider);
	void DeletePoolAtIndex(int32_t Index);
	class UResourcePool* InternalCreatePoolAtIndex(class UResourcePoolDefinition* PoolDefinition, int32_t Index, uint8_t PoolGUID);
	static class UResourcePool* CreatePoolAtIndex(class UIResourcePoolProvider* ResourcePoolProvider, class UResourcePoolDefinition* PoolDefinition, int32_t Index, uint8_t PoolGUID);
	void GetDebugInfo(class TArray<class FString>& DebugInfo);
	int32_t GetNumberOfPoolsInUse();
	static void RecalculateBaseValues(class UIResourcePoolProvider* ResourcePoolProvider);
	static struct FResourcePoolReference GetResourcePoolForResourceDefinition(class UIResourcePoolProvider* ResourcePoolProvider, class UResourceDefinition* Resource);
	bool HasResourcePoolForResourceDefinition(class UResourceDefinition* Resource);
	static void DeletePoolByReference(struct FResourcePoolReference& PoolReference);
	static void DeletePoolForManager(class AResourcePoolManager* Mgr, const struct FResourcePoolReference& PoolReference);
	static void DeletePool(class UIResourcePoolProvider* ResourcePoolProvider, const struct FResourcePoolReference& PoolReference);
	static void DeleteAllPoolsForManager(class AResourcePoolManager* Mgr);
	static void DeleteAllPools(class UIResourcePoolProvider* ResourcePoolProvider);
	static struct FResourcePoolReference CreatePool(class UIResourcePoolProvider* ResourcePoolProvider, class UResourcePoolDefinition* PoolDefinition, bool optionalBReinitializeExistingPool);
	void eventDestroyed();
	class UResourcePool* GetResourcePool(int32_t Index);
	void ShutDown();
};

// Class Engine.TeamInfo
// 0x0020 (0x0240 - 0x0260)
class ATeamInfo : public AReplicationInfo
{
public:
	class FString                                      TeamName;                                      // 0x0240 (0x0010) [0x0000000000408022] (CPF_Const | CPF_Net | CPF_Localized | CPF_NeedCtorLink)
	int32_t                                            Size;                                          // 0x0250 (0x0004) [0x0000000000000000]               
	float                                              Score;                                         // 0x0254 (0x0004) [0x0000000000000020] (CPF_Net)     
	int32_t                                            TeamIndex;                                     // 0x0258 (0x0004) [0x0000000100000020] (CPF_Net)     
	struct FColor                                      TeamColor;                                     // 0x025C (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TeamInfo");
		}

		return uClassPointer;
	};

	uint8_t GetTeamNum();
	void RemoveFromTeam(class AController* Other);
	bool AddToTeam(class AController* Other);
	void eventDestroyed();
	void eventReplicatedEvent(const struct FName& VarName);
};

// Class Engine.Terrain
// 0x0110 (0x0240 - 0x0350)
class ATerrain : public AInfo
{
public:
	class TArray<struct FTerrainHeight>                Heights;                                       // 0x0240 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<struct FTerrainInfoData>              InfoData;                                      // 0x0250 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<struct FTerrainLayer>                 Layers;                                        // 0x0260 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	int32_t                                            NormalMapLayer;                                // 0x0270 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FTerrainDecoLayer>             DecoLayers;                                    // 0x0278 (0x0010) [0x0000000000480003] (CPF_Edit | CPF_Const | CPF_Component | CPF_NeedCtorLink)
	class TArray<struct FAlphaMap>                     AlphaMaps;                                     // 0x0288 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<class UTerrainComponent*>             TerrainComponents;                             // 0x0298 (0x0010) [0x000000040448000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	int32_t                                            NumSectionsX;                                  // 0x02A8 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            NumSectionsY;                                  // 0x02AC (0x0004) [0x0000000000000002] (CPF_Const)   
	class TArray<struct ATerrain_FTerrainWeightedMaterial> WeightedMaterials;                             // 0x02B0 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<class UTerrainWeightMapTexture*>      WeightedTextureMaps;                           // 0x02C0 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	int32_t                                            MaxTesselationLevel;                           // 0x02D0 (0x0004) [0x0000000000000000]               
	uint8_t                                            WeightmapQuadAlphaThreshold;                   // 0x02D4 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                            WeightmapTexelAlphaThreshold;                  // 0x02D5 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                            WeightmapQuadMaxLayers;                        // 0x02D6 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                            WeightmapTexelMaxLayers;                       // 0x02D7 (0x0001) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            WeightmapTesselationLevel;                     // 0x02D8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            PreviousWeightmapTesselationLevel;             // 0x02DC (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FCachedTerrainMaterialArray                 CachedTerrainMaterials;                        // 0x02E0 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class UMaterial*                                   TerrainMaterialGBX;                            // 0x02F0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    TerrainMaterialResourceGBX;                    // 0x02F8 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	int32_t                                            NumPatchesX;                                   // 0x0300 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            PreviousNumPatchesX;                           // 0x0304 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            NumPatchesY;                                   // 0x0308 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            PreviousNumPatchesY;                           // 0x030C (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            MaxComponentSize;                              // 0x0310 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            StaticLightingResolution;                      // 0x0314 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bIsOverridingLightResolution : 1;              // 0x0318 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bBilinearFilterLightmapGeneration : 1;         // 0x0318 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bCastShadow : 1;                               // 0x0318 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bForceDirectLightMap : 1;                      // 0x0318 (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           bCastDynamicShadow : 1;                        // 0x0318 (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableSpecular : 1;                           // 0x0318 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bBlockRigidBody : 1;                           // 0x0318 (0x0004) [0x0000000000000002] [0x00000040] (CPF_Const)
	uint32_t                                           bAllowRigidBodyUnderneath : 1;                 // 0x0318 (0x0004) [0x0000000000000003] [0x00000080] (CPF_Edit | CPF_Const)
	uint32_t                                           bAcceptsDynamicLights : 1;                     // 0x0318 (0x0004) [0x0000000000000003] [0x00000100] (CPF_Edit | CPF_Const)
	uint32_t                                           bLocked : 1;                                   // 0x0318 (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bHeightmapLocked : 1;                          // 0x0318 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bUseWorldOriginTextureUVs : 1;                 // 0x0318 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bAllowDuplication : 1;                         // 0x0318 (0x0004) [0x0000000000000001] [0x00001000] (CPF_Edit)
	uint32_t                                           bBlockUnreal : 1;                              // 0x0318 (0x0004) [0x0000000000000001] [0x00002000] (CPF_Edit)
	uint32_t                                           bRegenerateTerrainMaterialResources : 1;       // 0x0318 (0x0004) [0x0000000000202000] [0x00004000] (CPF_Transient)
	uint32_t                                           bIsClearingComponents : 1;                     // 0x0318 (0x0004) [0x0000000000002000] [0x00008000] (CPF_Transient)
	class UPhysicalMaterial*                           TerrainPhysMaterialOverride;                   // 0x0320 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FLightingChannelContainer                   LightingChannels;                              // 0x0328 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FPointer                                    ReleaseResourcesFence;                         // 0x0330 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	float                                              MaxDrawDistance;                               // 0x0338 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FSelectedTerrainVertex>        SelectedVertices;                              // 0x0340 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Terrain");
		}

		return uClassPointer;
	};

	void eventPostBeginPlay();
};

// Class Engine.VolumeTimer
// 0x0008 (0x0240 - 0x0248)
class AVolumeTimer : public AInfo
{
public:
	class APhysicsVolume*                              V;                                             // 0x0240 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.VolumeTimer");
		}

		return uClassPointer;
	};

	void eventTimer();
	void eventPostBeginPlay();
};

// Class Engine.WorldSoundManager
// 0x0020 (0x0240 - 0x0260)
class AWorldSoundManager : public AInfo
{
public:
	class TArray<struct FWorldEventSource>             EventSources;                                  // 0x0240 (0x0010) [0x0000000000482000] (CPF_Transient | CPF_Component | CPF_NeedCtorLink)
	class UAkComponent*                                UIAkComponent;                                 // 0x0250 (0x0008) [0x0000000004082008] (CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	uint32_t                                           bHasTicked : 1;                                // 0x0258 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WorldSoundManager");
		}

		return uClassPointer;
	};

	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	int32_t GetWorldSoundCount();
};

// Class Engine.ZoneInfo
// 0x0018 (0x0240 - 0x0258)
class AZoneInfo : public AInfo
{
public:
	float                                              KillZ;                                         // 0x0240 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SoftKill;                                      // 0x0244 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UClass*                                      KillZDamageType;                               // 0x0248 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bSoftKillZ : 1;                                // 0x0250 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ZoneInfo");
		}

		return uClassPointer;
	};

};

// Class Engine.WorldInfo
// 0x0650 (0x0258 - 0x08A8)
class AWorldInfo : public AZoneInfo
{
public:
	struct FPostProcessSettings                        DefaultPostProcessSettings;                    // 0x0258 (0x0118) [0x0000000000404001] (CPF_Edit | CPF_Config | CPF_NeedCtorLink)
	class UPostProcessChain*                           WorldPostProcessChain;                         // 0x0370 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UTextureCube*                                WorldEnvMap;                                   // 0x0378 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bPersistPostProcessToNextLevel : 1;            // 0x0380 (0x0004) [0x0000000000004001] [0x00000001] (CPF_Edit | CPF_Config)
	uint32_t                                           bMapNeedsLightingFullyRebuilt : 1;             // 0x0380 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bMapHasPathingErrors : 1;                      // 0x0380 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bRequestedBlockOnAsyncLoading : 1;             // 0x0380 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bBegunPlay : 1;                                // 0x0380 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bPlayersOnly : 1;                              // 0x0380 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bPlayersOnlyPending : 1;                       // 0x0380 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bSuspendAI : 1;                                // 0x0380 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bStatusMenuOnly : 1;                           // 0x0380 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bAggressiveLOD : 1;                            // 0x0380 (0x0004) [0x0000000000002000] [0x00000200] (CPF_Transient)
	uint32_t                                           bDontTickMind : 1;                             // 0x0380 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bStartup : 1;                                  // 0x0380 (0x0004) [0x0000000000000000] [0x00000800] 
	uint32_t                                           bPathsRebuilt : 1;                             // 0x0380 (0x0004) [0x0000000000000000] [0x00001000] 
	uint32_t                                           bHasPathNodes : 1;                             // 0x0380 (0x0004) [0x0000000000000000] [0x00002000] 
	uint32_t                                           bIsMenuLevel : 1;                              // 0x0380 (0x0004) [0x0000000000002002] [0x00004000] (CPF_Const | CPF_Transient)
	uint32_t                                           bServerHelixSlomoActive : 1;                   // 0x0380 (0x0004) [0x0000000000002000] [0x00008000] (CPF_Transient)
	uint32_t                                           bDebugPauseExecution : 1;                      // 0x0380 (0x0004) [0x0000000800002002] [0x00010000] (CPF_Const | CPF_Transient)
	uint32_t                                           bDebugStepExecution : 1;                       // 0x0380 (0x0004) [0x0000000800002002] [0x00020000] (CPF_Const | CPF_Transient)
	uint32_t                                           bUseConsoleInput : 1;                          // 0x0380 (0x0004) [0x0000000000002000] [0x00040000] (CPF_Transient)
	uint32_t                                           bNoDefaultInventoryForPlayer : 1;              // 0x0380 (0x0004) [0x0000000000000001] [0x00080000] (CPF_Edit)
	uint32_t                                           bClientDestroyedActorsSet : 1;                 // 0x0380 (0x0004) [0x0000000000020002] [0x00100000] (CPF_Const | CPF_EditConst)
	uint32_t                                           bNoPathWarnings : 1;                           // 0x0380 (0x0004) [0x0000000000000001] [0x00200000] (CPF_Edit)
	uint32_t                                           bHighPriorityLoading : 1;                      // 0x0380 (0x0004) [0x0000000000000020] [0x00400000] (CPF_Net)
	uint32_t                                           bHighPriorityLoadingLocal : 1;                 // 0x0380 (0x0004) [0x0000000000000000] [0x00800000] 
	uint32_t                                           bSupportDoubleBufferedPhysics : 1;             // 0x0380 (0x0004) [0x0000000000000001] [0x01000000] (CPF_Edit)
	uint32_t                                           bPhysicsIgnoreDeltaTime : 1;                   // 0x0380 (0x0004) [0x0000000000000001] [0x02000000] (CPF_Edit)
	uint32_t                                           bEnableChanceOfPhysicsChunkOverride : 1;       // 0x0380 (0x0004) [0x0000000000004001] [0x04000000] (CPF_Edit | CPF_Config)
	uint32_t                                           bLimitExplosionChunkSize : 1;                  // 0x0380 (0x0004) [0x0000000000004001] [0x08000000] (CPF_Edit | CPF_Config)
	uint32_t                                           bLimitDamageChunkSize : 1;                     // 0x0380 (0x0004) [0x0000000000004001] [0x10000000] (CPF_Edit | CPF_Config)
	uint32_t                                           bPrecomputeVisibility : 1;                     // 0x0380 (0x0004) [0x0000000000000001] [0x20000000] (CPF_Edit)
	uint32_t                                           bPlaceCellsOnSurfaces : 1;                     // 0x0380 (0x0004) [0x0000000000000000] [0x40000000] 
	uint32_t                                           bRotateMinimapAroundPlayer : 1;                // 0x0380 (0x0004) [0x0000000000000001] [0x80000000] (CPF_Edit)
	uint32_t                                           bForceNoPrecomputedLighting : 1;               // 0x0384 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAssertOnGBXCheck : 1;                         // 0x0384 (0x0004) [0x0000000000004000] [0x00000002] (CPF_Config)
	uint32_t                                           bSupportsTimeOfDay : 1;                        // 0x0384 (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)
	uint32_t                                           bClientSideOnly : 1;                           // 0x0384 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bUpdateInfluence : 1;                          // 0x0384 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bPutAllNavMeshInPersistentLevel : 1;           // 0x0384 (0x0004) [0x0000000800000001] [0x00000020] (CPF_Edit)
	float                                              SquintModeKernelSize;                          // 0x0388 (0x0004) [0x0000000000004001] (CPF_Edit | CPF_Config)
	float                                              ShadowmapStreamingFactorMultiplier;            // 0x038C (0x0004) [0x0000000000004001] (CPF_Edit | CPF_Config)
	class APostProcessVolume*                          HighestPriorityPostProcessVolume;              // 0x0390 (0x0008) [0x0000000001002002] (CPF_Const | CPF_Transient)
	class AWorldSoundManager*                          WorldSoundManager;                             // 0x0398 (0x0008) [0x0000000001002002] (CPF_Const | CPF_Transient)
	class AWorldMusicManager*                          WorldMusicManager;                             // 0x03A0 (0x0008) [0x0000000021002002] (CPF_Const | CPF_Transient | CPF_Deprecated)
	class TArray<class APortalVolume*>                 PortalVolumes;                                 // 0x03A8 (0x0010) [0x0000000001402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<class ULevelStreaming*>               StreamingLevels;                               // 0x03B8 (0x0010) [0x0000000004420003] (CPF_Edit | CPF_Const | CPF_EditConst | CPF_NeedCtorLink | CPF_EditInline)
	struct FDouble                                     LastTimeUnbuiltLightingWasEncountered;         // 0x03C8 (0x0008) [0x0000000000002000] (CPF_Transient)
	class UBookMark*                                   BookMarks[0xA];                                // 0x03D0 (0x0050) [0x0000000000000001] (CPF_Edit)    
	struct FDouble                                     HiPrecision_TimeSeconds;                       // 0x0420 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FDouble                                     HiPrecision_RealTimeSeconds;                   // 0x0428 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FDouble                                     HiPrecision_AudioTimeSeconds;                  // 0x0430 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FDouble                                     HiPrecision_DeltaSeconds;                      // 0x0438 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FDouble                                     HiPrecision_PauseDelay;                        // 0x0440 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FDouble                                     HiPrecision_RealTimeToUnPause;                 // 0x0448 (0x0008) [0x0000000000002000] (CPF_Transient)
	float                                              TimeDilation;                                  // 0x0450 (0x0004) [0x0000000000002020] (CPF_Net | CPF_Transient)
	float                                              DemoPlayTimeDilation;                          // 0x0454 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              TimeSeconds;                                   // 0x0458 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              RealTimeSeconds;                               // 0x045C (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              AudioTimeSeconds;                              // 0x0460 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              DeltaSeconds;                                  // 0x0464 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              LinearLODScale;                                // 0x0468 (0x0004) [0x0000000000002000] (CPF_Transient)
	class APlayerReplicationInfo*                      Pauser;                                        // 0x0470 (0x0008) [0x0000000000000020] (CPF_Net)     
	int32_t                                            ParticleDetailSetting;                         // 0x0478 (0x0004) [0x0000000000002000] (CPF_Transient)
	class UTexture2D*                                  DefaultTexture;                                // 0x0480 (0x0008) [0x0000000000000000]               
	class UTexture2D*                                  WireframeTexture;                              // 0x0488 (0x0008) [0x0000000000000000]               
	class UTexture2D*                                  WhiteSquareTexture;                            // 0x0490 (0x0008) [0x0000000000000000]               
	class UTexture2D*                                  LargeVertex;                                   // 0x0498 (0x0008) [0x0000000000000000]               
	class UTexture2D*                                  BSPVertex;                                     // 0x04A0 (0x0008) [0x0000000000000000]               
	class TArray<class FString>                        DeferredExecs;                                 // 0x04A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class AGameReplicationInfo*                        GRI;                                           // 0x04B8 (0x0008) [0x0000000000002000] (CPF_Transient)
	ENetMode                                           NetMode;                                       // 0x04C0 (0x0001) [0x0000000000000000]               
	ETravelType                                        NextTravelType;                                // 0x04C1 (0x0001) [0x0000000000000000]               
	EVisibilityAggressiveness                          VisibilityAggressiveness;                      // 0x04C2 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ELightingBuildQuality                              LevelLightingQuality;                          // 0x04C3 (0x0001) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	class FString                                      ComputerName;                                  // 0x04C8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      EngineVersion;                                 // 0x04D8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      MinNetVersion;                                 // 0x04E8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class AGameInfo*                                   Game;                                          // 0x04F8 (0x0008) [0x0000000000000000]               
	float                                              StallZ;                                        // 0x0500 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WorldGravityZ;                                 // 0x0504 (0x0004) [0x0000000000002020] (CPF_Net | CPF_Transient)
	float                                              DefaultGravityZ;                               // 0x0508 (0x0004) [0x0000000000044002] (CPF_Const | CPF_Config | CPF_GlobalConfig)
	float                                              GlobalGravityZ;                                // 0x050C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RBPhysicsGravityScaling;                       // 0x0510 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	class ANavigationPoint*                            NavigationPointList;                           // 0x0518 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class AController*                                 ControllerList;                                // 0x0520 (0x0008) [0x0000000000000002] (CPF_Const)   
	class APawn*                                       PawnList;                                      // 0x0528 (0x0008) [0x0000000000000002] (CPF_Const)   
	class ACoverLink*                                  CoverList;                                     // 0x0530 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class AGBXNavMesh*                                 NavMeshList;                                   // 0x0538 (0x0008) [0x0000000000002000] (CPF_Transient)
	class AGBXInfluenceMap*                            InfluenceMapList;                              // 0x0540 (0x0008) [0x0000000000002000] (CPF_Transient)
	class UGearboxCollisionGrid*                       CollisionGrid;                                 // 0x0548 (0x0008) [0x0000000000000000]               
	float                                              MoveRepSize;                                   // 0x0550 (0x0004) [0x0000000000000000]               
	class TArray<struct FNetViewer>                    ReplicationViewers;                            // 0x0558 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class FString                                      NextURL;                                       // 0x0568 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              NextSwitchCountdown;                           // 0x0578 (0x0004) [0x0000000000000000]               
	int32_t                                            PackedLightAndShadowMapTextureSize;            // 0x057C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     DefaultColorScale;                             // 0x0580 (0x000C) [0x0000000000000001] (CPF_Edit)    
	class UClass*                                      DefaultGameType;                               // 0x0590 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class TArray<class UClass*>                        GameTypesSupportedOnThisMap;                   // 0x0598 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UObject*>                       ClientDestroyedActorContent;                   // 0x05A8 (0x0010) [0x0000000000420002] (CPF_Const | CPF_EditConst | CPF_NeedCtorLink)
	class TArray<class AActor*>                        ClientDestroyedActors;                         // 0x05B8 (0x0010) [0x0000000000420002] (CPF_Const | CPF_EditConst | CPF_NeedCtorLink)
	class TArray<struct FName>                         PreparingLevelNames;                           // 0x05C8 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class ULevel*                                      CommittedPersistentLevel;                      // 0x05D8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class UObjectReferencer*                           PersistentMapForcedObjects;                    // 0x05E0 (0x0008) [0x0000000000000000]               
	class FString                                      Author;                                        // 0x05E8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class UMapInfo*                                    MyMapInfo;                                     // 0x05F8 (0x0008) [0x0000000004400009] (CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class FString                                      EmitterPoolClassPath;                          // 0x0600 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class AEmitterPool*                                MyEmitterPool;                                 // 0x0610 (0x0008) [0x0000000000002000] (CPF_Transient)
	class FString                                      DecalManagerClassPath;                         // 0x0618 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class ADecalManager*                               MyDecalManager;                                // 0x0628 (0x0008) [0x0000000000002000] (CPF_Transient)
	class FString                                      EffectNetworkManagerClassPath;                 // 0x0630 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class AEffectNetworkManager*                       MyEffectNetworkManager;                        // 0x0640 (0x0008) [0x0000000000002000] (CPF_Transient)
	class FString                                      ParticleEventManagerClassPath;                 // 0x0648 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class AParticleEventManager*                       MyParticleEventManager;                        // 0x0658 (0x0008) [0x0000000000002000] (CPF_Transient)
	class ARealTimeShatterMgr*                         RealTimeShatterMgr;                            // 0x0660 (0x0008) [0x0000000000002000] (CPF_Transient)
	class FString                                      ParentLoader;                                  // 0x0668 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              MaxPhysicsDeltaTime;                           // 0x0678 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MaxPhysicsSubsteps;                            // 0x067C (0x0004) [0x0000000000004000] (CPF_Config)  
	struct FPhysXSceneProperties                       PhysicsProperties;                             // 0x0680 (0x003C) [0x0000000004000001] (CPF_Edit | CPF_EditInline)
	class TArray<struct FCompartmentRunList>           CompartmentRunFrames;                          // 0x06C0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              DefaultSkinWidth;                              // 0x06D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ApexLODResourceBudget;                         // 0x06D4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ApexDestructionLODResourceValue;               // 0x06D8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ApexClothingLODResourceValue;                  // 0x06DC (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FApexModuleDestructibleSettings             DestructibleSettings;                          // 0x06E0 (0x0014) [0x0000000000000001] (CPF_Edit)    
	class UPhysicsLODVerticalEmitter*                  EmitterVertical;                               // 0x06F8 (0x0008) [0x0000000000000000]               
	struct FPhysXVerticalProperties                    VerticalProperties;                            // 0x0700 (0x0018) [0x0000000004000001] (CPF_Edit | CPF_EditInline)
	float                                              ChanceOfPhysicsChunkOverride;                  // 0x0718 (0x0004) [0x0000000000004001] (CPF_Edit | CPF_Config)
	float                                              MaxExplosionChunkSize;                         // 0x071C (0x0004) [0x0000000000004001] (CPF_Edit | CPF_Config)
	float                                              MaxDamageChunkSize;                            // 0x0720 (0x0004) [0x0000000000004001] (CPF_Edit | CPF_Config)
	float                                              FractureExplosionVelScale;                     // 0x0724 (0x0004) [0x0000000000004001] (CPF_Edit | CPF_Config)
	int32_t                                            MaxNumFacturedChunksToSpawnInAFrame;           // 0x0728 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            NumFacturedChunksSpawnedThisFrame;             // 0x072C (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              FracturedMeshWeaponDamage;                     // 0x0730 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            VisibilityCellSize;                            // 0x0734 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CharacterLitIndirectBrightness;                // 0x0738 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CharacterLitIndirectContrastFactor;            // 0x073C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CharacterShadowedIndirectBrightness;           // 0x0740 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CharacterShadowedIndirectContrastFactor;       // 0x0744 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CharacterLightingContrastFactor;               // 0x0748 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DefaultMinimapIconScale;                       // 0x074C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ExpandedMinimapIconScale;                      // 0x0750 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MinimapScale;                                  // 0x0754 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FMap_Mirror                                 ScreenMessages;                                // 0x0758 (0x0050) [0x0000000000003000] (CPF_Native | CPF_Transient)
	class TArray<struct FScreenMessageString>          PriorityScreenMessages;                        // 0x07A8 (0x0010) [0x0000000000003000] (CPF_Native | CPF_Transient)
	struct FLightmassWorldInfoSettings                 LightmassSettings;                             // 0x07B8 (0x0048) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FNavigationArea>               NavigationAreas;                               // 0x0800 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class AHoldingAreaDestination*                     HoldingCell;                                   // 0x0810 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class ATeleporterDestination*                      PersonalTeleporterDestination;                 // 0x0818 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class AActor*                                      PersonalReturnTeleporterLocation;              // 0x0820 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       CommonsLevelName;                              // 0x0828 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       TeleporterPlacedEventName;                     // 0x0830 (0x0008) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            GBXCheckDisplayDuration;                       // 0x0838 (0x0004) [0x0000000000004000] (CPF_Config)  
	class TArray<class UTextureMovie*>                 TextureMovies;                                 // 0x0840 (0x0010) [0x0000000000003000] (CPF_Native | CPF_Transient)
	float                                              InfluenceSize;                                 // 0x0850 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              InfluenceGameViewDistance;                     // 0x0854 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              InfluenceEditorViewDistance;                   // 0x0858 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FArray_Mirror                               RegisteredAudioOcclusionZones;                 // 0x0860 (0x0010) [0x0000000000003000] (CPF_Native | CPF_Transient)
	struct FArray_Mirror                               RegisteredSpecialAudioOcclusionZones;          // 0x0870 (0x0010) [0x0000000000003000] (CPF_Native | CPF_Transient)
	struct FArray_Mirror                               RegisteredEnvironmentalEffectProviders;        // 0x0880 (0x0010) [0x0000000000003000] (CPF_Native | CPF_Transient)
	class TArray<class UObject*>                       StaticSublevelAssetList;                       // 0x0890 (0x0010) [0x0000000000420002] (CPF_Const | CPF_EditConst | CPF_NeedCtorLink)
	class UAkBank*                                     PersistentLevelAkBank;                         // 0x08A0 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WorldInfo");
		}

		return uClassPointer;
	};

	void ClearInfluenceMaps();
	bool AreAllStreamingMapsLoaded();
	class ULevel* GetStreamingPersistentMap();
	class AWorldInfo* GetStreamingPersistentWorldInfo();
	struct FName GetStreamingPersistentMapName();
	struct FColor GetAreaColor(const struct FName& AreaName);
	bool IsPreview();
	void ClearObjectPools();
	static class AWorldInfo* GetWorldInfo();
	struct FWorldFractureSettings GetWorldFractureSettings();
	void DoMemoryTracking();
	bool GetDemoRewindPoints(class TArray<int32_t>& OutRewindPoints);
	void GetDemoFrameInfo(int32_t& CurrentFrame, int32_t& TotalFrames);
	bool IsPlayingDemo();
	bool IsRecordingDemo();
	EDetailMode GetDetailMode();
	class FString GetMapName(bool optionalBIncludePrefix);
	void SetMapInfo(class UMapInfo* NewMapInfo);
	class UMapInfo* GetMapInfo();
	void SetSeamlessTravelMidpointPause(bool bNowPaused);
	bool IsInSeamlessTravel();
	void SeamlessTravel(const class FString& URL, bool optionalBAbsolute, const struct FGuid& optionalMapPackageGuid);
	void CommitMapChange();
	void CancelPendingMapChange();
	bool IsMapChangeReady();
	bool IsPreparingMapChange();
	void PrepareMapChange(class TArray<struct FName>& LevelNames);
	void NotifyMatchStarted(bool optionalBShouldActivateLevelStartupEvents, bool optionalBShouldActivateLevelBeginningEvents, bool optionalBShouldActivateLevelLoadedEvents);
	void NotifyNavMeshRemoved(class AGBXNavMesh* NavMeshRemoved);
	void NotifyNavMeshAdded(class AGBXNavMesh* NavMeshAdded);
	bool RemoveNavMeshFromList(class AGBXNavMesh* NavMeshToRemove);
	bool AddNavMeshToList(class AGBXNavMesh* NavMeshToAdd);
	void Reset();
	void PostBeginPlay();
	void PreBeginPlay();
	void ThisIsNeverExecuted(class ADefaultPhysicsVolume* P);
	void eventServerTravel(const class FString& URL, bool optionalBAbsolute, bool optionalBShouldSkipGameNotify);
	class UClass* GetGameClass();
	class FString GetAddressURL();
	void VerifyNavList();
	void ForceGarbageCollection(bool optionalBFullPurge);
	static bool IsPlayInEditor();
	static bool IsDemoBuild();
	class FString GetLocalURL();
	void SetLevelRBGravity(const struct FVector& NewGrav);
	class TArray<class USequence*> GetAllRootSequences();
	class USequence* GetGameSequence();
	float GetGravityZ();
	static bool IsMenuLevel(const class FString& optionalMapName);
	void AddOnScreenDebugMessage(int32_t Key, float TimeToDisplay, const struct FColor& DisplayColor, const class FString& DebugMessage);
};

// Class Engine.Inventory
// 0x0048 (0x0240 - 0x0288)
class AInventory : public AActor
{
public:
	class AInventory*                                  Inventory;                                     // 0x0240 (0x0008) [0x0000000000000020] (CPF_Net)     
	class AInventoryManager*                           InvManager;                                    // 0x0248 (0x0008) [0x0000000000000020] (CPF_Net)     
	class FString                                      ItemName;                                      // 0x0250 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bDropOnDeath : 1;                              // 0x0260 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bReadied : 1;                                  // 0x0260 (0x0004) [0x0000000100000020] [0x00000002] (CPF_Net)
	uint32_t                                           bDelayedSpawn : 1;                             // 0x0260 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bPredictRespawns : 1;                          // 0x0260 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              RespawnTime;                                   // 0x0264 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxDesireability;                              // 0x0268 (0x0004) [0x0000000000000000]               
	class FString                                      PickupMessage;                                 // 0x0270 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class UClass*                                      MessageClass;                                  // 0x0280 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Inventory");
		}

		return uClassPointer;
	};

	void Unreadied();
	void Readied();
	void Unready();
	void Ready();
	bool eventCanBeUsedBy(class APawn* Other);
	static class FString GetLocalString(int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01);
	void ItemRemovedFromInvManager();
	void ClientGivenTo(class APawn* NewOwner, bool bDoNotActivate);
	void GivenTo(class APawn* thisPawn, bool bReady, bool optionalBDoNotActivate);
	void PlayPickupSound(class APawn* Other, bool bEquipped);
	void AnnouncePickup(class APawn* Other);
	void eventGiveTo(class APawn* Other, bool bReady, bool optionalBPlayPickupSound);
	static float DetourWeight(class APawn* Other, float PathWeight);
	static float BotDesireability(class AActor* PickupHolder, class APawn* P, class AController* C);
	void eventDestroyed();
	void eventReplicatedEvent(const struct FName& VarName);
};

// Class Engine.WillowInventory
// 0x0A88 (0x0288 - 0x0D10)
class AWillowInventory : public AInventory
{
public:
	struct FPointer                                    VfTable_IIBalancedActor;                       // 0x0288 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIAttributeSlotEffectProvider;         // 0x0290 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	int32_t                                            MonetaryValue;                                 // 0x0298 (0x0004) [0x4000000000000021] (CPF_Edit | CPF_Net)
	float                                              MonetaryValueModifierTotal;                    // 0x029C (0x0004) [0x4000000000000000]               
	int32_t                                            Quantity;                                      // 0x02A0 (0x0004) [0x4000000000000021] (CPF_Edit | CPF_Net)
	int32_t                                            RarityLevel;                                   // 0x02A4 (0x0004) [0x4000000000000020] (CPF_Net)     
	int32_t                                            ExpLevel;                                      // 0x02A8 (0x0004) [0x4000000000000000]               
	int32_t                                            GameStage;                                     // 0x02AC (0x0004) [0x4000000000002000] (CPF_Transient)
	int32_t                                            AwesomeLevel;                                  // 0x02B0 (0x0004) [0x4000000000002000] (CPF_Transient)
	class UObject*                                     AdditionalQueryInterfaceSource;                // 0x02B8 (0x0008) [0x0000000000000000]               
	float                                              ClonedForSharing;                              // 0x02C0 (0x0004) [0x4000000000002000] (CPF_Transient)
	int32_t                                            LastCanBeUsedByResult;                         // 0x02C4 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FName                                       ZippyFrame;                                    // 0x02C8 (0x0008) [0x0000000000000000]               
	class FString                                      ItemFrame;                                     // 0x02D0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FName                                       ElementalFrame;                                // 0x02E0 (0x0008) [0x0000000000000000]               
	struct FName                                       SourceDefinitionName;                          // 0x02E8 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FName                                       SourceResponsibleName;                         // 0x02F0 (0x0008) [0x0000000000002000] (CPF_Transient)
	uint8_t                                            ItemLocation;                                  // 0x02F8 (0x0001) [0x0000000000002000] (CPF_Transient)
	EPlayerMark                                        Mark;                                          // 0x02F9 (0x0001) [0x0000000000000020] (CPF_Net)     
	uint32_t                                           bShopsHaveInfiniteQuantity : 1;                // 0x02FC (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)
	uint32_t                                           bOnlyCompareStatsForMatchingAttributes : 1;    // 0x02FC (0x0004) [0x0000000000000002] [0x00000002] (CPF_Const)
	struct FAttributeSlotData                          AttributeSlots[0x13];                          // 0x0300 (0x0980) [0x0000000000000002] (CPF_Const)   
	float                                              ReplicatedAttributeSlotModifierValues[0x13];   // 0x0C80 (0x004C) [0x0000000000000022] (CPF_Const | CPF_Net)
	class UGBXDefinition*                              RuntimeAttributeSlotSkill;                     // 0x0CD0 (0x0008) [0x0000000000000002] (CPF_Const)   
	float                                              TempStatModifier;                              // 0x0CD8 (0x0004) [0x8000000000002000] (CPF_Transient)
	float                                              TempStatModifierBaseValue;                     // 0x0CDC (0x0004) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            TempStatModifierModifierStack;                 // 0x0CE0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FAppliedAttributeEffect>       AppliedAttributeSlotEffects;                   // 0x0CF0 (0x0010) [0x0000000000003000] (CPF_Native | CPF_Transient)
	class TArray<class AActor*>                        ExternalLikenessConsumers;                     // 0x0D00 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WillowInventory");
		}

		return uClassPointer;
	};

	bool TryConsume();
	void Consume();
	bool IsReadied();
	void RemoveExternalLikenessConsumer(class AActor* LikenessActor);
	void AddExternalLikenessConsumer(class AActor* LikenessActor);
	int32_t GetRarityLevel();
	void eventSetMark(EPlayerMark NewMark);
	EPlayerMark eventGetMark();
	void eventLogInventoryDebug();
	void ResetTempStatModifier(float NewBaseValue);
	float GetAttributeSlotModifierValue(const struct FName& SlotName);
	int32_t GetAttributeSlotGrade(const struct FName& SlotName);
	void CloneAttributeSlotData(class AWillowInventory* NewInventory);
	void InitializeAttributeSlotsForNameParts();
	void InitializeAttributeSlots(bool bIncludeNameParts);
	int32_t GetAttributeSlotIndex(const struct FName& SlotName);
	static bool IsFindMissingAttributeSlotPresentationsDebugEnabled();
	static void ToggleFindMissingAttributeSlotPresentationsDebugEnabled();
	class FString eventGetElementalFrame();
	class FString eventGetZippyFrame();
	struct FName eventGetCategoryKey();
	class UMeshComponent* eventClonePrimaryMeshForUI();
	class USkeletalMeshComponent* CloneInventorySkelMeshComponent(class AActor* CloneOwner, class USkeletalMeshComponent* SourceMeshComponent, float SourceMeshScale, class USkeletalMeshComponent* optionalDestMeshComponent);
	void eventCloneAppearance(class AActor* CloneOwner, class USkeletalMeshComponent* ClonedPrimaryMeshComponent, class TArray<class UPrimitiveComponent*>& ClonedComponentsAttachedToPrimaryMesh, class UMaterialInstance*& ClonedMeshMaterial);
	class UMeshComponent* ClonePrimaryMesh();
	void AttachMeshToPickup(class AActor* Pickup);
	class FString GetModelName();
	class UImpactDefinition* GetDroppedImpactDefinition();
	int32_t CompareUIStat(int32_t StatIdx, class AWillowInventory* CompareTo);
	bool CanBeReadiedOnPickup(class APawn* Other);
	bool CanBeUsedBy(class APawn* Other);
	bool IsConsumable();
	bool IsDLCRequirementMet(class APlayerController* Other);
	class FString GetDLCRestrictedMessage(class APlayerController* Other, bool optionalBShort);
	class APlayerController* GetPawnController(class APawn* Other);
	void eventTranslateUseFailure(class APawn* Other, int32_t FailureFlag, class FString& Output);
	class FString GetLastCanBeUsedByResult(class APawn* Other);
	bool eventIsLevelRequirementMet(class AController* C, int32_t& RequiredLevel);
	int32_t GetControllerPlayerExpLevelRequiredToUse(class AController* OtherController);
	int32_t GetPlayerExpLevelRequiredToUse(class APawn* Other);
	class AWillowInventory* CreateClone();
	void GivenTo(class APawn* thisPawn, bool bReady, bool optionalBDoNotActivate);
	bool eventIsItemAutoUsedBy(class APawn* Other);
	int32_t GetInventorySpaceRequirement();
	void ClientSoldTo(bool bSoldAll);
	void SoldTo(class APawn* Buyer, int32_t optionalSellQuantity, bool optionalBReady);
	static class UMeshComponent* eventInitConstructPreview(class UMeshComponent* PreviewComponent, class UWillowInventoryDefinition* InvDef);
	void PlayPickupSound(class APawn* Other, bool bEquipped);
	void AnnouncePickup(class APawn* Other);
	class FString GetTemplateString(int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01);
	void ConsumeItem();
	class FString eventGetInventoryCardString(bool bIncludeManufacturer, bool bIncludeModelName, bool bIncludePrefixTitle);
	class UInventoryCardPresentationDefinition* GetPresentationDefinition();
	bool CanThrow();
	bool CanInventoryBeSoldOrStoredByOwner();
	bool CanInventoryBeDroppedByOwner();
	bool PassesDroppabilityCheck(EPlayerDroppability MaxDroppability);
	static class USkeletalMesh* StaticCreateCompositeMesh(class TArray<class USkeletalMesh*>& PartMeshes);
	void OverrideMonetaryValue(int32_t NewMonetaryValue);
	int32_t ComputeMonetaryValue();
	static int32_t GetCappedCurrencyAmount(ECurrencyType FormOfCurrency, int32_t Amount);
	int32_t GetSellPrice(class APawn* Customer);
	int32_t GetPurchasePrice(class APawn* Customer);
	int32_t GetMonetaryValueInCurrency(ECurrencyType FormOfCurrency);
	int32_t GetMonetaryValue();
	ECurrencyType GetCurrencyTypeInventoryIsValuedIn();
	void ClientInitializeInventoryFromDefinition();
	void eventInitializeInventory(class UBaseBalanceDefinition* InBalanceDef, class UManufacturerDefinition* InManufacturer, int32_t InGradeIndex, class UObject* InAdditionalQueryInterfaceSource);
	int32_t GetUniqueID();
	static int32_t GenerateUniqueID();
	struct FName GetBalancedActorTypeIdentifier();
	void SetExpLevel(int32_t NewExpLevel);
	void SetAwesomeLevel(int32_t NewAwesomeLevel);
	void SetGameStage(int32_t NewGameStage);
	int32_t GetExpLevel();
	int32_t GetAwesomeLevel();
	int32_t GetGameStage();
	void ApplyExternalSlotEffectModifiers(class AController* ContextSource, int32_t MaxSlotsActivated, class UObject* optionalOverrideContextSource, class TArray<struct FAppliedAttributeEffect>& AttributeModifiers);
	void ApplyInternalSlotEffectModifiers(bool bBackupSlotEffectsApplied, int32_t MaxSlotsActivated, class TArray<struct FAppliedAttributeEffect>& AttributeModifiers);
	int32_t GetManufacturerGradeIndex();
	class UWillowInventoryDefinition* GetInventoryDefinition();
	static bool IsLevelRequirementsDebugEnabled();
	static void ToggleLevelRequirementsDebug();
	int32_t GetAttributeSlotIndexByAttributeDef(class UAttributeDefinition* AttributeDef);
	struct FName GetEquippedStat();
	class FString GetSerialNumberString();
};

// Class Engine.Weapon
// 0x01E0 (0x0D10 - 0x0EF0)
class AWeapon : public AWillowInventory
{
public:
	uint8_t                                            CurrentFireMode;                               // 0x0D10 (0x0001) [0x0000000000000000]               
	uint8_t                                            FireKickSeed;                                  // 0x0D11 (0x0001) [0x0000000000002000] (CPF_Transient)
	uint8_t                                            bOffHand;                                      // 0x0D12 (0x0001) [0x4000000000000000]               
	uint8_t                                            NextFlashLocationIdx;                          // 0x0D13 (0x0001) [0x0000000000002000] (CPF_Transient)
	uint8_t                                            FlashCount;                                    // 0x0D14 (0x0001) [0x0000000100000020] (CPF_Net)     
	class TArray<struct FName>                         FiringStatesArray;                             // 0x0D18 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<EWeaponFireType>                      WeaponFireTypes;                               // 0x0D28 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UClass*>                        WeaponProjectiles;                             // 0x0D38 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              FireInterval;                                  // 0x0D48 (0x0004) [0x8000000000002020] (CPF_Net | CPF_Transient)
	float                                              FireIntervalBaseValue;                         // 0x0D4C (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            FireIntervalModifierStack;                     // 0x0D50 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              Spread;                                        // 0x0D60 (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              SpreadBaseValue;                               // 0x0D64 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            SpreadModifierStack;                           // 0x0D68 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              InstantHitDamage;                              // 0x0D78 (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              InstantHitDamageBaseValue;                     // 0x0D7C (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            InstantHitDamageModifierStack;                 // 0x0D80 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              InstantHitMomentum;                            // 0x0D90 (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              InstantHitMomentumBaseValue;                   // 0x0D94 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            InstantHitMomentumModifierStack;               // 0x0D98 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<class UClass*>                        InstantHitDamageTypes;                         // 0x0DA8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UDamageTypeDefinition*>         InstantHitDamageTypeDefinitions;               // 0x0DB8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UImpactDefinition*>             InstantHitImpactDefinitions;                   // 0x0DC8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class UPhysicsResponseDefinition*                  PhysicsResponse;                               // 0x0DD8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              EquipTime;                                     // 0x0DE0 (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              EquipTimeBaseValue;                            // 0x0DE4 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            EquipTimeModifierStack;                        // 0x0DE8 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              PutDownTime;                                   // 0x0DF8 (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              PutDownTimeBaseValue;                          // 0x0DFC (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            PutDownTimeModifierStack;                      // 0x0E00 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	struct FVector                                     FireOffset;                                    // 0x0E10 (0x000C) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bWeaponPutDown : 1;                            // 0x0E1C (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bCanThrow : 1;                                 // 0x0E1C (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bWasOptionalSet : 1;                           // 0x0E1C (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bWasDoNotActivate : 1;                         // 0x0E1C (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bInstantHit : 1;                               // 0x0E1C (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bMeleeWeapon : 1;                              // 0x0E1C (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bIsFiringWeapon : 1;                           // 0x0E1C (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bPreviewFire : 1;                              // 0x0E1C (0x0004) [0x0000000000002000] [0x00000080] (CPF_Transient)
	float                                              WeaponRange;                                   // 0x0E20 (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              WeaponRangeBaseValue;                          // 0x0E24 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            WeaponRangeModifierStack;                      // 0x0E28 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              ClothImpulseRadius;                            // 0x0E38 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ClothImpulseScale;                             // 0x0E3C (0x0004) [0x0000000000000001] (CPF_Edit)    
	class USkeletalMeshComponent*                      FirstPersonMesh;                               // 0x0E40 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              DefaultAnimSpeed;                              // 0x0E48 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Priority;                                      // 0x0E4C (0x0004) [0x0000000000004000] (CPF_Config)  
	class AAIController*                               AIController;                                  // 0x0E50 (0x0008) [0x0000000000000000]               
	class TArray<uint8_t>                              ShouldFireOnRelease;                           // 0x0E58 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              AIRating;                                      // 0x0E68 (0x0004) [0x0000000000000000]               
	float                                              CachedMaxRange;                                // 0x0E6C (0x0004) [0x0000000000000000]               
	struct FQWord                                      FlashLocationFlags;                            // 0x0E70 (0x0008) [0x0000000000002020] (CPF_Net | CPF_Transient)
	struct FVector                                     FlashLocation[0xA];                            // 0x0E78 (0x0078) [0x0000000000000020] (CPF_Net)     

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Weapon");
		}

		return uClassPointer;
	};

	void Unreadied();
	void Readied();
	float GetTargetDistance();
	void CacheAIController();
	void UninitializeAfterPutDown();
	void WeaponIsDown();
	bool StillFiring(uint8_t FireMode);
	bool ShouldRefire();
	void NotifyWeaponFinishedFiring(uint8_t FireMode);
	void NotifyWeaponFired(uint8_t FireMode);
	void HandleFinishedFiring();
	void TryPutDownEx();
	bool TryPutDown();
	struct FVector GetPhysicalFireStartLoc(const struct FVector& optionalAimDir);
	struct FVector eventGetMuzzleLoc();
	void CustomFire();
	class AProjectile* ProjectileFire();
	void eventProcessInstantHit(uint8_t FiringMode, const struct FImpactInfo& Impact, bool optionalBIsPurposefulMiss, int32_t optionalNumHits);
	void InstantFire();
	bool PassThroughDamage(class AActor* HitActor);
	class AActor* GetTraceOwner();
	float eventGetTraceRange();
	struct FRotator GetAdjustedAim(const struct FVector& StartFireLoc);
	void FireAmmunition();
	void SetCurrentFireMode(uint8_t FiringModeNum);
	void SendToFiringState(uint8_t FireModeNum);
	void ServerForceEndFire();
	void ForceEndFire(bool optionalBReplicateToServer);
	void EndFire(uint8_t FireModeNum, bool optionalBInterrupted);
	void ServerStopFire(uint8_t FireModeNum);
	void StopFire(uint8_t FireModeNum, bool optionalBInterrupted);
	void BeginFire(uint8_t FireModeNum);
	void ServerStartFire(uint8_t FireModeNum, const struct FVector& InFireOffset, uint8_t InFireKickSeed);
	void StartFire(uint8_t FireModeNum);
	void ClientWeaponSet(bool bOptionalSet, bool optionalBDoNotActivate);
	void ClientGivenTo(class APawn* NewOwner, bool bDoNotActivate);
	void DetachWeapon();
	void AttachWeaponTo(class USkeletalMeshComponent* MeshCpnt, const struct FName& optionalSocketName);
	void FlashLocationUpdated(const struct FVector& InFlashLocation, bool bViaReplication, int32_t Index);
	void FlashCountUpdated(uint8_t InFlashCount, bool bViaReplication);
	void ClearFlashLocation();
	void SetFlashLocation(const struct FVector& HitLocation, uint8_t optionalFlags);
	void ClearFlashCount();
	void IncrementFlashCount();
	void WeaponEmpty();
	void PutDownWeapon();
	void Activate(bool optionalBEquipInOffHand);
	void TimeWeaponEquipping();
	float GetEquipTime();
	void eventTimeWeaponPutDown();
	float GetPutDownTime();
	void RefireCheckTimer();
	void TimeWeaponFiring(uint8_t FireModeNum);
	float GetFireInterval(uint8_t FireModeNum);
	void StopFireEffects(uint8_t FireModeNum);
	void PlayFireEffects(uint8_t FireModeNum, int32_t optionalFiringSlot);
	void StopWeaponAnimation(float BlendOutTime);
	void PlayWeaponAnimation(const struct FName& Sequence, float fDesiredDuration, bool optionalBLoop, class USkeletalMeshComponent* optionalSkelMesh);
	void WeaponPlayAkEvent(class UAkEvent* Event, bool optionalBReplicate);
	class UAnimNodeSequence* GetWeaponAnimNodeSeq();
	bool FireOnRelease();
	bool CanAttack(class AActor* Other);
	float GetWeaponRating();
	float GetAIRating();
	float MaxRange();
	struct FRotator AddSpread(const struct FRotator& BaseAim);
	class UClass* GetProjectileClass();
	void ClearPendingFire(int32_t FireMode);
	void SetPendingFire(int32_t FireMode);
	bool PendingFire(int32_t FireMode);
	int32_t GetPendingFireLength();
	bool HasAnyAmmo();
	bool HasActiveAmmo(uint8_t FireModeNum, int32_t optionalAmount);
	bool HasAmmo(uint8_t FireModeNum, int32_t optionalAmount);
	int32_t AddAmmo(int32_t Amount);
	void ConsumeAmmo(uint8_t FireModeNum);
	void GetWeaponDebug(class TArray<class FString>& DebugInfo);
	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	bool DenyClientWeaponSet();
	bool eventIsFiring();
	void ClientWeaponThrown();
	bool CanThrow();
	bool DoOverridePrevWeapon();
	bool DoOverrideNextWeapon();
	void HolderDied();
	void ItemRemovedFromInvManager();
	void eventDestroyed();
	bool ForceWeaponToBeEquipped();
	void eventReplicatedEvent(const struct FName& VarName);
};

// Class Engine.InventoryManager
// 0x0048 (0x0240 - 0x0288)
class AInventoryManager : public AActor
{
public:
	class AInventory*                                  InventoryChain;                                // 0x0240 (0x0008) [0x0000000100000020] (CPF_Net)     
	class AWeapon*                                     PendingWeapon;                                 // 0x0248 (0x0008) [0x0000000000000000]               
	class AWeapon*                                     PendingOffHandWeapon;                          // 0x0250 (0x0008) [0x0000000000000000]               
	class AWeapon*                                     LastAttemptedSwitchToWeapon;                   // 0x0258 (0x0008) [0x0000000000000000]               
	uint32_t                                           bMustHoldWeapon : 1;                           // 0x0260 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bInstantWeaponSwitch : 1;                      // 0x0260 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	uint32_t                                           bInstantOffhandWeaponSwitch : 1;               // 0x0260 (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)
	uint32_t                                           bInfiniteAmmo : 1;                             // 0x0260 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bForceOwnedItemsToBeRelevantToAll : 1;         // 0x0260 (0x0004) [0x0000000000000000] [0x00000010] 
	class TArray<int32_t>                              PendingFire;                                   // 0x0268 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<int32_t>                              OffHandPendingFire;                            // 0x0278 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InventoryManager");
		}

		return uClassPointer;
	};

	void ClientConditionalIncrementPickupStats(class AInventory* InvObject);
	void ClearInventoryReferences(class AInventory* TheItem);
	bool ShouldSwitchToBestWeapon();
	void UpdateController();
	void ClientWeaponSet(class AWeapon* NewWeapon, bool bOptionalSet, bool optionalBDoNotActivate);
	void ChangedWeapon(bool bEquipInOffHand);
	void ClearPendingWeapon(bool bOffHand);
	bool CancelWeaponChange();
	void SetPendingWeapon(class AWeapon* DesiredWeapon, bool bEquipInOffHand);
	void InternalSetCurrentWeapon(class AWeapon* DesiredWeapon, bool bEquipInOffHand, bool bInstantSwitch);
	void ServerSetCurrentWeapon(class AWeapon* DesiredWeapon, bool bEquipInOffHand, bool optionalBInstantSwitch);
	void SetCurrentWeapon(class AWeapon* DesiredWeapon, bool bEquipInOffHand, bool optionalBInstantSwitch);
	void NextWeapon();
	void PrevWeapon();
	void SwitchToBestWeapon(bool optionalBForceADifferentWeapon);
	class AWeapon* GetBestWeapon(bool optionalBForceADifferentWeapon);
	float GetWeaponRatingFor(class AWeapon* W);
	void eventDrawHUD(class AHUD* H);
	void OwnerDied();
	void eventDiscardInventory(bool optionalBDestroyContents);
	void InventoryUnreadied(class AInventory* Inv);
	void InventoryReadied(class AInventory* Inv);
	void RemoveFromInventory(class AInventory* ItemToRemove, bool optionalBCanDrop);
	bool AddInventory(class AInventory* NewItem, bool bReady, bool optionalBDoNotActivate, bool optionalBPlayPickupSound);
	class AInventory* CreateInventory(class UClass* NewInventoryItemClass, bool bReady, bool optionalBDoNotActivate);
	class AInventory* eventFindInventoryType(class UClass* DesiredClass, bool optionalBAllowSubclass);
	void eventDestroyed();
	void SetupFor(class APawn* P);
	void ClearAllPendingFire(class AWeapon* InWeapon, bool bOffHand);
	bool IsPendingFire(class AWeapon* InWeapon, int32_t InFiringMode, bool bOffHand);
	void ClearPendingFire(class AWeapon* InWeapon, int32_t InFiringMode, bool bOffHand);
	void SetPendingFire(class AWeapon* InWeapon, int32_t InFiringMode, bool bOffHand);
	int32_t GetPendingFireLength(class AWeapon* InWeapon, bool bOffHand);
	void PostBeginPlay();
	void eventReplicatedEvent(const struct FName& VarName);
};

// Class Engine.KAsset
// 0x0020 (0x0240 - 0x0260)
class AKAsset : public AActor
{
public:
	class USkeletalMeshComponent*                      SkeletalMeshComponent;                         // 0x0240 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	uint32_t                                           bDamageAppliesImpulse : 1;                     // 0x0248 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bWakeOnLevelStart : 1;                         // 0x0248 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bBlockPawns : 1;                               // 0x0248 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	class USkeletalMesh*                               ReplicatedMesh;                                // 0x0250 (0x0008) [0x0000000100002020] (CPF_Net | CPF_Transient)
	class UPhysicsAsset*                               ReplicatedPhysAsset;                           // 0x0258 (0x0008) [0x0000000100002020] (CPF_Net | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.KAsset");
		}

		return uClassPointer;
	};

	void DoKismetAttachment(class AActor* Attachment, class USeqAct_AttachToActor* Action);
	void OnTeleport(class USeqAct_Teleport* inAction);
	void OnToggle(class USeqAct_Toggle* Action);
	void TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class UIDamageCauser* DamageCauser, float optionalDamageFalloffExponent, class UDamagePipeline* optionalPipeline);
	void eventTakeDamage(float Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& HitDirection, class UClass* DamageType, const struct FTraceHitInfo& optionalHitInfo, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline);
	void eventReplicatedEvent(const struct FName& VarName);
	void SetMeshAndPhysAsset(class USkeletalMesh* NewMesh, class UPhysicsAsset* NewPhysAsset);
	void eventPostBeginPlay();
};

// Class Engine.KAssetSpawnable
// 0x0000 (0x0260 - 0x0260)
class AKAssetSpawnable : public AKAsset
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.KAssetSpawnable");
		}

		return uClassPointer;
	};

};

// Class Engine.Keypoint
// 0x0008 (0x0240 - 0x0248)
class AKeypoint : public AActor
{
public:
	class USpriteComponent*                            SpriteComp;                                    // 0x0240 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Keypoint");
		}

		return uClassPointer;
	};

};

// Class Engine.PathTargetPoint
// 0x0000 (0x0248 - 0x0248)
class APathTargetPoint : public AKeypoint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PathTargetPoint");
		}

		return uClassPointer;
	};

};

// Class Engine.TargetPoint
// 0x0008 (0x0248 - 0x0250)
class ATargetPoint : public AKeypoint
{
public:
	int32_t                                            SpawnRefCount;                                 // 0x0248 (0x0004) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TargetPoint");
		}

		return uClassPointer;
	};

};

// Class Engine.LensFlareSource
// 0x0010 (0x0240 - 0x0250)
class ALensFlareSource : public AActor
{
public:
	class ULensFlareComponent*                         LensFlareComp;                                 // 0x0240 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	uint32_t                                           bCurrentlyActive : 1;                          // 0x0248 (0x0004) [0x0000000100000020] [0x00000001] (CPF_Net)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LensFlareSource");
		}

		return uClassPointer;
	};

	void SetActorParameter(const struct FName& ParameterName, class AActor* Param);
	void SetColorParameter(const struct FName& ParameterName, const struct FLinearColor& Param);
	void SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param);
	void SetFloatParameter(const struct FName& ParameterName, float Param);
	void eventReplicatedEvent(const struct FName& VarName);
	void OnToggle(class USeqAct_Toggle* Action);
	void eventPostBeginPlay();
	void SetTemplate(class ULensFlare* NewTemplate);
};

// Class Engine.LevelLandmark
// 0x0020 (0x0240 - 0x0260)
class ALevelLandmark : public AActor
{
public:
	class FString                                      LandmarkName;                                  // 0x0240 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	ELandmarkType                                      LandmarkType;                                  // 0x0250 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AssociatedStationDefinitionName;               // 0x0254 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LevelLandmark");
		}

		return uClassPointer;
	};

};

// Class Engine.PersistentTransitionLandmark
// 0x0030 (0x0260 - 0x0290)
class APersistentTransitionLandmark : public ALevelLandmark
{
public:
	class FString                                      FromMapName;                                   // 0x0260 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class FString                                      ToMapName;                                     // 0x0270 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FName>                         RequiredSublevelNames;                         // 0x0280 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PersistentTransitionLandmark");
		}

		return uClassPointer;
	};

};

// Class Engine.Light
// 0x0010 (0x0240 - 0x0250)
class ALight : public AActor
{
public:
	class ULightComponent*                             LightComponent;                                // 0x0240 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	uint32_t                                           bEnabled : 1;                                  // 0x0248 (0x0004) [0x0000000100000020] [0x00000001] (CPF_Net)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Light");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* Action);
	void eventReplicatedEvent(const struct FName& VarName);
};

// Class Engine.DirectionalLight
// 0x0000 (0x0250 - 0x0250)
class ADirectionalLight : public ALight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DirectionalLight");
		}

		return uClassPointer;
	};

};

// Class Engine.DirectionalLightToggleable
// 0x0000 (0x0250 - 0x0250)
class ADirectionalLightToggleable : public ADirectionalLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DirectionalLightToggleable");
		}

		return uClassPointer;
	};

};

// Class Engine.DominantDirectionalLight
// 0x0000 (0x0250 - 0x0250)
class ADominantDirectionalLight : public ADirectionalLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DominantDirectionalLight");
		}

		return uClassPointer;
	};

};

// Class Engine.DominantDirectionalLightMovable
// 0x0000 (0x0250 - 0x0250)
class ADominantDirectionalLightMovable : public ADominantDirectionalLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DominantDirectionalLightMovable");
		}

		return uClassPointer;
	};

};

// Class Engine.PointLight
// 0x0000 (0x0250 - 0x0250)
class APointLight : public ALight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PointLight");
		}

		return uClassPointer;
	};

};

// Class Engine.DominantPointLight
// 0x0000 (0x0250 - 0x0250)
class ADominantPointLight : public APointLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DominantPointLight");
		}

		return uClassPointer;
	};

};

// Class Engine.PointLightDynamicOnly
// 0x0000 (0x0250 - 0x0250)
class APointLightDynamicOnly : public APointLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PointLightDynamicOnly");
		}

		return uClassPointer;
	};

};

// Class Engine.PointLightMovable
// 0x0000 (0x0250 - 0x0250)
class APointLightMovable : public APointLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PointLightMovable");
		}

		return uClassPointer;
	};

};

// Class Engine.PointLightToggleable
// 0x0000 (0x0250 - 0x0250)
class APointLightToggleable : public APointLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PointLightToggleable");
		}

		return uClassPointer;
	};

	void ApplyCheckpointRecord(struct FPointLightToggleableCheckpointRecord& Record);
	void CreateCheckpointRecord(struct FPointLightToggleableCheckpointRecord& Record);
	bool ShouldSaveForCheckpoint();
};

// Class Engine.SkyLight
// 0x0000 (0x0250 - 0x0250)
class ASkyLight : public ALight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkyLight");
		}

		return uClassPointer;
	};

};

// Class Engine.SkyLightToggleable
// 0x0000 (0x0250 - 0x0250)
class ASkyLightToggleable : public ASkyLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkyLightToggleable");
		}

		return uClassPointer;
	};

};

// Class Engine.SpotLight
// 0x0000 (0x0250 - 0x0250)
class ASpotLight : public ALight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpotLight");
		}

		return uClassPointer;
	};

};

// Class Engine.DominantSpotLight
// 0x0000 (0x0250 - 0x0250)
class ADominantSpotLight : public ASpotLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DominantSpotLight");
		}

		return uClassPointer;
	};

};

// Class Engine.GeneratedMeshAreaLight
// 0x0000 (0x0250 - 0x0250)
class AGeneratedMeshAreaLight : public ASpotLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GeneratedMeshAreaLight");
		}

		return uClassPointer;
	};

};

// Class Engine.SpotLightDynamicOnly
// 0x0000 (0x0250 - 0x0250)
class ASpotLightDynamicOnly : public ASpotLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpotLightDynamicOnly");
		}

		return uClassPointer;
	};

};

// Class Engine.SpotLightMovable
// 0x0000 (0x0250 - 0x0250)
class ASpotLightMovable : public ASpotLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpotLightMovable");
		}

		return uClassPointer;
	};

};

// Class Engine.SpotLightToggleable
// 0x0000 (0x0250 - 0x0250)
class ASpotLightToggleable : public ASpotLight
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpotLightToggleable");
		}

		return uClassPointer;
	};

	void ApplyCheckpointRecord(struct FSpotLightToggleableCheckpointRecord& Record);
	void CreateCheckpointRecord(struct FSpotLightToggleableCheckpointRecord& Record);
	bool ShouldSaveForCheckpoint();
};

// Class Engine.StaticLightCollectionActor
// 0x0018 (0x0250 - 0x0268)
class AStaticLightCollectionActor : public ALight
{
public:
	class TArray<class ULightComponent*>               LightComponents;                               // 0x0250 (0x0010) [0x000000000448000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	int32_t                                            MaxLightComponents;                            // 0x0260 (0x0004) [0x0000000000004000] (CPF_Config)  

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.StaticLightCollectionActor");
		}

		return uClassPointer;
	};

};

// Class Engine.LODManager
// 0x0018 (0x0240 - 0x0258)
class ALODManager : public AActor
{
public:
	class TArray<class ULODObject*>                    LODObjects;                                    // 0x0240 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bEnabled : 1;                                  // 0x0250 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LODManager");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialInstanceActor
// 0x0008 (0x0240 - 0x0248)
class AMaterialInstanceActor : public AActor
{
public:
	class UMaterialInstance*                           MatInst;                                       // 0x0240 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialInstanceActor");
		}

		return uClassPointer;
	};

};

// Class Engine.MatineeActor
// 0x00E8 (0x0240 - 0x0328)
class AMatineeActor : public AActor
{
public:
	class USeqAct_Interp*                              InterpAction;                                  // 0x0240 (0x0008) [0x0000000000000022] (CPF_Const | CPF_Net)
	uint32_t                                           bIsPlaying : 1;                                // 0x0248 (0x0004) [0x0000000000000020] [0x00000001] (CPF_Net)
	uint32_t                                           bReversePlayback : 1;                          // 0x0248 (0x0004) [0x0000000000000020] [0x00000002] (CPF_Net)
	uint32_t                                           bPaused : 1;                                   // 0x0248 (0x0004) [0x0000000000000020] [0x00000004] (CPF_Net)
	uint32_t                                           AllAIGroupsInitialized : 1;                    // 0x0248 (0x0004) [0x0000000000002000] [0x00000008] (CPF_Transient)
	float                                              PlayRate;                                      // 0x024C (0x0004) [0x0000000000000020] (CPF_Net)     
	float                                              Position;                                      // 0x0250 (0x0004) [0x0000000000000020] (CPF_Net)     
	uint8_t                                            PlayId;                                        // 0x0254 (0x0001) [0x0000000000000020] (CPF_Net)     
	struct FName                                       AIGroupNames[0xA];                             // 0x0258 (0x0050) [0x0000000000000020] (CPF_Net)     
	class APawn*                                       AIGroupPawns[0xA];                             // 0x02A8 (0x0050) [0x0000000000000020] (CPF_Net)     
	int32_t                                            AIGroupInitStage[0xA];                         // 0x02F8 (0x0028) [0x0000000000002000] (CPF_Transient)
	float                                              ClientSidePositionErrorTolerance;              // 0x0320 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MatineeActor");
		}

		return uClassPointer;
	};

	void CheckPriorityRefresh();
	void eventUpdate();
	void AddAIGroupActor(class UInterpGroupInstAI* AIGroupInst);
};

// Class Engine.NavigationPoint
// 0x0020 (0x0240 - 0x0260)
class ANavigationPoint : public AActor
{
public:
	class UCylinderComponent*                          CylinderComponent;                             // 0x0240 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	class ANavigationPoint*                            nextNavigationPoint;                           // 0x0248 (0x0008) [0x0000000000000002] (CPF_Const)   
	class APawn*                                       AnchoredPawn;                                  // 0x0250 (0x0008) [0x0000000000002000] (CPF_Transient)
	float                                              LastAnchoredPawnTime;                          // 0x0258 (0x0004) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavigationPoint");
		}

		return uClassPointer;
	};

};

// Class Engine.CoverLink
// 0x0038 (0x0260 - 0x0298)
class ACoverLink : public ANavigationPoint
{
public:
	struct FPointer                                    VfTable_IIGBXNavMeshSpecialMove;               // 0x0260 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class TArray<class UCoverSlotComponent*>           SlotComponents;                                // 0x0268 (0x0010) [0x00000000044A0009] (CPF_Edit | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	uint32_t                                           bDisabled : 1;                                 // 0x0278 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bAutoSort : 1;                                 // 0x0278 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           bAutoAdjust : 1;                               // 0x0278 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           bDisplayAutoAdjustLines : 1;                   // 0x0278 (0x0004) [0x0000000000004003] [0x00000008] (CPF_Edit | CPF_Const | CPF_Config)
	uint32_t                                           bShowCoverLocations : 1;                       // 0x0278 (0x0004) [0x0000000000004003] [0x00000010] (CPF_Edit | CPF_Const | CPF_Config)
	uint32_t                                           bAutoAdjustCoverWhileMoving : 1;               // 0x0278 (0x0004) [0x0000000000004003] [0x00000020] (CPF_Edit | CPF_Const | CPF_Config)
	float                                              AlignDist;                                     // 0x027C (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	float                                              AutoCoverSlotInterval;                         // 0x0280 (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	float                                              StandHeight;                                   // 0x0284 (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	float                                              MidHeight;                                     // 0x0288 (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	class ACoverLink*                                  NextCoverLink;                                 // 0x0290 (0x0008) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CoverLink");
		}

		return uClassPointer;
	};

	int32_t AddCoverSlot(const struct FVector& SlotLocation, const struct FRotator& SlotRotation, int32_t optionalSlotIdx, bool optionalBForceSlotUpdate);
	void OnToggle(class USeqAct_Toggle* inAction);
	bool IsEnabled();
	bool AutoAdjustSlot(int32_t SlotIdx, bool bOnlyCheckLeans);
	void eventSetSlotEnabled(int32_t SlotIdx, bool bEnable);
	void eventSetDisabled(bool bNewDisabled);
	int32_t GetSlotIdxToRight(int32_t SlotIdx, int32_t optionalCnt);
	int32_t GetSlotIdxToLeft(int32_t SlotIdx, int32_t optionalCnt);
	bool IsRightEdgeSlot(int32_t SlotIdx, bool bIgnoreLeans);
	bool IsLeftEdgeSlot(int32_t SlotIdx, bool bIgnoreLeans);
	bool IsEdgeSlot(int32_t SlotIdx, bool optionalBIgnoreLeans);
	struct FRotator GetSlotRotation(int32_t SlotIdx, bool optionalBForceUseOffset);
	struct FVector GetSlotLocation(int32_t SlotIdx, bool optionalBForceUseOffset);
};

// Class Engine.PlayerStart
// 0x0010 (0x0260 - 0x0270)
class APlayerStart : public ANavigationPoint
{
public:
	uint32_t                                           bEnabled : 1;                                  // 0x0260 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bPrimaryStart : 1;                             // 0x0260 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bBestStart : 1;                                // 0x0260 (0x0004) [0x0000000000000000] [0x00000004] 
	int32_t                                            TeamIndex;                                     // 0x0264 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Score;                                         // 0x0268 (0x0004) [0x0000000000000000]               
	int32_t                                            SelectionIndex;                                // 0x026C (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PlayerStart");
		}

		return uClassPointer;
	};

	void eventPostRenderFor(class APlayerController* PC, class UCanvas* Canvas, const struct FVector& CameraPosition, const struct FVector& CameraDir);
	void OnToggle(class USeqAct_Toggle* Action);
};

// Class Engine.Teleporter
// 0x0030 (0x0260 - 0x0290)
class ATeleporter : public ANavigationPoint
{
public:
	class FString                                      URL;                                           // 0x0260 (0x0010) [0x0000000000400021] (CPF_Edit | CPF_Net | CPF_NeedCtorLink)
	struct FName                                       ProductRequired;                               // 0x0270 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bChangesVelocity : 1;                          // 0x0278 (0x0004) [0x0000000000000021] [0x00000001] (CPF_Edit | CPF_Net)
	uint32_t                                           bChangesYaw : 1;                               // 0x0278 (0x0004) [0x0000000000000021] [0x00000002] (CPF_Edit | CPF_Net)
	uint32_t                                           bReversesX : 1;                                // 0x0278 (0x0004) [0x0000000000000021] [0x00000004] (CPF_Edit | CPF_Net)
	uint32_t                                           bReversesY : 1;                                // 0x0278 (0x0004) [0x0000000000000021] [0x00000008] (CPF_Edit | CPF_Net)
	uint32_t                                           bReversesZ : 1;                                // 0x0278 (0x0004) [0x0000000000000021] [0x00000010] (CPF_Edit | CPF_Net)
	uint32_t                                           bEnabled : 1;                                  // 0x0278 (0x0004) [0x0000000000000021] [0x00000020] (CPF_Edit | CPF_Net)
	uint32_t                                           bCanTeleportVehicles : 1;                      // 0x0278 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	struct FVector                                     TargetVelocity;                                // 0x027C (0x000C) [0x0000000000000021] (CPF_Edit | CPF_Net)
	float                                              LastFired;                                     // 0x0288 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Teleporter");
		}

		return uClassPointer;
	};

	class AActor* eventSpecialHandling(class APawn* Other);
	void eventPostTouch(class AActor* Other);
	void eventTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void eventPostBeginPlay();
};

// Class Engine.Note
// 0x0000 (0x0240 - 0x0240)
class ANote : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Note");
		}

		return uClassPointer;
	};

};

// Class Engine.NxForceField
// 0x0058 (0x0240 - 0x0298)
class ANxForceField : public AActor
{
public:
	int32_t                                            ExcludeChannel;                                // 0x0240 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bForceActive : 1;                              // 0x0244 (0x0004) [0x0000000000000021] [0x00000001] (CPF_Edit | CPF_Net)
	struct FRBCollisionChannelContainer                CollideWithChannels;                           // 0x0248 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ERBCollisionChannel                                RBChannel;                                     // 0x024C (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FPointer                                    ForceField;                                    // 0x0250 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      ConvexMeshes;                                  // 0x0258 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      ExclusionShapes;                               // 0x0268 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      ExclusionShapePoses;                           // 0x0278 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    U2NRotation;                                   // 0x0288 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            SceneIndex;                                    // 0x0290 (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxForceField");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* inAction);
	void DoInitRBPhys();
};

// Class Engine.NxCylindricalForceField
// 0x0030 (0x0298 - 0x02C8)
class ANxCylindricalForceField : public ANxForceField
{
public:
	float                                              RadialStrength;                                // 0x0298 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              RotationalStrength;                            // 0x029C (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftStrength;                                  // 0x02A0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceRadius;                                   // 0x02A4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceTopRadius;                                // 0x02A8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftFalloffHeight;                             // 0x02AC (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              EscapeVelocity;                                // 0x02B0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceHeight;                                   // 0x02B4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              HeightOffset;                                  // 0x02B8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	uint32_t                                           UseSpecialRadialForce : 1;                     // 0x02BC (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FPointer                                    Kernel;                                        // 0x02C0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxCylindricalForceField");
		}

		return uClassPointer;
	};

};

// Class Engine.NxCylindricalForceFieldCapsule
// 0x0008 (0x02C8 - 0x02D0)
class ANxCylindricalForceFieldCapsule : public ANxCylindricalForceField
{
public:
	class UDrawCapsuleComponent*                       RenderComponent;                               // 0x02C8 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxCylindricalForceFieldCapsule");
		}

		return uClassPointer;
	};

	void DoInitRBPhys();
};

// Class Engine.NxForceFieldGeneric
// 0x00C0 (0x0298 - 0x0358)
class ANxForceFieldGeneric : public ANxForceField
{
public:
	class UForceFieldShape*                            Shape;                                         // 0x0298 (0x0008) [0x0000000004000001] (CPF_Edit | CPF_EditInline)
	class UActorComponent*                             DrawComponent;                                 // 0x02A0 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              RoughExtentX;                                  // 0x02A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RoughExtentY;                                  // 0x02AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RoughExtentZ;                                  // 0x02B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	EFFG_ForceFieldCoordinates                         Coordinates;                                   // 0x02B4 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Constant;                                      // 0x02B8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierX;                           // 0x02C4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierY;                           // 0x02D0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierZ;                           // 0x02DC (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionTarget;                                // 0x02E8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierX;                           // 0x02F4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierY;                           // 0x0300 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierZ;                           // 0x030C (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityTarget;                                // 0x0318 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Noise;                                         // 0x0324 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     FalloffLinear;                                 // 0x0330 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     FalloffQuadratic;                              // 0x033C (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              TorusRadius;                                   // 0x0348 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    LinearKernel;                                  // 0x0350 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxForceFieldGeneric");
		}

		return uClassPointer;
	};

	void DoInitRBPhys();
};

// Class Engine.NxForceFieldRadial
// 0x0028 (0x0298 - 0x02C0)
class ANxForceFieldRadial : public ANxForceField
{
public:
	class UForceFieldShape*                            Shape;                                         // 0x0298 (0x0008) [0x0000000004000001] (CPF_Edit | CPF_EditInline)
	class UActorComponent*                             DrawComponent;                                 // 0x02A0 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              ForceStrength;                                 // 0x02A8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceRadius;                                   // 0x02AC (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              SelfRotationStrength;                          // 0x02B0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	ERadialImpulseFalloff                              ForceFalloff;                                  // 0x02B4 (0x0001) [0x0000000000080009] (CPF_Edit | CPF_ExportObject | CPF_Component)
	struct FPointer                                    Kernel;                                        // 0x02B8 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxForceFieldRadial");
		}

		return uClassPointer;
	};

	void DoInitRBPhys();
};

// Class Engine.NxForceFieldTornado
// 0x0048 (0x0298 - 0x02E0)
class ANxForceFieldTornado : public ANxForceField
{
public:
	class UForceFieldShape*                            Shape;                                         // 0x0298 (0x0008) [0x0000000004000001] (CPF_Edit | CPF_EditInline)
	class UActorComponent*                             DrawComponent;                                 // 0x02A0 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              RadialStrength;                                // 0x02A8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              RotationalStrength;                            // 0x02AC (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftStrength;                                  // 0x02B0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceRadius;                                   // 0x02B4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceTopRadius;                                // 0x02B8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftFalloffHeight;                             // 0x02BC (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              EscapeVelocity;                                // 0x02C0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceHeight;                                   // 0x02C4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              HeightOffset;                                  // 0x02C8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	uint32_t                                           BSpecialRadialForceMode : 1;                   // 0x02CC (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              SelfRotationStrength;                          // 0x02D0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	struct FPointer                                    Kernel;                                        // 0x02D8 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxForceFieldTornado");
		}

		return uClassPointer;
	};

	void DoInitRBPhys();
};

// Class Engine.NxGenericForceField
// 0x00A0 (0x0298 - 0x0338)
class ANxGenericForceField : public ANxForceField
{
public:
	EFFG_ForceFieldCoordinates                         Coordinates;                                   // 0x0298 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Constant;                                      // 0x029C (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierX;                           // 0x02A8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierY;                           // 0x02B4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierZ;                           // 0x02C0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionTarget;                                // 0x02CC (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierX;                           // 0x02D8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierY;                           // 0x02E4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierZ;                           // 0x02F0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityTarget;                                // 0x02FC (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Noise;                                         // 0x0308 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     FalloffLinear;                                 // 0x0314 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     FalloffQuadratic;                              // 0x0320 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              TorusRadius;                                   // 0x032C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    LinearKernel;                                  // 0x0330 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxGenericForceField");
		}

		return uClassPointer;
	};

};

// Class Engine.NxGenericForceFieldBox
// 0x0018 (0x0338 - 0x0350)
class ANxGenericForceFieldBox : public ANxGenericForceField
{
public:
	class UDrawBoxComponent*                           RenderComponent;                               // 0x0338 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FVector                                     BoxExtent;                                     // 0x0340 (0x000C) [0x0000000200000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxGenericForceFieldBox");
		}

		return uClassPointer;
	};

	void DoInitRBPhys();
};

// Class Engine.NxGenericForceFieldCapsule
// 0x0010 (0x0338 - 0x0348)
class ANxGenericForceFieldCapsule : public ANxGenericForceField
{
public:
	class UDrawCapsuleComponent*                       RenderComponent;                               // 0x0338 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              CapsuleHeight;                                 // 0x0340 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CapsuleRadius;                                 // 0x0344 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxGenericForceFieldCapsule");
		}

		return uClassPointer;
	};

};

// Class Engine.NxRadialForceField
// 0x0020 (0x0298 - 0x02B8)
class ANxRadialForceField : public ANxForceField
{
public:
	class UDrawSphereComponent*                        RenderComponent;                               // 0x0298 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              ForceStrength;                                 // 0x02A0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceRadius;                                   // 0x02A4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	ERadialImpulseFalloff                              ForceFalloff;                                  // 0x02A8 (0x0001) [0x0000000000080009] (CPF_Edit | CPF_ExportObject | CPF_Component)
	struct FPointer                                    LinearKernel;                                  // 0x02B0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxRadialForceField");
		}

		return uClassPointer;
	};

};

// Class Engine.NxRadialCustomForceField
// 0x0010 (0x02B8 - 0x02C8)
class ANxRadialCustomForceField : public ANxRadialForceField
{
public:
	float                                              SelfRotationStrength;                          // 0x02B8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	struct FPointer                                    Kernel;                                        // 0x02C0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxRadialCustomForceField");
		}

		return uClassPointer;
	};

};

// Class Engine.NxTornadoAngularForceField
// 0x0038 (0x0298 - 0x02D0)
class ANxTornadoAngularForceField : public ANxForceField
{
public:
	float                                              RadialStrength;                                // 0x0298 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              RotationalStrength;                            // 0x029C (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftStrength;                                  // 0x02A0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceRadius;                                   // 0x02A4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceTopRadius;                                // 0x02A8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftFalloffHeight;                             // 0x02AC (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              EscapeVelocity;                                // 0x02B0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceHeight;                                   // 0x02B4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              HeightOffset;                                  // 0x02B8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	uint32_t                                           BSpecialRadialForceMode : 1;                   // 0x02BC (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              SelfRotationStrength;                          // 0x02C0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	struct FPointer                                    Kernel;                                        // 0x02C8 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxTornadoAngularForceField");
		}

		return uClassPointer;
	};

};

// Class Engine.NxTornadoAngularForceFieldCapsule
// 0x0008 (0x02D0 - 0x02D8)
class ANxTornadoAngularForceFieldCapsule : public ANxTornadoAngularForceField
{
public:
	class UDrawCapsuleComponent*                       RenderComponent;                               // 0x02D0 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxTornadoAngularForceFieldCapsule");
		}

		return uClassPointer;
	};

};

// Class Engine.NxTornadoForceField
// 0x0030 (0x0298 - 0x02C8)
class ANxTornadoForceField : public ANxForceField
{
public:
	float                                              RadialStrength;                                // 0x0298 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              RotationalStrength;                            // 0x029C (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftStrength;                                  // 0x02A0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceRadius;                                   // 0x02A4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceTopRadius;                                // 0x02A8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftFalloffHeight;                             // 0x02AC (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              EscapeVelocity;                                // 0x02B0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceHeight;                                   // 0x02B4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              HeightOffset;                                  // 0x02B8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	uint32_t                                           BSpecialRadialForceMode : 1;                   // 0x02BC (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FPointer                                    Kernel;                                        // 0x02C0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxTornadoForceField");
		}

		return uClassPointer;
	};

};

// Class Engine.NxTornadoForceFieldCapsule
// 0x0008 (0x02C8 - 0x02D0)
class ANxTornadoForceFieldCapsule : public ANxTornadoForceField
{
public:
	class UDrawCapsuleComponent*                       RenderComponent;                               // 0x02C8 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxTornadoForceFieldCapsule");
		}

		return uClassPointer;
	};

};

// Class Engine.NxForceFieldSpawnable
// 0x0008 (0x0240 - 0x0248)
class ANxForceFieldSpawnable : public AActor
{
public:
	class UNxForceFieldComponent*                      ForceFieldComponent;                           // 0x0240 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxForceFieldSpawnable");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* inAction);
};

// Class Engine.ParticleEventManager
// 0x0000 (0x0240 - 0x0240)
class AParticleEventManager : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleEventManager");
		}

		return uClassPointer;
	};

	void eventHandleParticleModuleEventSendToGame(class UParticleModuleEventSendToGame* InEvent, struct FVector& InCollideDirection, struct FVector& InHitLocation, struct FVector& InHitNormal, struct FName& InBoneName);
};

// Class Engine.Pawn
// 0x0478 (0x0240 - 0x06B8)
class APawn : public AActor
{
public:
	struct FPointer                                    VfTable_IIKilledBehavior;                      // 0x0240 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IITargetable;                          // 0x0248 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIViewTarget;                          // 0x0250 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IINamedObject;                         // 0x0258 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIDamageBehavior;                      // 0x0260 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIBasicBehavior;                       // 0x0268 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class APlayerStateInfo*                            PSI;                                           // 0x0270 (0x0008) [0x0000000000002000] (CPF_Transient)
	float                                              MaxStepHeight;                                 // 0x0278 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              MaxJumpHeight;                                 // 0x027C (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              WalkableFloorZ;                                // 0x0280 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              LedgeCheckThreshold;                           // 0x0284 (0x0004) [0x0000000000000002] (CPF_Const)   
	struct FVector                                     PartialLedgeMoveDir;                           // 0x0288 (0x000C) [0x0000000000000002] (CPF_Const)   
	class AController*                                 Controller;                                    // 0x0298 (0x0008) [0x0000000104000020] (CPF_Net | CPF_EditInline)
	class APawn*                                       NextPawn;                                      // 0x02A0 (0x0008) [0x0000000000000002] (CPF_Const)   
	float                                              NetRelevancyTime;                              // 0x02A8 (0x0004) [0x0000000000000000]               
	class APlayerController*                           LastRealViewer;                                // 0x02B0 (0x0008) [0x0000000000000000]               
	class AActor*                                      LastViewer;                                    // 0x02B8 (0x0008) [0x0000000000000000]               
	uint32_t                                           bScriptTickSpecial : 1;                        // 0x02C0 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bUpAndOut : 1;                                 // 0x02C0 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bIsWalking : 1;                                // 0x02C0 (0x0004) [0x0000000000000020] [0x00000004] (CPF_Net)
	uint32_t                                           bWantsToCrouch : 1;                            // 0x02C0 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bIsCrouched : 1;                               // 0x02C0 (0x0004) [0x0000000000000022] [0x00000010] (CPF_Const | CPF_Net)
	uint32_t                                           bTryToUncrouch : 1;                            // 0x02C0 (0x0004) [0x0000000000000002] [0x00000020] (CPF_Const)
	uint32_t                                           bCanCrouch : 1;                                // 0x02C0 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bCrawler : 1;                                  // 0x02C0 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bReducedSpeed : 1;                             // 0x02C0 (0x0004) [0x0000000000000002] [0x00000100] (CPF_Const)
	uint32_t                                           bJumpCapable : 1;                              // 0x02C0 (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bCanJump : 1;                                  // 0x02C0 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bCanWalk : 1;                                  // 0x02C0 (0x0004) [0x0000000000000000] [0x00000800] 
	uint32_t                                           bCanSwim : 1;                                  // 0x02C0 (0x0004) [0x0000000000000000] [0x00001000] 
	uint32_t                                           bCanFly : 1;                                   // 0x02C0 (0x0004) [0x0000000000000000] [0x00002000] 
	uint32_t                                           bCanClimbLadders : 1;                          // 0x02C0 (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bCanStrafe : 1;                                // 0x02C0 (0x0004) [0x0000000000000000] [0x00008000] 
	uint32_t                                           bAvoidLedges : 1;                              // 0x02C0 (0x0004) [0x0000000000000000] [0x00010000] 
	uint32_t                                           bStopAtLedges : 1;                             // 0x02C0 (0x0004) [0x0000000000000000] [0x00020000] 
	uint32_t                                           bAllowLedgeOverhang : 1;                       // 0x02C0 (0x0004) [0x0000000000000000] [0x00040000] 
	uint32_t                                           bPartiallyOverLedge : 1;                       // 0x02C0 (0x0004) [0x0000000000000002] [0x00080000] (CPF_Const)
	uint32_t                                           bSimulateGravity : 1;                          // 0x02C0 (0x0004) [0x0000000000000022] [0x00100000] (CPF_Const | CPF_Net)
	uint32_t                                           bIgnoreForces : 1;                             // 0x02C0 (0x0004) [0x0000000000000000] [0x00200000] 
	uint32_t                                           bCanWalkOffLedges : 1;                         // 0x02C0 (0x0004) [0x0000000000000000] [0x00400000] 
	uint32_t                                           bCanBeBaseForPawns : 1;                        // 0x02C0 (0x0004) [0x0000000000000000] [0x00800000] 
	uint32_t                                           bSimGravityDisabled : 1;                       // 0x02C0 (0x0004) [0x0000000000000002] [0x01000000] (CPF_Const)
	uint32_t                                           bDirectHitWall : 1;                            // 0x02C0 (0x0004) [0x0000000000000000] [0x02000000] 
	uint32_t                                           bPushesRigidBodies : 1;                        // 0x02C0 (0x0004) [0x0000000000000002] [0x04000000] (CPF_Const)
	uint32_t                                           bForceFloorCheck : 1;                          // 0x02C0 (0x0004) [0x0000000000000000] [0x08000000] 
	uint32_t                                           bForceKeepAnchor : 1;                          // 0x02C0 (0x0004) [0x0000000000000000] [0x10000000] 
	uint32_t                                           bProcessPawnsInHitWall : 1;                    // 0x02C0 (0x0004) [0x0000000000000000] [0x20000000] 
	uint32_t                                           bIgnoreAllTraces : 1;                          // 0x02C0 (0x0004) [0x0000000000002000] [0x40000000] (CPF_Transient)
	uint32_t                                           bCanMantle : 1;                                // 0x02C0 (0x0004) [0x0000000000004000] [0x80000000] (CPF_Config)
	uint32_t                                           bCanClimbUp : 1;                               // 0x02C4 (0x0004) [0x0000000000004000] [0x00000001] (CPF_Config)
	uint32_t                                           bCanClimbCeilings : 1;                         // 0x02C4 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bCanSwatTurn : 1;                              // 0x02C4 (0x0004) [0x0000000000004020] [0x00000004] (CPF_Net | CPF_Config)
	uint32_t                                           bCanLeap : 1;                                  // 0x02C4 (0x0004) [0x0000000000004000] [0x00000008] (CPF_Config)
	uint32_t                                           bCanCoverSlip : 1;                             // 0x02C4 (0x0004) [0x0000000000004000] [0x00000010] (CPF_Config)
	uint32_t                                           bDisplayPathErrors : 1;                        // 0x02C4 (0x0004) [0x0000000000044000] [0x00000020] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bCanPickupInventory : 1;                       // 0x02C4 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bAmbientCreature : 1;                          // 0x02C4 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bLOSHearing : 1;                               // 0x02C4 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bMuffledHearing : 1;                           // 0x02C4 (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bDontPossess : 1;                              // 0x02C4 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bRollToDesired : 1;                            // 0x02C4 (0x0004) [0x0000000000000000] [0x00000800] 
	uint32_t                                           bStationary : 1;                               // 0x02C4 (0x0004) [0x0000000000000000] [0x00001000] 
	uint32_t                                           bCachedRelevant : 1;                           // 0x02C4 (0x0004) [0x0000000000000000] [0x00002000] 
	uint32_t                                           bNoWeaponFiring : 1;                           // 0x02C4 (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bModifyReachSpecCost : 1;                      // 0x02C4 (0x0004) [0x0000000000000000] [0x00008000] 
	uint32_t                                           bModifyNavPointDest : 1;                       // 0x02C4 (0x0004) [0x0000000000000000] [0x00010000] 
	uint32_t                                           bPathfindsAsVehicle : 1;                       // 0x02C4 (0x0004) [0x0000000000000000] [0x00020000] 
	uint32_t                                           bPrevBypassSimulatedClientPhysics : 1;         // 0x02C4 (0x0004) [0x0000000000000000] [0x00040000] 
	uint32_t                                           bRunPhysicsWithNoController : 1;               // 0x02C4 (0x0004) [0x0000000000000000] [0x00080000] 
	uint32_t                                           bForceMaxAccel : 1;                            // 0x02C4 (0x0004) [0x0000000000000000] [0x00100000] 
	uint32_t                                           bLimitFallAccel : 1;                           // 0x02C4 (0x0004) [0x0000000000000000] [0x00200000] 
	uint32_t                                           bUsingAnimTreeMeshOffset : 1;                  // 0x02C4 (0x0004) [0x0000000000000000] [0x00400000] 
	uint32_t                                           bForceRMVelocity : 1;                          // 0x02C4 (0x0004) [0x0000000000000000] [0x00800000] 
	uint32_t                                           bForceRegularVelocity : 1;                     // 0x02C4 (0x0004) [0x0000000000000000] [0x01000000] 
	uint32_t                                           bTearOffImpulsePropagates : 1;                 // 0x02C4 (0x0004) [0x0000000000000020] [0x02000000] (CPF_Net)
	uint32_t                                           bPlayedDeath : 1;                              // 0x02C4 (0x0004) [0x0000000000000000] [0x04000000] 
	uint32_t                                           bDesiredRotationSet : 1;                       // 0x02C4 (0x0004) [0x0000000000000002] [0x08000000] (CPF_Const)
	uint32_t                                           bLockDesiredRotation : 1;                      // 0x02C4 (0x0004) [0x0000000000000002] [0x10000000] (CPF_Const)
	uint32_t                                           bUnlockWhenReached : 1;                        // 0x02C4 (0x0004) [0x0000000000000002] [0x20000000] (CPF_Const)
	uint32_t                                           bIsDead : 1;                                   // 0x02C4 (0x0004) [0x0000000000000000] [0x40000000] 
	uint32_t                                           bNeedsBaseTickedFirst : 1;                     // 0x02C4 (0x0004) [0x0000000000000000] [0x80000000] 
	uint32_t                                           bUsedByMatinee : 1;                            // 0x02C8 (0x0004) [0x0000000100002020] [0x00000001] (CPF_Net | CPF_Transient)
	uint32_t                                           bRootMotionFromInterpCurve : 1;                // 0x02C8 (0x0004) [0x0000000000000020] [0x00000002] (CPF_Net)
	uint32_t                                           bDebugShowCameraLocation : 1;                  // 0x02C8 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bFastAttachedMove : 1;                         // 0x02C8 (0x0004) [0x0000000000000021] [0x00000008] (CPF_Edit | CPF_Net)
	uint32_t                                           bSnapToTarget : 1;                             // 0x02C8 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bAutoAimTarget : 1;                            // 0x02C8 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bUnlockPreciseDestinationWhenReached : 1;      // 0x02C8 (0x0004) [0x0000000000000002] [0x00000040] (CPF_Const)
	uint32_t                                           ImmuneToFallingDamage : 1;                     // 0x02C8 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bSkipClientAdjustment : 1;                     // 0x02C8 (0x0004) [0x0000000000000020] [0x00000100] (CPF_Net)
	uint32_t                                           bIsTargetable : 1;                             // 0x02C8 (0x0004) [0x0000000000002020] [0x00000200] (CPF_Net | CPF_Transient)
	int32_t                                            bIsSprinting;                                  // 0x02CC (0x0004) [0x8000000000002020] (CPF_Net | CPF_Transient)
	int32_t                                            bIsSprintingBaseValue;                         // 0x02D0 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            bIsSprintingModifierStack;                     // 0x02D8 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	EPhysics                                           WalkingPhysics;                                // 0x02E8 (0x0001) [0x0000000000000000]               
	uint8_t                                            RemoteViewPitch;                               // 0x02E9 (0x0001) [0x0000000000000022] (CPF_Const | CPF_Net)
	uint8_t                                            RemoteViewYaw;                                 // 0x02EA (0x0001) [0x0000000000000022] (CPF_Const | CPF_Net)
	EAutoAimProfile                                    AutoAimProfile;                                // 0x02EB (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                            bEnableWeaponFireSkillEvent;                   // 0x02EC (0x0001) [0x8000000000002000] (CPF_Transient)
	uint8_t                                            bEnableWeaponFireSkillEventBaseValue;          // 0x02ED (0x0001) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            bEnableWeaponFireSkillEventModifierStack;      // 0x02F0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              UncrouchTime;                                  // 0x0300 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              CrouchHeight;                                  // 0x0304 (0x0004) [0x0000000000000000]               
	float                                              CrouchRadius;                                  // 0x0308 (0x0004) [0x0000000000000000]               
	int32_t                                            FullHeight;                                    // 0x030C (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              NonPreferredVehiclePathMultiplier;             // 0x0310 (0x0004) [0x0000000000000000]               
	float                                              HearingThreshold;                              // 0x0314 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              Alertness;                                     // 0x0318 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              SightRadius;                                   // 0x031C (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              PeripheralVision;                              // 0x0320 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              AvgPhysicsTime;                                // 0x0324 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              Buoyancy;                                      // 0x0328 (0x0004) [0x0000000000000002] (CPF_Const)   
	class ANavigationPoint*                            Anchor;                                        // 0x0330 (0x0008) [0x0000000000000002] (CPF_Const)   
	class ANavigationPoint*                            LastAnchor;                                    // 0x0338 (0x0008) [0x0000000000000002] (CPF_Const)   
	float                                              LastValidAnchorTime;                           // 0x0340 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              SpawnTime;                                     // 0x0344 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            MaxPitchLimit;                                 // 0x0348 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              GroundSpeed;                                   // 0x034C (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              GroundSpeedBaseValue;                          // 0x0350 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            GroundSpeedModifierStack;                      // 0x0358 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              WaterSpeed;                                    // 0x0368 (0x0004) [0x0000000000000021] (CPF_Edit | CPF_Net)
	float                                              AirSpeed;                                      // 0x036C (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              AirSpeedBaseValue;                             // 0x0370 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            AirSpeedModifierStack;                         // 0x0378 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              LadderSpeed;                                   // 0x0388 (0x0004) [0x0000000000000000]               
	float                                              AccelRate;                                     // 0x038C (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              AccelRateBaseValue;                            // 0x0390 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            AccelRateModifierStack;                        // 0x0398 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              JumpZ;                                         // 0x03A8 (0x0004) [0x8000000000002020] (CPF_Net | CPF_Transient)
	float                                              JumpZBaseValue;                                // 0x03AC (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            JumpZModifierStack;                            // 0x03B0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              OutofWaterZ;                                   // 0x03C0 (0x0004) [0x0000000000000000]               
	float                                              MaxOutOfWaterStepHeight;                       // 0x03C4 (0x0004) [0x0000000000000000]               
	float                                              AirControl;                                    // 0x03C8 (0x0004) [0x0000000000000020] (CPF_Net)     
	float                                              WalkingPct;                                    // 0x03CC (0x0004) [0x0000000000000000]               
	float                                              MovementSpeedModifier;                         // 0x03D0 (0x0004) [0x0000000000000000]               
	float                                              CrouchedPct;                                   // 0x03D4 (0x0004) [0x0000000000000000]               
	float                                              SprintingPct;                                  // 0x03D8 (0x0004) [0x8000000000002000] (CPF_Transient)
	float                                              SprintingPctBaseValue;                         // 0x03DC (0x0004) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            SprintingPctModifierStack;                     // 0x03E0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              MaxFallSpeed;                                  // 0x03F0 (0x0004) [0x0000000000000000]               
	float                                              TotalEncumbrance;                              // 0x03F4 (0x0004) [0x8000000000002020] (CPF_Net | CPF_Transient)
	float                                              TotalEncumbranceBaseValue;                     // 0x03F8 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            TotalEncumbranceModifierStack;                 // 0x0400 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              EncumbranceResistance;                         // 0x0410 (0x0004) [0x8000000000002020] (CPF_Net | CPF_Transient)
	float                                              EncumbranceResistanceBaseValue;                // 0x0414 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            EncumbranceResistanceModifierStack;            // 0x0418 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              BackpedalPct;                                  // 0x0428 (0x0004) [0x0000000000000000]               
	class UGearboxCollisionGridComponent*              CollisionGridComponent;                        // 0x0430 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FVector                                     ServerLocation;                                // 0x0438 (0x000C) [0x0000000000002000] (CPF_Transient)
	float                                              AnalogMovePct;                                 // 0x0444 (0x0004) [0x0000000000000000]               
	float                                              BaseEyeHeight;                                 // 0x0448 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              EyeHeight;                                     // 0x044C (0x0004) [0x0000000000000000]               
	struct FVector                                     Floor;                                         // 0x0450 (0x000C) [0x0000000000000000]               
	float                                              SplashTime;                                    // 0x045C (0x0004) [0x0000000000000000]               
	class APhysicsVolume*                              HeadVolume;                                    // 0x0460 (0x0008) [0x0000000000002000] (CPF_Transient)
	float                                              LastHealthVar;                                 // 0x0468 (0x0004) [0x0000000000000000]               
	float                                              LastHealthMaxVar;                              // 0x046C (0x0004) [0x0000000000000000]               
	struct FResourcePoolReference                      HealthPool;                                    // 0x0470 (0x0018) [0x0000002000000020] (CPF_Net)     
	float                                              BreathTime;                                    // 0x0488 (0x0004) [0x0000000000000000]               
	float                                              UnderWaterTime;                                // 0x048C (0x0004) [0x0000000000000000]               
	float                                              LastPainTime;                                  // 0x0490 (0x0004) [0x0000000000000000]               
	float                                              KismetDeathDelayTime;                          // 0x0494 (0x0004) [0x0000000000000000]               
	struct FVector                                     RMVelocity;                                    // 0x0498 (0x000C) [0x0000000000000000]               
	struct FVector                                     noise1spot;                                    // 0x04A4 (0x000C) [0x0000000000000002] (CPF_Const)   
	float                                              noise1time;                                    // 0x04B0 (0x0004) [0x0000000000000002] (CPF_Const)   
	class APawn*                                       noise1other;                                   // 0x04B8 (0x0008) [0x0000000000000002] (CPF_Const)   
	float                                              noise1loudness;                                // 0x04C0 (0x0004) [0x0000000000000002] (CPF_Const)   
	struct FVector                                     noise2spot;                                    // 0x04C4 (0x000C) [0x0000000000000002] (CPF_Const)   
	float                                              noise2time;                                    // 0x04D0 (0x0004) [0x0000000000000002] (CPF_Const)   
	class APawn*                                       noise2other;                                   // 0x04D8 (0x0008) [0x0000000000000002] (CPF_Const)   
	float                                              noise2loudness;                                // 0x04E0 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              SoundDampening;                                // 0x04E4 (0x0004) [0x0000000000000000]               
	float                                              DamageScaling;                                 // 0x04E8 (0x0004) [0x0000000000000000]               
	class FString                                      MenuName;                                      // 0x04F0 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class UClass*                                      ControllerClass;                               // 0x0500 (0x0008) [0x0000000000000000]               
	class APlayerReplicationInfo*                      PlayerReplicationInfo;                         // 0x0508 (0x0008) [0x0000000104000020] (CPF_Net | CPF_EditInline)
	class ALadderVolume*                               OnLadder;                                      // 0x0510 (0x0008) [0x0000000000000000]               
	struct FName                                       LandMovementState;                             // 0x0518 (0x0008) [0x0000000000000000]               
	struct FName                                       WaterMovementState;                            // 0x0520 (0x0008) [0x0000000000000000]               
	class APlayerStart*                                LastStartSpot;                                 // 0x0528 (0x0008) [0x0000000000000000]               
	float                                              LastStartTime;                                 // 0x0530 (0x0004) [0x0000000000000000]               
	struct FVector                                     TakeHitLocation;                               // 0x0534 (0x000C) [0x0000000000000020] (CPF_Net)     
	class UClass*                                      HitDamageType;                                 // 0x0540 (0x0008) [0x0000000000000020] (CPF_Net)     
	class UDamageTypeDefinition*                       HitDamageTypeDefinition;                       // 0x0548 (0x0008) [0x0000000000000020] (CPF_Net)     
	class UImpactDefinition*                           HitImpactDefinition;                           // 0x0550 (0x0008) [0x0000000000000020] (CPF_Net)     
	struct FVector                                     TearOffMomentum;                               // 0x0558 (0x000C) [0x0000000000000020] (CPF_Net)     
	class USkeletalMeshComponent*                      Mesh;                                          // 0x0568 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	class UCylinderComponent*                          CylinderComponent;                             // 0x0570 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              RBPushRadius;                                  // 0x0578 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RBPushStrength;                                // 0x057C (0x0004) [0x0000000000000001] (CPF_Edit)    
	class AVehicle*                                    DrivenVehicle;                                 // 0x0580 (0x0008) [0x0000000100000020] (CPF_Net)     
	float                                              VehicleCheckRadius;                            // 0x0588 (0x0004) [0x0000000000000000]               
	class AController*                                 LastHitBy;                                     // 0x0590 (0x0008) [0x0000000000000000]               
	float                                              ViewPitchMin;                                  // 0x0598 (0x0004) [0x0000000000000000]               
	float                                              ViewPitchMax;                                  // 0x059C (0x0004) [0x0000000000000000]               
	int32_t                                            AllowedYawError;                               // 0x05A0 (0x0004) [0x0000000000000000]               
	struct FRotator                                    DesiredRotation;                               // 0x05A4 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UClass*                                      InventoryManagerClass;                         // 0x05B0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class AInventoryManager*                           InvManager;                                    // 0x05B8 (0x0008) [0x0000000100000020] (CPF_Net)     
	class AWeapon*                                     Weapon;                                        // 0x05C0 (0x0008) [0x0000000100000020] (CPF_Net)     
	class AWeapon*                                     OffHandWeapon;                                 // 0x05C8 (0x0008) [0x0000000100000020] (CPF_Net)     
	class UPrimitiveComponent*                         PreRagdollCollisionComponent;                  // 0x05D0 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	class UPawnAllegiance*                             Allegiance;                                    // 0x05D8 (0x0008) [0x0000000100000022] (CPF_Const | CPF_Net)
	class UITargetable*                                AllegianceParent_Object;                       // 0x05E0 (0x0008) [0x0000000000002000] (CPF_Transient)
	class UITargetable*                                AllegianceParent_Interface;                    // 0x05E8 (0x0008) [0x0000000000002000] (CPF_Transient)
	class TArray<class UITargetable*>                  AllegianceChildren;                            // 0x05F0 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class URB_BodyInstance*                            PhysicsPushBody;                               // 0x0600 (0x0008) [0x0000000000000000]               
	int32_t                                            FailedLandingCount;                            // 0x0608 (0x0004) [0x0000000000000000]               
	class TArray<class UAnimNodeSlot*>                 SlotNodes;                                     // 0x0610 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<class UInterpGroup*>                  InterpGroupList;                               // 0x0620 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FScalarParameterInterpStruct>  ScalarParameterInterpArray;                    // 0x0630 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FRootMotionCurve                            RootMotionInterpCurve;                         // 0x0640 (0x0028) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              RootMotionInterpRate;                          // 0x0668 (0x0004) [0x0000000000000020] (CPF_Net)     
	float                                              RootMotionInterpCurrentTime;                   // 0x066C (0x0004) [0x0000000000000020] (CPF_Net)     
	struct FVector                                     RootMotionInterpCurveLastValue;                // 0x0670 (0x000C) [0x0000000000000020] (CPF_Net)     
	float                                              MaxPreciseDestinationSpeed;                    // 0x067C (0x0004) [0x0000000000000000]               
	float                                              HorizontalPreciseDestinationThreshold;         // 0x0680 (0x0004) [0x0000000000000000]               
	float                                              VerticalPreciseDestinationThreshold;           // 0x0684 (0x0004) [0x0000000000000000]               
	struct FRecentDamageTracker                        RecentDamage;                                  // 0x0688 (0x000C) [0x0000000000000000]               
	struct FBalanceDefSpawnedActorState                BalanceDefinitionState;                        // 0x0698 (0x0010) [0x0000000100000020] (CPF_Net)     
	int32_t                                            YawLastFrame;                                  // 0x06A8 (0x0004) [0x0000000000000000]               
	float                                              YawPerSecond;                                  // 0x06AC (0x0004) [0x0000000000000000]               
	class UTextureCube*                                CachedEnvironmentMap;                          // 0x06B0 (0x0008) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Pawn");
		}

		return uClassPointer;
	};

	struct FRotator GetAimRotation();
	bool IsVulnerableToFriendlyFire();
	void ResetDefaultRotationRate();
	float GetAudibility();
	float GetVisibility();
	void SetPatsy(class UITargetable* NewPatsy);
	class UITargetable* GetPatsy();
	bool IsBeingHealed();
	void SetBeingHealed(bool bNewBeingHealed);
	ERootMotionRotationMode GetDefaultRootMotionRotationMode();
	ERootMotionMode GetDefaultRootMotionMode();
	bool OverrideDestroyInventoryContents(bool bDestroyContents);
	void TellSpawnerPawnIsDead(bool bKeepCorpse);
	struct FVector GetDamageVector();
	class UMeshComponent* GetRigidBodyMesh();
	void DestroyHealthPool();
	void SetHealthResourcePoolDefinition(class UIResourcePoolProvider* ResourcePoolProvider, class UResourcePoolDefinition* Definition);
	void Behavior_Killed(class AActor* Killer, class UDamageTypeDefinition* optionalTechFilter, EScriptedKillType optionalDeathType);
	void Behavior_CauseRadiusDamage(float Radius, float DamageAmount, bool bFullDamage, float Momentum, class UClass* DamageType, class UDamagePipeline* Pipeline, const struct FVector& optionalOffset, class UIDamageCauser* optionalDamageCauser, bool optionalBSkipTraceTest, EOpinion optionalAllegianceFilter, class TArray<class AActor*>& ActorsHurt);
	void Behavior_CauseDamage(class AActor* Target, float DamageAmount, float Momentum, class UClass* DamageType, class UDamagePipeline* Pipeline, class UIDamageCauser* optionalDamageCauser);
	float EvaluateAttributeInitialization(const struct FAttributeInitializationData& InitData);
	class UAnimNode* FindAnimNode(const struct FName& NodeName);
	void SetRotationRate(const struct FRotator& NewRotationRate);
	float GetCollisionRadius();
	void Behavior_RegisterTargetable(bool bUnregister);
	void Behavior_SetCanTarget(EChangeStatus ChangeStatus);
	int32_t ShowSelfAsTarget(bool bControllersOnly);
	void SetScalarParameterInterp(struct FScalarParameterInterpStruct& ScalarParameterInterp);
	void SetRootMotionInterpCurrentTime(float inTime, float optionalDeltaTime, bool optionalBUpdateSkelPose);
	void ZeroMovementVariables();
	void eventSoakPause();
	void eventBecomeViewTarget(class APlayerController* PC);
	void eventMessagePlayer(const class FString& msg);
	bool HandleTeleport(const class TArray<class UObject*>& DestList, bool bUpdateRotation, bool bCheckOverlap, float optionalTeleportDistance, const class TArray<class AVolume*>& optionalTeleportVolumes, int32_t optionalPreferredDestIndex);
	void OnTeleport(class USeqAct_Teleport* Action);
	void OnSetMaterial(class USeqAct_SetMaterial* Action);
	float GetDamageScaling();
	void DoKismetAttachment(class AActor* Attachment, class USeqAct_AttachToActor* Action);
	void eventSpawnedByKismet();
	struct FVector GetCollisionExtent();
	float eventGetCollisionHeight();
	bool CheatFly();
	bool CheatGhost();
	bool CheatWalk();
	void PlayWeaponSwitch(class AWeapon* OldWeapon, class AWeapon* NewWeapon);
	void SetActiveWeapon(class AWeapon* NewWeapon, bool bOffHand);
	void TossInventory(class AInventory* Inv, const struct FVector& optionalForceVelocity);
	void ThrowActiveWeapon(bool optionalBDestroyWeap);
	void DrawHUD(class AHUD* H);
	class AInventory* FindInventoryType(class UClass* DesiredClass, bool optionalBAllowSubclass);
	class AInventory* eventCreateInventory(class UClass* NewInvClass, bool optionalBDoNotActivate);
	void AddDefaultInventory();
	void eventStopDriving(class AVehicle* V);
	void eventStartDriving(class AVehicle* V, bool optionalSkipAnim);
	bool CanThrowWeapon();
	void Suicide();
	class AVehicle* GetVehicleBase();
	void PlayLanded(float ImpactVel, class AActor* optionalFloorActor);
	bool CannotJumpNow();
	void PlayFootStepSound(int32_t FootDown, bool bFirstPerson);
	void eventTornOff();
	void PlayDying(class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition, class UImpactDefinition* ImpactDefinition, const struct FVector& HitLoc);
	void SetDyingPhysics();
	void TurnOff();
	void PlayHealingHit(class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, const struct FTraceHitInfo& HitInfo, class UDamagePipeline* optionalPipeline);
	void PlayHit(class APawn* SomePawn, const struct FVector& HitLocation, class UClass* DamageType, const struct FVector& Momentum, const struct FTraceHitInfo& HitInfo, class UDamagePipeline* optionalPipeline, bool optionalBFriendlyNoDamage);
	bool PawnCheckPlayHitPreconditions(class UDamagePipeline* Pipeline);
	void PlayDyingSound();
	bool DoJump(bool bUpdating);
	bool CanJump();
	bool CanStuckJump();
	bool CheckWaterJump(struct FVector& WallNormal);
	void TakeDrowningDamage();
	void eventBreathTimer();
	bool TouchingWaterVolume();
	void eventHeadVolumeChange(class APhysicsVolume* newHeadVolume);
	void eventTickSpecial(float DeltaTime);
	void eventLanded(const struct FVector& HitNormal, class AActor* FloorActor);
	void eventFalling();
	void DelayTriggerDeath();
	bool Died(class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation, class UDamagePipeline* optionalPipeline);
	void ThrowWeaponOnDeath();
	bool eventIsSameTeam(class APawn* Other);
	class ATeamInfo* GetTeam();
	uint8_t GetTeamNum();
	void TookDamageFromFriendly(float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& optionalHitInfo, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline);
	void TookDamageFromEnemy(class AController* InstigatedBy, class UCharacterClassDefinition* MyCharacterClass, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& optionalHitInfo, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline);
	void eventTakeDamage(float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& HitDirection, class UClass* DamageType, const struct FTraceHitInfo& optionalHitInfo, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline);
	bool PawnCheckTakeDamagePreconditions();
	bool eventHandleHealthDepleted(class AController* InstigatedBy, class UClass* DamageType, const struct FVector& HitLocation, class UIDamageCauser* DamageCauser, const struct FTraceHitInfo& optionalHitInfo, class UDamagePipeline* optionalPipeline);
	class AController* SetKillInstigator(class AController* InstigatedBy, class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition);
	void NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, float Damage, class UClass* DamageType, const struct FVector& Momentum, class UDamagePipeline* optionalPipeline);
	bool eventTakeRadiusDamageOnBones(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class UIDamageCauser* DamageCauser, const class TArray<struct FName>& Bones, class UDamagePipeline* optionalPipeline);
	void PruneDamagedBoneList(class TArray<struct FName>& Bones);
	bool eventHealDamage(float Amount, class AController* Healer, class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition, bool optionalBIsShieldRestore);
	void AdjustDamage(class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* DamageType, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline, float& InDamage, float& DamageSeverityPercent, struct FVector& Momentum, struct FTraceHitInfo& HitInfo);
	void SetMovementPhysics();
	void Gasp();
	void OnAssignController(class USeqAct_AssignController* inAction);
	void eventReceivedNewEvent(class USequenceEvent* Evt);
	void SpawnDefaultController();
	void eventPostBeginPlay();
	void eventPreBeginPlay();
	void eventDestroyed();
	void DetachFromController(bool optionalBDestroyController);
	void CrushedByActor(class AActor* Other);
	void CrushedBy(class APawn* OtherPawn);
	bool CanBeBaseForPawn(class APawn* aPawn);
	void eventBaseChange();
	void eventStuckOnPawn(class APawn* OtherPawn);
	void JumpOffPawn();
	void gibbedBy(class AActor* Other);
	void eventEncroachedBy(class AActor* Other);
	bool eventEncroachingOn(class AActor* Other);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void eventUpdatePawnRotation(const struct FRotator& NewRotation);
	void ClientSetRotation(const struct FRotator& NewRotation);
	void ClientRestart();
	void Restart();
	float GetFallingDamageScale();
	void TakeFallingDamage();
	void KilledBy(class APawn* EventInstigator);
	void AddVelocity(const struct FVector& NewVelocity, const struct FVector& HitLocation, class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition, const struct FTraceHitInfo& optionalHitInfo);
	void HandleMomentum(const struct FVector& Momentum, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& optionalHitInfo);
	void eventStartCrouch(float HeightAdjust);
	void eventEndCrouch(float HeightAdjust);
	void ShouldCrouch(bool bCrouch);
	void UnCrouch();
	bool eventOutsideWorldBounds();
	void eventFellOutOfWorld(class UClass* dmgType);
	void eventClientMessage(const class FString& S, const struct FName& optionalType);
	void HandlePickup(class AInventory* Inv);
	void SetMoveTarget(class AActor* NewTarget);
	bool InGodMode();
	void SetViewRotation(const struct FRotator& NewRotation);
	struct FRotator GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc);
	bool InFreeCam();
	struct FRotator eventGetBaseAimRotation();
	struct FVector GetWeaponStartTraceLocation(class AWeapon* optionalCurrentWeapon);
	struct FVector GetCameraAnchorLocation();
	struct FVector GetPawnViewLocation();
	struct FRotator GetViewRotation();
	void GetActorEyesViewPoint(struct FVector& out_Location, struct FRotator& out_Rotation);
	void ProcessViewRotation(float DeltaTime, struct FRotator& out_ViewRotation, struct FRotator& out_DeltaRot);
	bool IsPlayerPawn();
	bool IsLocallyControlled();
	bool IsAIControlled();
	bool IsHumanControlled(class AController* optionalPawnController);
	void SwitchDisplayDebugPage(const struct FName& ActiveDebugCategory, bool Forward);
	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	void ClimbLadder(class ALadderVolume* L);
	void EndClimbLadder(class ALadderVolume* OldLadder);
	bool CanSplash();
	void eventSetSprinting(bool bNewIsSprinting);
	float RangedAttackTime();
	bool RecommendLongRangedAttack();
	bool CanGrabLadder();
	void DropToGround();
	struct FName GetDefaultCameraMode(class APlayerController* RequestedBy);
	void UnPossessed();
	void UpdateControllerOnPossess(bool bVehicleTransition);
	void UpdateWeaponOnPossess(bool bVehicleTransition);
	void PossessedBy(class AController* C, bool bVehicleTransition);
	void NotifyTeamChanged();
	void PlayTeleportEffect(bool bOut, bool bSound);
	bool NeedToTurn(const struct FVector& targ);
	bool IsFiring();
	bool HasRangedAttack();
	bool FireOnRelease();
	bool TooCloseToAttack(class AActor* Other);
	bool CanAttack(class AActor* Other);
	void StopOffHandFire(uint8_t FireModeNum);
	void StopFire(uint8_t FireModeNum, bool optionalBInterrupted);
	void StartOffHandFire(uint8_t FireModeNum);
	void StartFire(uint8_t FireModeNum);
	bool StopFiring();
	void Reset();
	void PlayerChangedTeam();
	void SetBaseEyeheight();
	bool IsDead();
	bool IsInjured();
	class AController* GetController();
	bool SpecialMoveTo(class ANavigationPoint* Start, class ANavigationPoint* End, class AActor* Next);
	bool TermRagdoll();
	bool InitRagdoll();
	void GetBoundingCylinder(float& CollisionRadius, float& CollisionHeight);
	bool ReachedDesiredRotation();
	void SetPushesRigidBodies(bool NewPush);
	void UndoForceCrouch();
	void ForceCrouch();
	bool ReachedPoint(const struct FVector& Point, class AActor* NewAnchor);
	bool ReachedDestination(class AActor* Goal);
	class ANavigationPoint* GetBestAnchor(class AActor* TestActor, const struct FVector& TestLocation, bool bStartPoint, bool bOnlyCheckVisible, float& out_Dist);
	void SetAnchor(class ANavigationPoint* NewAnchor);
	void SetRemoteViewYaw(int32_t NewRemoteViewYaw);
	void SetRemoteViewPitch(int32_t NewRemoteViewPitch);
	bool IsInvisible();
	bool IsValidEnemyTargetFor(class APlayerReplicationInfo* PRI, bool bNoPRIisEnemy);
	float GetFallDuration();
	float GetJumpVelocity();
	bool IsAliveAndWell();
	void ApplyBalanceDefinitionCustomizations();
	void InitializeBalanceDefinitionState(class UBaseBalanceDefinition* BalanceDefinition, int32_t GradeIndex);
	void eventReplicatedEvent(const struct FName& VarName);
	void eventSetSkelControlScale(const struct FName& SkelControlName, float Scale);
	void eventSetMorphWeight(const struct FName& MorphNodeName, float MorphWeight);
	class UFaceFXAsset* eventGetActorFaceFXAsset();
	void OnPlayFaceFXAnim(class USeqAct_PlayFaceFXAnim* inAction);
	bool CanActorPlayFaceFXAnim();
	bool IsActorPlayingFaceFXAnim();
	void eventStopActorFaceFXAnim();
	bool eventPlayActorFaceFXAnim(class UFaceFXAnimSet* AnimSet, const class FString& GroupName, const class FString& SeqName, class UAkEvent* AkEventToPlay);
	void eventMAT_FinishAIGroup();
	void eventMAT_BeginAIGroup(const struct FVector& StartLoc, const struct FRotator& StartRot, EInterpGroupAlignmentTypes AlignmentType, float LerpTime, bool bDemiGod);
	void FinishAIGroup();
	void BeginAIGroup();
	void eventInterpolationFinished(class USeqAct_Interp* InterpAction);
	void eventInterpolationStarted(class USeqAct_Interp* InterpAction, class UInterpGroupInst* GroupInst);
	void LastMatineeAnimFinished();
	void MAT_SetSkelControlStrength(const struct FName& SkelControlName, float ControlStrength);
	void MAT_SetSkelControlScale(const struct FName& SkelControlName, float Scale);
	void MAT_SetMorphWeight(const struct FName& MorphNodeName, float MorphWeight);
	void MAT_SetAnimWeights(const class TArray<struct FAnimSlotInfo>& SlotInfos);
	void MAT_SetAnimPosition(const struct FName& SlotName, int32_t ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion);
	void eventSetAnimPosition(const struct FName& SlotName, int32_t ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion);
	void MAT_FinishAnimControl(class UInterpGroup* InInterpGroup);
	void eventFinishAnimControl(class UInterpGroup* InInterpGroup);
	void MAT_BeginAnimControl(class UInterpGroup* InInterpGroup);
	void eventBeginAnimControl(class UInterpGroup* InInterpGroup);
	float GetDefaultMaxHealth();
	float GetDefaultHealth();
	float GetMaxHealth();
	float GetHealth();
	void SetMaxHealth(float NewMaxHealth);
	void SetHealth(float NewHealth);
	bool eventRestoreAnimSetsToDefault();
	void eventAnimSetListUpdated();
	void AddAnimSets(class TArray<class UAnimSet*>& CustomAnimSets);
	void eventBuildScriptAnimSetList();
	void UpdateAnimSetList();
	void ClearAnimNodes();
	void CacheAnimNodes();
	void eventPostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	bool IsDesiredRotationLocked();
	bool IsDesiredRotationInUse();
	void CheckDesiredRotation();
	void ResetDesiredRotation();
	void LockDesiredRotation(bool Lock, bool optionalInUnlockWhenReached);
	bool SetDesiredRotation(const struct FRotator& TargetDesiredRotation, bool optionalInLockDesiredRotation, bool optionalInUnlockWhenReached, float optionalInterpolationTime, bool optionalBResetRotationRate);
	static bool IsExperiencePipelineDebugEnabled();
	static void ToggleExperiencePipelineDebug();
	static bool IsCurrencyPipelineDebugEnabled();
	static void ToggleCurrencyPipelineDebug();
	static bool IsDamagePipelineDebugEnabled();
	static void ToggleDamagePipelineDebug();
	void SetInfoBarVisibility(bool bVisible);
	bool HideTargetInfoOnHud(class APawn* optionalHUDOwner);
	bool IsChampion();
	bool IsBoss();
	bool DisplayParentInfo();
	void GetHealthInfo(struct FHealthInfo& OutHealthInfo);
	void GetExpInfo(int32_t& ExpLevelValue);
	bool IsUsingWalkingPhysics();
	void SetAutoAimProfile(EAutoAimProfile NewProfile);
	EAutoAimProfile GetAutoAimProfile();
	float GetMagnetismRange();
	struct FVector GetMagnetismOrigin();
	bool IsAutoAimTarget();
	bool IsValidHomingTarget();
	bool GetTargetableIsHidden();
	bool DoesTargetableTakeDamage();
	float GetTargetingModifier();
	bool CanSnapZoom();
	void GetSnapRegion(struct FTargetSnapRegion& SnapRegion);
	struct FVector GetSnapLocation();
	void GetAuxiliaryTargetableLocations(class TArray<struct FVector>& AuxLocations);
	struct FVector GetTargetableLocation();
	bool IsTargetableProxy();
	bool IsTargetable(int32_t optionalTargetFlags);
	EOpinion GetOpinion(class UObject* Other);
	void SetAllegiance(class UPawnAllegiance* NewAllegiance);
	class UPawnAllegiance* GetDefaultAllegiance();
	class UPawnAllegiance* GetObjectAllegianceW();
	bool IsSameAllegiance(class UObject* anObject);
	bool IsNeutral(class UObject* anObject);
	bool IsFriendly(class UObject* anObject);
	bool IsEnemy(class UObject* anObject);
	class AActor* GetTargetableActor();
};

// Class Engine.MatineePawn
// 0x0000 (0x06B8 - 0x06B8)
class AMatineePawn : public APawn
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MatineePawn");
		}

		return uClassPointer;
	};

};

// Class Engine.Vehicle
// 0x0088 (0x06B8 - 0x0740)
class AVehicle : public APawn
{
public:
	class APawn*                                       Driver;                                        // 0x06B8 (0x0008) [0x0000000100000020] (CPF_Net)     
	uint32_t                                           bDriving : 1;                                  // 0x06C0 (0x0004) [0x0000000100000020] [0x00000001] (CPF_Net)
	uint32_t                                           bDriverIsVisible : 1;                          // 0x06C0 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bAttachDriver : 1;                             // 0x06C0 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bTurnInPlace : 1;                              // 0x06C0 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bSeparateTurretFocus : 1;                      // 0x06C0 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bFollowLookDir : 1;                            // 0x06C0 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bHasHandbrake : 1;                             // 0x06C0 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bScriptedRise : 1;                             // 0x06C0 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bDuckObstacles : 1;                            // 0x06C0 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bAvoidReversing : 1;                           // 0x06C0 (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bRetryPathfindingWithDriver : 1;               // 0x06C0 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bIgnoreStallZ : 1;                             // 0x06C0 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bDoExtraNetRelevancyTraces : 1;                // 0x06C0 (0x0004) [0x0000000000000000] [0x00001000] 
	class TArray<struct FVector>                       ExitPositions;                                 // 0x06C8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              ExitRadius;                                    // 0x06D8 (0x0004) [0x0000000000000000]               
	struct FVector                                     ExitOffset;                                    // 0x06DC (0x000C) [0x0000000000000000]               
	float                                              Steering;                                      // 0x06E8 (0x0004) [0x0000000000000000]               
	float                                              Throttle;                                      // 0x06EC (0x0004) [0x0000000000000000]               
	float                                              Rise;                                          // 0x06F0 (0x0004) [0x0000000000000000]               
	struct FVector                                     TargetLocationAdjustment;                      // 0x06F4 (0x000C) [0x0000000000000000]               
	float                                              DriverDamageMult;                              // 0x0700 (0x0004) [0x0000000000000000]               
	float                                              MomentumMult;                                  // 0x0704 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UClass*                                      CrushedDamageType;                             // 0x0708 (0x0008) [0x0000000000000000]               
	float                                              MinCrushSpeed;                                 // 0x0710 (0x0004) [0x0000000000000000]               
	float                                              ForceCrushPenetration;                         // 0x0714 (0x0004) [0x0000000000000000]               
	uint8_t                                            StuckCount;                                    // 0x0718 (0x0001) [0x0000000000000000]               
	float                                              ThrottleTime;                                  // 0x071C (0x0004) [0x0000000000000000]               
	float                                              StuckTime;                                     // 0x0720 (0x0004) [0x0000000000000000]               
	float                                              OldSteering;                                   // 0x0724 (0x0004) [0x0000000000000000]               
	float                                              OnlySteeringStartTime;                         // 0x0728 (0x0004) [0x0000000000000000]               
	float                                              OldThrottle;                                   // 0x072C (0x0004) [0x0000000000000000]               
	float                                              AIMoveCheckTime;                               // 0x0730 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              VehicleMovingTime;                             // 0x0734 (0x0004) [0x0000000000000000]               
	float                                              TurnTime;                                      // 0x0738 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Vehicle");
		}

		return uClassPointer;
	};

	void SwitchSeats();
	void ZeroMovementVariables();
	void NotifyDriverTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, float Damage, class UClass* DamageType, const struct FVector& Momentum, class UDamagePipeline* optionalPipeline);
	void eventReplicatedEvent(const struct FName& VarName);
	void SetVehicleBlockingMeshCollision(class APawn* DriverPawn);
	void eventDrivingStatusChanged();
	void SetDriving(bool B);
	struct FVector eventGetEntryLocation();
	void CrushedBy(class APawn* OtherPawn);
	void PancakeOther(class APawn* Other);
	bool eventEncroachingOn(class AActor* Other);
	class AController* GetCollisionDamageInstigator();
	void eventEncroachedBy(class AActor* Other);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	struct FName GetDefaultCameraMode(class APlayerController* RequestedBy);
	void PlayDying(class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition, class UImpactDefinition* ImpactDefinition, const struct FVector& HitLoc);
	void DriverDied(class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition);
	bool Died(class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation, class UDamagePipeline* optionalPipeline);
	void ThrowActiveWeapon(bool optionalBDestroyWeap);
	void eventTakeDamage(float Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& HitDirection, class UClass* DamageType, const struct FTraceHitInfo& optionalHitInfo, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline);
	class AController* SetKillInstigator(class AController* InstigatedBy, class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition);
	void UnPossessed();
	bool TryExitPos(class APawn* ExitingDriver, const struct FVector& ExitPos, bool bMustFindGround);
	bool FindAutoExit(class APawn* ExitingDriver);
	bool PlaceExitingDriver(class APawn* optionalExitingDriver);
	void DriverLeft();
	void SetInputs(float InForward, float InStrafe, float InUp);
	void NoFailSetDriverLocation(class APawn* DriverPawn, const struct FVector& NewLocation);
	bool eventDriverLeave(bool bForceLeave, bool optionalSkipPawnPlacement);
	struct FVector GetDefaultExitLocation(class APawn* ExitingDriver);
	struct FRotator GetExitRotation(class AController* C);
	bool eventContinueOnFoot();
	void DetachDriver(class APawn* P);
	void AttachDriver(class APawn* P, bool optionalSkipAnim);
	void EntryAnnouncement(class AController* C);
	void PossessedBy(class AController* C, bool bVehicleTransition);
	bool DriverEnter(class APawn* P, bool optionalSkipAnim);
	bool TryToRide(class APawn* P, bool optionalSkipAnim, int32_t optionalPreferredSeat);
	bool AnySeatAvailable();
	bool CanEnterVehicle(class APawn* P);
	void Destroyed_HandleDriver();
	void eventDestroyed();
	bool CheatFly();
	bool CheatGhost();
	bool CheatWalk();
	void eventPostBeginPlay();
	void SetBaseEyeheight();
	void PlayerChangedTeam();
	void DriverRadiusDamage(float DamageAmount, float DamageRadius, class AController* EventInstigator, class UClass* DamageType, float Momentum, const struct FVector& HitLocation, class UIDamageCauser* DamageCauser, float optionalDamageFalloffExponent, class UDamagePipeline* optionalPipeline);
	void TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class UIDamageCauser* DamageCauser, float optionalDamageFalloffExponent, class UDamagePipeline* optionalPipeline);
	struct FVector GetTargetLocation(class AActor* optionalRequestedBy, bool optionalBRequestAlternateLoc);
	float GetMaxRiseForce();
	bool IsAttachedRiderSeat();
	class AController* GetDriverController();
	class AVehicle* GetVehicleBase();
	void Suicide();
	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	void NotifyTeamChanged();
};

// Class Engine.SVehicle
// 0x0140 (0x0740 - 0x0880)
class ASVehicle : public AVehicle
{
public:
	struct FPointer                                    PVehicle;                                      // 0x0740 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FPointer                                    MyVehicleManager;                              // 0x0748 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	float                                              ChassisMass;                                   // 0x0750 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bIsTank : 1;                                   // 0x0754 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bEnableDebugRendering : 1;                     // 0x0754 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bInReverseMode : 1;                            // 0x0754 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bStayUpright : 1;                              // 0x0754 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bUseSuspensionAxis : 1;                        // 0x0754 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bUpdateWheelShapes : 1;                        // 0x0754 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bVehicleOnGround : 1;                          // 0x0754 (0x0004) [0x0000000000000002] [0x00000040] (CPF_Const)
	uint32_t                                           bVehicleOnWater : 1;                           // 0x0754 (0x0004) [0x0000000000000002] [0x00000080] (CPF_Const)
	uint32_t                                           bIsInverted : 1;                               // 0x0754 (0x0004) [0x0000000000000002] [0x00000100] (CPF_Const)
	uint32_t                                           bChassisTouchingGround : 1;                    // 0x0754 (0x0004) [0x0000000000000002] [0x00000200] (CPF_Const)
	uint32_t                                           bWasChassisTouchingGroundLastTick : 1;         // 0x0754 (0x0004) [0x0000000000000002] [0x00000400] (CPF_Const)
	uint32_t                                           bCanFlip : 1;                                  // 0x0754 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bFlipRight : 1;                                // 0x0754 (0x0004) [0x0000000000000000] [0x00001000] 
	uint32_t                                           bIsUprighting : 1;                             // 0x0754 (0x0004) [0x0000000000000000] [0x00002000] 
	uint32_t                                           bOutputHandbrake : 1;                          // 0x0754 (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bHoldingDownHandbrake : 1;                     // 0x0754 (0x0004) [0x0000000000000000] [0x00008000] 
	uint32_t                                           bAllowPhysFlying : 1;                          // 0x0754 (0x0004) [0x0000000000000001] [0x00010000] (CPF_Edit)
	int32_t                                            DebugRenderActiveGraphChannelWheel;            // 0x0758 (0x0004) [0x0000000000000000]               
	int32_t                                            DebugRenderActiveGraphChannelEngine;           // 0x075C (0x0004) [0x0000000000000000]               
	class USVehicleSimBase*                            SimObj;                                        // 0x0760 (0x0008) [0x000000000608000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Component | CPF_NoClear | CPF_EditInline)
	class TArray<class USVehicleWheel*>                Wheels;                                        // 0x0768 (0x0010) [0x0000000004480009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	struct FVector                                     COMOffset;                                     // 0x0778 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     InertiaTensorMultiplier;                       // 0x0784 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              StayUprightRollResistAngle;                    // 0x0790 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StayUprightPitchResistAngle;                   // 0x0794 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StayUprightStiffness;                          // 0x0798 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StayUprightDamping;                            // 0x079C (0x0004) [0x0000000000000001] (CPF_Edit)    
	class URB_StayUprightSetup*                        StayUprightConstraintSetup;                    // 0x07A0 (0x0008) [0x0000000004400008] (CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class URB_ConstraintInstance*                      StayUprightConstraintInstance;                 // 0x07A8 (0x0008) [0x0000000004400008] (CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	float                                              HeavySuspensionShiftPercent;                   // 0x07B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxSpeed;                                      // 0x07B4 (0x0004) [0x0000000000000021] (CPF_Edit | CPF_Net)
	float                                              MaxAngularVelocity;                            // 0x07B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TimeOffGround;                                 // 0x07BC (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              UprightLiftStrength;                           // 0x07C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              UprightTorqueStrength;                         // 0x07C4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              UprightTime;                                   // 0x07C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              UprightStartTime;                              // 0x07CC (0x0004) [0x0000000000000000]               
	float                                              CollisionIntervalSecs;                         // 0x07D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CollisionThreshold;                            // 0x07D4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SquealThreshold;                               // 0x07D8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SquealLatThreshold;                            // 0x07DC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LatAngleVolumeMult;                            // 0x07E0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              EngineStartOffsetSecs;                         // 0x07E4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              EngineStopOffsetSecs;                          // 0x07E8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LastCollisionSoundTime;                        // 0x07EC (0x0004) [0x0000000000000000]               
	float                                              OutputBrake;                                   // 0x07F0 (0x0004) [0x0000000000000000]               
	float                                              OutputGas;                                     // 0x07F4 (0x0004) [0x0000000000000000]               
	float                                              OutputSteering;                                // 0x07F8 (0x0004) [0x0000000000000000]               
	float                                              OutputRise;                                    // 0x07FC (0x0004) [0x0000000000000000]               
	float                                              ForwardVel;                                    // 0x0800 (0x0004) [0x0000000000000000]               
	int32_t                                            NumPoweredWheels;                              // 0x0804 (0x0004) [0x0000000000000000]               
	struct FVector                                     BaseOffset;                                    // 0x0808 (0x000C) [0x0000000000000000]               
	float                                              CamDist;                                       // 0x0814 (0x0004) [0x0000000000000000]               
	int32_t                                            DriverViewPitch;                               // 0x0818 (0x0004) [0x0000000000000000]               
	int32_t                                            DriverViewYaw;                                 // 0x081C (0x0004) [0x0000000000000000]               
	struct FVehicleState                               VState;                                        // 0x0820 (0x0050) [0x0000000000001022] (CPF_Const | CPF_Net | CPF_Native)
	float                                              AngErrorAccumulator;                           // 0x0870 (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)
	float                                              RadialImpulseScaling;                          // 0x0874 (0x0004) [0x0000000000000000]               
	uint8_t                                           UnknownData00[0x8];                            // 0x0878 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SVehicle");
		}

		return uClassPointer;
	};

	void GetSVehicleDebug(class TArray<class FString>& DebugInfo);
	float HermiteEval(float Slip);
	void DrawWheel(class AHUD* HUD, int32_t WheelIndex, const struct FVector& ScreenLoc, float YL);
	void DisplayWheelsDebug(class AHUD* HUD, float YL);
	void DisplayDebug(class AHUD* HUD, float& out_YL, float& out_YPos);
	void PostTeleport(class ATeleporter* OutTeleporter);
	void eventDrivingStatusChanged();
	void VehiclePlayExitSound();
	void VehiclePlayEnterSound();
	void StopEngineSoundTimed();
	void StopEngineSound();
	void StartEngineSoundTimed();
	void StartEngineSound();
	bool HasWheelsOnGround();
	struct FName GetDefaultCameraMode(class APlayerController* RequestedBy);
	bool Died(class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation, class UDamagePipeline* optionalPipeline);
	void AddVelocity(const struct FVector& NewVelocity, const struct FVector& HitLocation, class UClass* DamageType, class UDamageTypeDefinition* DamageTypeDefinition, const struct FTraceHitInfo& optionalHitInfo);
	void InitVehicleRagdoll(class USkeletalMesh* RagdollMesh, class UPhysicsAsset* RagdollPhysAsset, const struct FVector& ActorMove, bool bClearAnimTree);
	void TakeRadiusDamage(class AController* InstigatedBy, float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, bool bFullDamage, class UIDamageCauser* DamageCauser, float optionalDamageFalloffExponent, class UDamagePipeline* optionalPipeline);
	void StopVehicleSounds();
	void TurnOff();
	void eventDestroyed();
	void eventPostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void SetWheelCollision(int32_t WheelNum, bool bCollision);
	void DrawGraphsAndPrintTireSurfaceTypes(class AHUD* HUD, float YL, float YPos);
	bool IsSleeping();
	void AddTorque(const struct FVector& Torque);
	void AddImpulse(const struct FVector& Impulse);
	void AddForce(const struct FVector& Force);
};

// Class Engine.PickupableMeshActor
// 0x0018 (0x0240 - 0x0258)
class APickupableMeshActor : public AActor
{
public:
	class AActor*                                      MyTarget;                                      // 0x0240 (0x0008) [0x0000000000000000]               
	float                                              MoveSpeed;                                     // 0x0248 (0x0004) [0x0000000000000000]               
	int32_t                                            RotateSpeed;                                   // 0x024C (0x0004) [0x0000000000000000]               
	float                                              PawnEyeHeightAdjustment;                       // 0x0250 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PickupableMeshActor");
		}

		return uClassPointer;
	};

	void SetTarget(class AActor* TargetActor);
};

// Class Engine.PipelineHistoryManager
// 0x04E0 (0x0240 - 0x0720)
class APipelineHistoryManager : public AActor
{
public:
	int32_t                                            Filter_TimeStampStart;                         // 0x0240 (0x0004) [0x0000000000000000]               
	int32_t                                            Filter_TimeStampEnd;                           // 0x0244 (0x0004) [0x0000000000000000]               
	float                                              Filter_MinFinalValue;                          // 0x0248 (0x0004) [0x0000000000000000]               
	float                                              Filter_MaxFinalValue;                          // 0x024C (0x0004) [0x0000000000000000]               
	EAttackerDefenderFilterType                        Filter_AttackerDefender;                       // 0x0250 (0x0001) [0x0000000000000000]               
	ECriticalHitFilterType                             Filter_CriticalHit;                            // 0x0251 (0x0001) [0x0000000000000000]               
	class UClass*                                      Filter_ObjectClass;                            // 0x0258 (0x0008) [0x0000000000000000]               
	class AActor*                                      Filter_NamedActor;                             // 0x0260 (0x0008) [0x0000000000000000]               
	class FString                                      Filter_AttackingPlayerName;                    // 0x0268 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      Filter_DefendingPlayerName;                    // 0x0278 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FDamageEventSummary>           CachedDamageHistories;                         // 0x0288 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FDamageEventSummary>           FilteredDamageHistories;                       // 0x0298 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            FilteredDamageHistoryIndex;                    // 0x02A8 (0x0004) [0x0000000000000000]               
	class TArray<struct FCurrencyEventSummary>         CachedCurrencyHistories;                       // 0x02B0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FCurrencyEventSummary>         FilteredCurrencyHistories;                     // 0x02C0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            FilteredCurrencyHistoryIndex;                  // 0x02D0 (0x0004) [0x0000000000000000]               
	class TArray<struct FExperienceEventSummary>       CachedExperienceHistories;                     // 0x02D8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FExperienceEventSummary>       FilteredExperienceHistories;                   // 0x02E8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            FilteredExperienceHistoryIndex;                // 0x02F8 (0x0004) [0x0000000000000000]               
	uint32_t                                           bServerAskingSelf : 1;                         // 0x02FC (0x0004) [0x0000000000000000] [0x00000001] 
	int32_t                                            NumberOfDamageSummariesToRetrieve;             // 0x0300 (0x0004) [0x0000000000000000]               
	int32_t                                            NumberOfCurrencySummariesToRetrieve;           // 0x0304 (0x0004) [0x0000000000000000]               
	int32_t                                            NumberOfExperienceSummariesToRetrieve;         // 0x0308 (0x0004) [0x0000000000000000]               
	int32_t                                            CurrentDamageSummaryCount;                     // 0x030C (0x0004) [0x0000000000000020] (CPF_Net)     
	int32_t                                            CurrentCurrencySummaryCount;                   // 0x0310 (0x0004) [0x0000000000000020] (CPF_Net)     
	int32_t                                            CurrentExperienceSummaryCount;                 // 0x0314 (0x0004) [0x0000000000000020] (CPF_Net)     
	struct FSummaryCount                               MatchingSummaries;                             // 0x0318 (0x000C) [0x0000000100000020] (CPF_Net)     
	struct FDamageEventSummary                         ReplicatedDamageHistory;                       // 0x0328 (0x0220) [0x0000000100400020] (CPF_Net | CPF_NeedCtorLink)
	struct FCurrencyEventSummary                       ReplicatedCurrencyHistory;                     // 0x0548 (0x00E8) [0x0000000100400020] (CPF_Net | CPF_NeedCtorLink)
	struct FExperienceEventSummary                     ReplicatedExperienceHistory;                   // 0x0630 (0x00F0) [0x0000000100400020] (CPF_Net | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PipelineHistoryManager");
		}

		return uClassPointer;
	};

	void ClearAllFilters();
	void ScriptPrintCurrentFilterInLog();
	void eventReplicatedEvent(const struct FName& VarName);
	void HandleExperienceSummary(const struct FExperienceEventSummary& ReplicatedSummary);
	void HandleCurrencySummary(const struct FCurrencyEventSummary& ReplicatedSummary);
	void HandleDamageSummary(const struct FDamageEventSummary& ReplicatedSummary);
	void RequestNextExperienceSummary();
	void RequestNextCurrencySummary();
	void RequestNextDamageSummary();
	void PrepRequestForExperienceSummaries(int32_t NumberToRetrieve, bool bIsServer);
	void PrepRequestForCurrencySummaries(int32_t NumberToRetrieve, bool bIsServer);
	void PrepRequestForDamageSummaries(int32_t NumberToRetrieve, bool bIsServer);
	void RequestCurrentFilterResults();
	void ServerClearAllFilters();
	void NewFilterConfirmation(const struct FSummaryCount& NumberOfHistories);
	void SetFilterCriticalHit(ECriticalHitFilterType NewCritCycle);
	void SetFilterAttackerDefender(EAttackerDefenderFilterType NewAttackerDefenderCycle);
	void SetFilterNamedActor(class AActor* NewNamedActor);
	void SetFilterObjectClass(class UClass* NewObjectClass);
	void SetFilterFinalValue(float NewMinFinalValue, float NewMaxFinalValue);
	void SetFilterTimeStamps(int32_t NewStartTimeStamp, int32_t NewEndTimeStamp);
	void SetFilterDefendingPlayerName(const class FString& NewDefendingPlayerName);
	void SetFilterAttackingPlayerName(const class FString& NewAttackingPlayerName);
};

// Class Engine.PlayerStateInfo
// 0x0028 (0x0240 - 0x0268)
class APlayerStateInfo : public AActor
{
public:
	struct FPointer                                    VfTable_IIResourcePoolProvider;                // 0x0240 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class APawn*                                       Pawn;                                          // 0x0248 (0x0008) [0x0000000000000000]               
	class AController*                                 Controller;                                    // 0x0250 (0x0008) [0x0000000000000000]               
	class APlayerReplicationInfo*                      PRI;                                           // 0x0258 (0x0008) [0x0000000000000000]               
	uint32_t                                           bInSprintState : 1;                            // 0x0260 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PlayerStateInfo");
		}

		return uClassPointer;
	};

	bool IsSprinting();
	bool EndSprinting();
	bool BeginSprinting();
	void OnSpawningProcessComplete();
	void InitPlayerStateInfo();
	class AActor* GetResourcePoolProviderActor();
	void SetResourcePoolManager(class AResourcePoolManager* InManager);
	class AResourcePoolManager* GetResourcePoolManager();
	struct FResourcePoolReference GetResourcePoolForResourceDefinition(class UResourceDefinition* Resource, bool optionalBCreatePoolIfOneDoesntExist);
};

// Class Engine.PrefabInstance
// 0x0108 (0x0240 - 0x0348)
class APrefabInstance : public AActor
{
public:
	class UPrefab*                                     TemplatePrefab;                                // 0x0240 (0x0008) [0x0000000000000002] (CPF_Const)   
	int32_t                                            TemplateVersion;                               // 0x0248 (0x0004) [0x0000000000000002] (CPF_Const)   
	uint8_t                                           UnknownData00[0x50];                           // 0x0250 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.PrefabInstance.ArchetypeToInstanceMap
	class UPrefabSequence*                             SequenceInstance;                              // 0x02A0 (0x0008) [0x0000000000000002] (CPF_Const)   
	int32_t                                            PI_PackageVersion;                             // 0x02A8 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            PI_LicenseePackageVersion;                     // 0x02AC (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            PI_GamePackageVersion;                         // 0x02B0 (0x0004) [0x0000000000000002] (CPF_Const)   
	class TArray<uint8_t>                              PI_Bytes;                                      // 0x02B8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<class UObject*>                       PI_CompleteObjects;                            // 0x02C8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<class UObject*>                       PI_ReferencedObjects;                          // 0x02D8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<class FString>                        PI_SavedNames;                                 // 0x02E8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	uint8_t                                           UnknownData01[0x50];                           // 0x02F8 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.PrefabInstance.PI_ObjectMap

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PrefabInstance");
		}

		return uClassPointer;
	};

};

// Class Engine.Projectile
// 0x0090 (0x0240 - 0x02D0)
class AProjectile : public AActor
{
public:
	float                                              Speed;                                         // 0x0240 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxSpeed;                                      // 0x0244 (0x0004) [0x0000000100000021] (CPF_Edit | CPF_Net)
	uint32_t                                           bSwitchToZeroCollision : 1;                    // 0x0248 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bBlockedByInstigator : 1;                      // 0x0248 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bBegunPlay : 1;                                // 0x0248 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bRotationFollowsVelocity : 1;                  // 0x0248 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bIgnoreFoliageTouch : 1;                       // 0x0248 (0x0004) [0x0000000000000000] [0x00000010] 
	class AActor*                                      ZeroCollider;                                  // 0x0250 (0x0008) [0x0000000000000000]               
	class UPrimitiveComponent*                         ZeroColliderComponent;                         // 0x0258 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              Damage;                                        // 0x0260 (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              DamageBaseValue;                               // 0x0264 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            DamageModifierStack;                           // 0x0268 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              DamageRadius;                                  // 0x0278 (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              DamageRadiusBaseValue;                         // 0x027C (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            DamageRadiusModifierStack;                     // 0x0280 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              MomentumTransfer;                              // 0x0290 (0x0004) [0x8000000000002021] (CPF_Edit | CPF_Net | CPF_Transient)
	float                                              MomentumTransferBaseValue;                     // 0x0294 (0x0004) [0x4000000000000022] (CPF_Const | CPF_Net)
	class TArray<class UAttributeModifier*>            MomentumTransferModifierStack;                 // 0x0298 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class UClass*                                      MyDamageType;                                  // 0x02A8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UPhysicsResponseDefinition*                  PhysicsResponse;                               // 0x02B0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class AController*                                 InstigatorController;                          // 0x02B8 (0x0008) [0x0000000000000000]               
	class AActor*                                      ImpactedActor;                                 // 0x02C0 (0x0008) [0x0000000000000000]               
	class UCylinderComponent*                          CylinderComponent;                             // 0x02C8 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Projectile");
		}

		return uClassPointer;
	};

	static float GetRange();
	static float StaticGetTimeToLocation(const struct FVector& TargetLoc, const struct FVector& StartLoc, class AController* RequestedBy);
	float GetTimeToLocation(const struct FVector& TargetLoc);
	void eventFellOutOfWorld(class UClass* dmgType);
	void RandSpin(float spinRate);
	void Explode(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void eventEncroachedBy(class AActor* Other);
	void eventHitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void ProcessTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void eventTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool HurtRadius(float DamageAmount, float InDamageRadius, class UClass* DamageType, float Momentum, const struct FVector& HurtOrigin, class AController* optionalInstigatedByController, bool optionalBDoFullDamage, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline, bool optionalBSkipTraceTest, EOpinion optionalAllegianceFilter, class TArray<class AActor*>& IgnoredActors, class TArray<class AActor*>& ActorsHurt);
	bool ProjectileHurtRadius(const struct FVector& HurtOrigin, const struct FVector& HitNormal);
	void Reset();
	bool CanSplash();
	uint8_t GetTeamNum();
	void Init(const struct FVector& Direction);
	void eventPostBeginPlay();
	void eventPreBeginPlay();
	bool eventEncroachingOn(class AActor* Other);
};

// Class Engine.PxForceField
// 0x0020 (0x0240 - 0x0260)
class APxForceField : public AActor
{
public:
	int32_t                                            ExcludeChannel;                                // 0x0240 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bForceActive : 1;                              // 0x0244 (0x0004) [0x0000000000000021] [0x00000001] (CPF_Edit | CPF_Net)
	uint32_t                                           ForceIsImpulse : 1;                            // 0x0244 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	struct FRBCollisionChannelContainer                CollideWithChannels;                           // 0x0248 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ERBCollisionChannel                                RBChannel;                                     // 0x024C (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ERadialImpulseFalloff                              ForceFalloff;                                  // 0x024D (0x0001) [0x0000000000080009] (CPF_Edit | CPF_ExportObject | CPF_Component)
	class UForceFieldShape*                            ForceFieldParams;                              // 0x0250 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              Force;                                         // 0x0258 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            SceneIndex;                                    // 0x025C (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PxForceField");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* inAction);
};

// Class Engine.Pylon
// 0x0060 (0x0240 - 0x02A0)
class APylon : public AActor
{
public:
	struct FPointer                                    VfTable_IEditorLinkSelectionInterface;         // 0x0240 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class TArray<class AVolume*>                       ExpansionVolumes;                              // 0x0248 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              ExpansionRadius;                               // 0x0258 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FNavMeshPathSize>              PathSizes;                                     // 0x0260 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FColor                                      EdgeColor;                                     // 0x0270 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<class AActor*>                        OnBuild_DisableCollisionForThese;              // 0x0278 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class AActor*>                        OnBuild_EnableCollisionForThese;               // 0x0288 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bCheckPathSizes : 1;                           // 0x0298 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              IconScale;                                     // 0x029C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Pylon");
		}

		return uClassPointer;
	};

};

// Class Engine.DynamicPylon
// 0x0000 (0x02A0 - 0x02A0)
class ADynamicPylon : public APylon
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DynamicPylon");
		}

		return uClassPointer;
	};

};

// Class Engine.PylonSeed
// 0x0010 (0x0240 - 0x0250)
class APylonSeed : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavMeshPathObject;          // 0x0240 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIGBXNavMeshSeed;                      // 0x0248 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PylonSeed");
		}

		return uClassPointer;
	};

};

// Class Engine.RadialBlurActor
// 0x0008 (0x0240 - 0x0248)
class ARadialBlurActor : public AActor
{
public:
	class URadialBlurComponent*                        RadialBlur;                                    // 0x0240 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RadialBlurActor");
		}

		return uClassPointer;
	};

};

// Class Engine.RealTimeShatterMgr
// 0x0018 (0x0240 - 0x0258)
class ARealTimeShatterMgr : public AActor
{
public:
	class UMaterialInterface*                          UnbrokenShatterMaterial;                       // 0x0240 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UMaterialInterface*                          BrokenShatterMaterial;                         // 0x0248 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UParticleSystem*                             ChunkDissolveParticleSystem;                   // 0x0250 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RealTimeShatterMgr");
		}

		return uClassPointer;
	};

};

// Class Engine.RigidBodyBase
// 0x0000 (0x0240 - 0x0240)
class ARigidBodyBase : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RigidBodyBase");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_ConstraintActor
// 0x0038 (0x0240 - 0x0278)
class ARB_ConstraintActor : public ARigidBodyBase
{
public:
	class AActor*                                      ConstraintActor1;                              // 0x0240 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class AActor*                                      ConstraintActor2;                              // 0x0248 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class URB_ConstraintSetup*                         ConstraintSetup;                               // 0x0250 (0x0008) [0x0000000006400009] (CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_NoClear | CPF_EditInline)
	class URB_ConstraintInstance*                      ConstraintInstance;                            // 0x0258 (0x0008) [0x0000000006400009] (CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_NoClear | CPF_EditInline)
	uint32_t                                           bDisableCollision : 1;                         // 0x0260 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bUpdateActor1RefFrame : 1;                     // 0x0260 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bUpdateActor2RefFrame : 1;                     // 0x0260 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	class AActor*                                      PulleyPivotActor1;                             // 0x0268 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class AActor*                                      PulleyPivotActor2;                             // 0x0270 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_ConstraintActor");
		}

		return uClassPointer;
	};

	void OnToggleConstraintDrive(class USeqAct_ToggleConstraintDrive* Action);
	void OnToggle(class USeqAct_Toggle* Action);
	void OnDestroy(class USeqAct_Destroy* Action);
	void TermConstraint();
	void InitConstraint(class AActor* Actor1, class AActor* Actor2, const struct FName& optionalActor1Bone, const struct FName& optionalActor2Bone, float optionalBreakThreshold);
	void SetDisableCollision(bool NewDisableCollision);
};

// Class Engine.RB_BSJointActor
// 0x0000 (0x0278 - 0x0278)
class ARB_BSJointActor : public ARB_ConstraintActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_BSJointActor");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_ConstraintActorSpawnable
// 0x0000 (0x0278 - 0x0278)
class ARB_ConstraintActorSpawnable : public ARB_ConstraintActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_ConstraintActorSpawnable");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_HingeActor
// 0x0000 (0x0278 - 0x0278)
class ARB_HingeActor : public ARB_ConstraintActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_HingeActor");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_PrismaticActor
// 0x0000 (0x0278 - 0x0278)
class ARB_PrismaticActor : public ARB_ConstraintActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_PrismaticActor");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_PulleyJointActor
// 0x0000 (0x0278 - 0x0278)
class ARB_PulleyJointActor : public ARB_ConstraintActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_PulleyJointActor");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_CylindricalForceActor
// 0x0038 (0x0240 - 0x0278)
class ARB_CylindricalForceActor : public ARigidBodyBase
{
public:
	class UDrawCylinderComponent*                      RenderComponent;                               // 0x0240 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              RadialStrength;                                // 0x0248 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              RotationalStrength;                            // 0x024C (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftStrength;                                  // 0x0250 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftFalloffHeight;                             // 0x0254 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              EscapeVelocity;                                // 0x0258 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceRadius;                                   // 0x025C (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceTopRadius;                                // 0x0260 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceHeight;                                   // 0x0264 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              HeightOffset;                                  // 0x0268 (0x0004) [0x0000000200000001] (CPF_Edit)    
	uint32_t                                           bForceActive : 1;                              // 0x026C (0x0004) [0x0000000000000021] [0x00000001] (CPF_Edit | CPF_Net)
	uint32_t                                           bForceApplyToCloth : 1;                        // 0x026C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bForceApplyToFluid : 1;                        // 0x026C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bForceApplyToRigidBodies : 1;                  // 0x026C (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bForceApplyToProjectiles : 1;                  // 0x026C (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	struct FRBCollisionChannelContainer                CollideWithChannels;                           // 0x0270 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_CylindricalForceActor");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* inAction);
};

// Class Engine.RB_LineImpulseActor
// 0x0020 (0x0240 - 0x0260)
class ARB_LineImpulseActor : public ARigidBodyBase
{
public:
	float                                              ImpulseStrength;                               // 0x0240 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ImpulseRange;                                  // 0x0244 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bVelChange : 1;                                // 0x0248 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bStopAtFirstHit : 1;                           // 0x0248 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	class UArrowComponent*                             Arrow;                                         // 0x0250 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	uint8_t                                            ImpulseCount;                                  // 0x0258 (0x0001) [0x0000000100000020] (CPF_Net)     

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_LineImpulseActor");
		}

		return uClassPointer;
	};

	void eventReplicatedEvent(const struct FName& VarName);
	void OnToggle(class USeqAct_Toggle* inAction);
	void FireLineImpulse();
};

// Class Engine.RB_RadialForceActor
// 0x0028 (0x0240 - 0x0268)
class ARB_RadialForceActor : public ARigidBodyBase
{
public:
	class UDrawSphereComponent*                        RenderComponent;                               // 0x0240 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              ForceStrength;                                 // 0x0248 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceRadius;                                   // 0x024C (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              SwirlStrength;                                 // 0x0250 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              SpinTorque;                                    // 0x0254 (0x0004) [0x0000000200000001] (CPF_Edit)    
	ERadialImpulseFalloff                              ForceFalloff;                                  // 0x0258 (0x0001) [0x0000000000080009] (CPF_Edit | CPF_ExportObject | CPF_Component)
	ERadialForceType                                   RadialForceMode;                               // 0x0259 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bForceActive : 1;                              // 0x025C (0x0004) [0x0000000000000021] [0x00000001] (CPF_Edit | CPF_Net)
	uint32_t                                           bForceApplyToCloth : 1;                        // 0x025C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bForceApplyToFluid : 1;                        // 0x025C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bForceApplyToRigidBodies : 1;                  // 0x025C (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bForceApplyToProjectiles : 1;                  // 0x025C (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	struct FRBCollisionChannelContainer                CollideWithChannels;                           // 0x0260 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_RadialForceActor");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* inAction);
};

// Class Engine.RB_RadialImpulseActor
// 0x0018 (0x0240 - 0x0258)
class ARB_RadialImpulseActor : public ARigidBodyBase
{
public:
	class UDrawSphereComponent*                        RenderComponent;                               // 0x0240 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	class URB_RadialImpulseComponent*                  ImpulseComponent;                              // 0x0248 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	uint8_t                                            ImpulseCount;                                  // 0x0250 (0x0001) [0x0000000100000020] (CPF_Net)     

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_RadialImpulseActor");
		}

		return uClassPointer;
	};

	void eventReplicatedEvent(const struct FName& VarName);
	void OnToggle(class USeqAct_Toggle* inAction);
};

// Class Engine.RB_Thruster
// 0x0008 (0x0240 - 0x0248)
class ARB_Thruster : public ARigidBodyBase
{
public:
	uint32_t                                           bThrustEnabled : 1;                            // 0x0240 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              ThrustStrength;                                // 0x0244 (0x0004) [0x0000000200000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_Thruster");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* Action);
};

// Class Engine.SkeletalMeshActor
// 0x0068 (0x0240 - 0x02A8)
class ASkeletalMeshActor : public AActor
{
public:
	struct FPointer                                    VfTable_IIFaceFXActor;                         // 0x0240 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	uint32_t                                           bDamageAppliesImpulse : 1;                     // 0x0248 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bShouldDoAnimNotifies : 1;                     // 0x0248 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           FaceFXSpeechPending : 1;                       // 0x0248 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bForceSaveInCheckpoint : 1;                    // 0x0248 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bCollideActors_OldValue : 1;                   // 0x0248 (0x0004) [0x0000000020000000] [0x00000010]  CPF_Deprecated)
	class USkeletalMeshComponent*                      SkeletalMeshComponent;                         // 0x0250 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	class ULightEnvironmentComponent*                  LightEnvironment;                              // 0x0258 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	class USkeletalMesh*                               ReplicatedMesh;                                // 0x0260 (0x0008) [0x0000000100002020] (CPF_Net | CPF_Transient)
	class UMaterialInterface*                          ReplicatedMaterial0;                           // 0x0268 (0x0008) [0x0000000100000020] (CPF_Net)     
	class UMaterialInterface*                          ReplicatedMaterial1;                           // 0x0270 (0x0008) [0x0000000100000020] (CPF_Net)     
	class TArray<struct FSkelMeshActorControlTarget>   ControlTargets;                                // 0x0278 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UInterpGroup*>                  InterpGroupList;                               // 0x0288 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	struct FName                                       SavedAnimSeqName;                              // 0x0298 (0x0008) [0x0000000000002000] (CPF_Transient)
	float                                              SavedCurrentTime;                              // 0x02A0 (0x0004) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkeletalMeshActor");
		}

		return uClassPointer;
	};

	void eventSetAudioCueOpenedByFaceFX(bool Opened);
	class UFaceFXAsset* eventGetFaceFXAsset();
	bool eventCreateForceField(class UAnimNotify_ForceField* AnimNotifyData);
	void SkelMeshActorOnParticleSystemFinished(class UParticleSystemComponent* PSC);
	bool eventPlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	void ApplyCheckpointRecord(struct FSkeletalMeshActorCheckpointRecord& Record);
	void CreateCheckpointRecord(struct FSkeletalMeshActorCheckpointRecord& Record);
	bool ShouldSaveForCheckpoint();
	void eventTakeDamage(float Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& HitDirection, class UClass* DamageType, const struct FTraceHitInfo& optionalHitInfo, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline);
	void DoKismetAttachment(class AActor* Attachment, class USeqAct_AttachToActor* Action);
	void eventShutDown();
	void eventOnSetSkelControlTarget(class USeqAct_SetSkelControlTarget* Action);
	void eventOnUpdatePhysBonesFromAnim(class USeqAct_UpdatePhysBonesFromAnim* Action);
	void eventOnSetMesh(class USeqAct_SetMesh* Action);
	bool IsActorPlayingFaceFXAnim();
	class UObject* eventIGetActorFaceFXAsset();
	class UFaceFXAsset* eventGetActorFaceFXAsset();
	void OnPlayFaceFXAnim(class USeqAct_PlayFaceFXAnim* inAction);
	void eventStopActorFaceFXAnim();
	bool eventPlayActorFaceFXAnim(class UFaceFXAnimSet* AnimSet, const class FString& GroupName, const class FString& SeqName, class UAkEvent* AkEventToPlay);
	void MAT_FinishAnimControl(class UInterpGroup* InInterpGroup);
	void eventFinishAnimControl(class UInterpGroup* InInterpGroup);
	void eventSetAnimPosition(const struct FName& SlotName, int32_t ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion);
	void MAT_BeginAnimControl(class UInterpGroup* InInterpGroup);
	void eventBeginAnimControl(class UInterpGroup* InInterpGroup);
	void OnSetMaterial(class USeqAct_SetMaterial* Action);
	void OnToggle(class USeqAct_Toggle* Action);
	void eventReplicatedEvent(const struct FName& VarName);
	void UpdateAnimSetList();
	void eventDestroyed();
	void eventPostBeginPlay();
};

// Class Engine.SkeletalMeshActorBasedOnExtremeContent
// 0x0020 (0x02A8 - 0x02C8)
class ASkeletalMeshActorBasedOnExtremeContent : public ASkeletalMeshActor
{
public:
	class TArray<struct FSkelMaterialSetterDatum>      ExtremeContent;                                // 0x02A8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FSkelMaterialSetterDatum>      NonExtremeContent;                             // 0x02B8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkeletalMeshActorBasedOnExtremeContent");
		}

		return uClassPointer;
	};

	void SetMaterialBasedOnExtremeContent();
	void eventPostBeginPlay();
};

// Class Engine.SkeletalMeshActorSpawnable
// 0x0000 (0x02A8 - 0x02A8)
class ASkeletalMeshActorSpawnable : public ASkeletalMeshActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkeletalMeshActorSpawnable");
		}

		return uClassPointer;
	};

};

// Class Engine.SkeletalMeshCinematicActor
// 0x0000 (0x02A8 - 0x02A8)
class ASkeletalMeshCinematicActor : public ASkeletalMeshActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkeletalMeshCinematicActor");
		}

		return uClassPointer;
	};

};

// Class Engine.SkeletalMeshActorMAT
// 0x0010 (0x02A8 - 0x02B8)
class ASkeletalMeshActorMAT : public ASkeletalMeshCinematicActor
{
public:
	class TArray<class UAnimNodeSlot*>                 SlotNodes;                                     // 0x02A8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkeletalMeshActorMAT");
		}

		return uClassPointer;
	};

	void eventSetSkelControlScale(const struct FName& SkelControlName, float Scale);
	void eventSetMorphWeight(const struct FName& MorphNodeName, float MorphWeight);
	void eventFinishAnimControl(class UInterpGroup* InInterpGroup);
	void MAT_SetAnimPosition(const struct FName& SlotName, int32_t ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion);
	void eventSetAnimPosition(const struct FName& SlotName, int32_t ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion);
	void ClearAnimNodes();
	void CacheAnimNodes();
	void eventPostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void eventDestroyed();
	void MAT_SetSkelControlStrength(const struct FName& SkelControlName, float ControlStrength);
	void MAT_SetSkelControlScale(const struct FName& SkelControlName, float Scale);
	void MAT_SetMorphWeight(const struct FName& MorphNodeName, float MorphWeight);
	void MAT_SetAnimWeights(const class TArray<struct FAnimSlotInfo>& SlotInfos);
};

// Class Engine.SkeletalMeshActorMATSpawnable
// 0x0000 (0x02B8 - 0x02B8)
class ASkeletalMeshActorMATSpawnable : public ASkeletalMeshActorMAT
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkeletalMeshActorMATSpawnable");
		}

		return uClassPointer;
	};

};

// Class Engine.SkeletalMeshActorMATWalkable
// 0x0000 (0x02B8 - 0x02B8)
class ASkeletalMeshActorMATWalkable : public ASkeletalMeshActorMAT
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkeletalMeshActorMATWalkable");
		}

		return uClassPointer;
	};

};

// Class Engine.SplineActor
// 0x0070 (0x0240 - 0x02B0)
class ASplineActor : public AActor
{
public:
	class TArray<struct FSplineConnection>             Connections;                                   // 0x0240 (0x0010) [0x0000000000480000] (CPF_Component | CPF_NeedCtorLink)
	struct FVector                                     SplineActorTangent;                            // 0x0250 (0x000C) [0x0000000200000001] (CPF_Edit)    
	struct FColor                                      SplineColor;                                   // 0x025C (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDisableDestination : 1;                       // 0x0260 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAlreadyVisited : 1;                           // 0x0260 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	class TArray<class ASplineActor*>                  LinksFrom;                                     // 0x0268 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class ASplineActor*                                nextOrdered;                                   // 0x0278 (0x0008) [0x0000000000002000] (CPF_Transient)
	class ASplineActor*                                prevOrdered;                                   // 0x0280 (0x0008) [0x0000000000002000] (CPF_Transient)
	class ASplineActor*                                previousPath;                                  // 0x0288 (0x0008) [0x0000000000002000] (CPF_Transient)
	int32_t                                            bestPathWeight;                                // 0x0290 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            visitedWeight;                                 // 0x0294 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FInterpCurveFloat                           SplineVelocityOverTime;                        // 0x0298 (0x0018) [0x0000000004400001] (CPF_Edit | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SplineActor");
		}

		return uClassPointer;
	};

	void OnToggleHidden(class USeqAct_ToggleHidden* Action);
	void OnToggle(class USeqAct_Toggle* inAction);
	void GetAllConnectedSplineActors(class TArray<class ASplineActor*>& OutSet);
	bool FindSplinePathTo(class ASplineActor* Goal, class TArray<class ASplineActor*>& OutRoute);
	class ASplineActor* GetBestConnectionInDirection(const struct FVector& DesiredDir, bool optionalBUseLinksFrom);
	class ASplineActor* GetRandomConnection(bool optionalBUseLinksFrom);
	void BreakAllConnectionsFrom();
	void BreakAllConnections();
	void BreakConnectionTo(class ASplineActor* NextActor);
	class ASplineActor* FindTargetForComponent(class USplineComponent* SplineComp);
	class USplineComponent* FindSplineComponentTo(class ASplineActor* NextActor);
	bool IsConnectedTo(class ASplineActor* NextActor, bool bCheckForDisableDestination);
	void AddConnectionTo(class ASplineActor* NextActor);
	void UpdateConnectedSplineComponents(bool bFinish);
	void UpdateSplineComponents();
	struct FVector GetWorldSpaceTangent();
};

// Class Engine.SplineLoftActor
// 0x0060 (0x02B0 - 0x0310)
class ASplineLoftActor : public ASplineActor
{
public:
	float                                              ScaleX;                                        // 0x02B0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ScaleY;                                        // 0x02B4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	class TArray<class USplineMeshComponent*>          SplineMeshComps;                               // 0x02B8 (0x0010) [0x0000000004480008] (CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	class UStaticMesh*                                 DeformMesh;                                    // 0x02C8 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<class UMaterialInterface*>            DeformMeshMaterials;                           // 0x02D0 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	float                                              Roll;                                          // 0x02E0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	struct FVector                                     WorldXDir;                                     // 0x02E4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   Offset;                                        // 0x02F0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bSmoothInterpRollAndScale : 1;                 // 0x02F8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAcceptsLights : 1;                            // 0x02F8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	class UDynamicLightEnvironmentComponent*           MeshLightEnvironment;                          // 0x0300 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	float                                              MeshMaxDrawDistance;                           // 0x0308 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SplineLoftActor");
		}

		return uClassPointer;
	};

	void UpdateSplineParams();
	void ClearLoftMesh();
};

// Class Engine.SplineLoftActorMovable
// 0x0000 (0x0310 - 0x0310)
class ASplineLoftActorMovable : public ASplineLoftActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SplineLoftActorMovable");
		}

		return uClassPointer;
	};

};

// Class Engine.StaticMeshActorBase
// 0x0000 (0x0240 - 0x0240)
class AStaticMeshActorBase : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.StaticMeshActorBase");
		}

		return uClassPointer;
	};

};

// Class Engine.BlockingMeshActor
// 0x0010 (0x0240 - 0x0250)
class ABlockingMeshActor : public AStaticMeshActorBase
{
public:
	struct FPointer                                    VfTable_IIGBXNavMeshObstacle;                  // 0x0240 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class UBlockingMeshComponent*                      BlockingMeshComponent;                         // 0x0248 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BlockingMeshActor");
		}

		return uClassPointer;
	};

};

// Class Engine.BlockingMeshReplicatedActor
// 0x0000 (0x0250 - 0x0250)
class ABlockingMeshReplicatedActor : public ABlockingMeshActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BlockingMeshReplicatedActor");
		}

		return uClassPointer;
	};

};

// Class Engine.DynamicBlockingMeshActor
// 0x0020 (0x0250 - 0x0270)
class ADynamicBlockingMeshActor : public ABlockingMeshActor
{
public:
	struct FPointer                                    VfTable_IIGBXStaticReplicatedActor;            // 0x0250 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	uint32_t                                           bIsEnabled : 1;                                // 0x0258 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FStaticActorReplicationData                 CachedReplicationData;                         // 0x0260 (0x0010) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DynamicBlockingMeshActor");
		}

		return uClassPointer;
	};

	void OnToggle(class USeqAct_Toggle* Action);
};

// Class Engine.BlockingMeshCollectionActor
// 0x0018 (0x0240 - 0x0258)
class ABlockingMeshCollectionActor : public AStaticMeshActorBase
{
public:
	class TArray<class UBlockingMeshComponent*>        BlockingMeshComponents;                        // 0x0240 (0x0010) [0x000000000448000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	int32_t                                            MaxBlockingMeshComponents;                     // 0x0250 (0x0004) [0x0000000000004000] (CPF_Config)  

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BlockingMeshCollectionActor");
		}

		return uClassPointer;
	};

};

// Class Engine.StaticMeshActor
// 0x0008 (0x0240 - 0x0248)
class AStaticMeshActor : public AStaticMeshActorBase
{
public:
	class UStaticMeshComponent*                        StaticMeshComponent;                           // 0x0240 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.StaticMeshActor");
		}

		return uClassPointer;
	};

	void eventPreBeginPlay();
};

// Class Engine.InteractiveFoliageActor
// 0x0088 (0x0248 - 0x02D0)
class AInteractiveFoliageActor : public AStaticMeshActor
{
public:
	class UCylinderComponent*                          CylinderComponent;                             // 0x0248 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FVector                                     TouchingActorEntryPosition;                    // 0x0250 (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     FoliageVelocity;                               // 0x025C (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     FoliageForce;                                  // 0x0268 (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     FoliagePosition;                               // 0x0274 (0x000C) [0x0000000000002000] (CPF_Transient)
	float                                              FoliageDamageImpulseScale;                     // 0x0280 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FoliageTouchImpulseScale;                      // 0x0284 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FoliageStiffness;                              // 0x0288 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FoliageStiffnessQuadratic;                     // 0x028C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FoliageDamping;                                // 0x0290 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxDamageImpulse;                              // 0x0294 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxTouchImpulse;                               // 0x0298 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxForce;                                      // 0x029C (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UAkEvent*                                    FoliageAkEvent;                                // 0x02A0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UAkRtpc*                                     FoliageActivityRTPC;                           // 0x02A8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UAkComponent*                                PooledComponent;                               // 0x02B0 (0x0008) [0x0000000004082008] (CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	float                                              Mass;                                          // 0x02B8 (0x0004) [0x0000000000000000]               
	struct FVector4                                    TouchNormalizedRotationAxisAndAngle;           // 0x02C0 (0x0010) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InteractiveFoliageActor");
		}

		return uClassPointer;
	};

	void eventTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void eventTakeDamage(float Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& HitDirection, class UClass* DamageType, const struct FTraceHitInfo& optionalHitInfo, class UIDamageCauser* optionalDamageCauser, class UDamagePipeline* optionalPipeline);
};

// Class Engine.StaticMeshCollectionActor
// 0x0018 (0x0240 - 0x0258)
class AStaticMeshCollectionActor : public AStaticMeshActorBase
{
public:
	class TArray<class UStaticMeshComponent*>          StaticMeshComponents;                          // 0x0240 (0x0010) [0x000000000448000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	int32_t                                            MaxStaticMeshComponents;                       // 0x0250 (0x0004) [0x0000000000004000] (CPF_Config)  

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.StaticMeshCollectionActor");
		}

		return uClassPointer;
	};

};

// Class Engine.StaticMeshActorBasedOnExtremeContent
// 0x0028 (0x0240 - 0x0268)
class AStaticMeshActorBasedOnExtremeContent : public AActor
{
public:
	class UStaticMeshComponent*                        StaticMeshComponent;                           // 0x0240 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	class TArray<struct FSMMaterialSetterDatum>        ExtremeContent;                                // 0x0248 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FSMMaterialSetterDatum>        NonExtremeContent;                             // 0x0258 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.StaticMeshActorBasedOnExtremeContent");
		}

		return uClassPointer;
	};

	void SetMaterialBasedOnExtremeContent();
	void eventPostBeginPlay();
};

// Class Engine.TeleporterDestination
// 0x0018 (0x0240 - 0x0258)
class ATeleporterDestination : public AActor
{
public:
	class TArray<class AActor*>                        ExitPoints;                                    // 0x0240 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	int32_t                                            ExitPointsCounter;                             // 0x0250 (0x0004) [0x0000000000000000]               
	uint32_t                                           IsEnabled : 1;                                 // 0x0254 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           Resurrect : 1;                                 // 0x0254 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TeleporterDestination");
		}

		return uClassPointer;
	};

	class AActor* GetNextExitPoint(class AActor* TeleportActor);
	void OnToggle(class USeqAct_Toggle* Action);
};

// Class Engine.HoldingAreaDestination
// 0x0000 (0x0258 - 0x0258)
class AHoldingAreaDestination : public ATeleporterDestination
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.HoldingAreaDestination");
		}

		return uClassPointer;
	};

};

// Class Engine.Trigger
// 0x0010 (0x0240 - 0x0250)
class ATrigger : public AActor
{
public:
	class UCylinderComponent*                          CylinderComponent;                             // 0x0240 (0x0008) [0x00000000040A000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline)
	uint32_t                                           bRecentlyTriggered : 1;                        // 0x0248 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              AITriggerDelay;                                // 0x024C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Trigger");
		}

		return uClassPointer;
	};

	void ApplyCheckpointRecord(struct FTriggerCheckpointRecord& Record);
	void CreateCheckpointRecord(struct FTriggerCheckpointRecord& Record);
	bool ShouldSaveForCheckpoint();
	bool StopsProjectile(class AProjectile* P);
	void UnTrigger();
	void NotifyTriggered();
	void eventTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void eventPostBeginPlay();
	void TriggerDetachSprites();
};

// Class Engine.Trigger_Dynamic
// 0x0000 (0x0250 - 0x0250)
class ATrigger_Dynamic : public ATrigger
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Trigger_Dynamic");
		}

		return uClassPointer;
	};

};

// Class Engine.Trigger_PawnsOnly
// 0x0000 (0x0250 - 0x0250)
class ATrigger_PawnsOnly : public ATrigger
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Trigger_PawnsOnly");
		}

		return uClassPointer;
	};

};

// Class Engine.TriggerStreamingLevel
// 0x0010 (0x0250 - 0x0260)
class ATriggerStreamingLevel : public ATrigger
{
public:
	class TArray<struct FLevelStreamingData>           Levels;                                        // 0x0250 (0x0010) [0x0000000004400001] (CPF_Edit | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TriggerStreamingLevel");
		}

		return uClassPointer;
	};

	void eventTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};

// Class Engine.ActorComponent
// 0x0028 (0x0068 - 0x0090)
class UActorComponent : public UComponent
{
public:
	struct FPointer                                    VfTable_IIWorldBody;                           // 0x0068 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIDestroyBehavior;                     // 0x0070 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    Scene;                                         // 0x0078 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class AActor*                                      Owner;                                         // 0x0080 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	uint32_t                                           bAttached : 1;                                 // 0x0088 (0x0004) [0x0000000000003002] [0x00000001] (CPF_Const | CPF_Native | CPF_Transient)
	uint32_t                                           bSkipChildComponentUpdate : 1;                 // 0x0088 (0x0004) [0x0000000000002002] [0x00000002] (CPF_Const | CPF_Transient)
	uint32_t                                           bTickInEditor : 1;                             // 0x0088 (0x0004) [0x0000000000000002] [0x00000004] (CPF_Const)
	uint32_t                                           bTickInGame : 1;                               // 0x0088 (0x0004) [0x0000000000000002] [0x00000008] (CPF_Const)
	uint32_t                                           bTickInStatusMenu : 1;                         // 0x0088 (0x0004) [0x0000000000000002] [0x00000010] (CPF_Const)
	uint32_t                                           bNeedsReattach : 1;                            // 0x0088 (0x0004) [0x0000000000002002] [0x00000020] (CPF_Const | CPF_Transient)
	uint32_t                                           bNeedsUpdateTransform : 1;                     // 0x0088 (0x0004) [0x0000000000002002] [0x00000040] (CPF_Const | CPF_Transient)
	uint32_t                                           bIsPlayerOwned : 1;                            // 0x0088 (0x0004) [0x0000000000002002] [0x00000080] (CPF_Const | CPF_Transient)
	ETickingGroup                                      TickGroup;                                     // 0x008C (0x0001) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorComponent");
		}

		return uClassPointer;
	};

	void Behavior_Destroy();
	bool WorldBodyAttachComponent(class UActorComponent* Attachment, const struct FVector& optionalAttachmentRelativeLocation, const struct FRotator& optionalAttachmentRelativeRotation, const struct FName& optionalAttachmentPointName);
	bool WorldBodyAttachActor(class AActor* Attachment, const struct FVector& optionalAttachmentRelativeLocation, const struct FRotator& optionalAttachmentRelativeRotation, const struct FName& optionalAttachmentPointName);
	bool WorldBodyAttachTo(class UIWorldBody* OtherWorldBody, const struct FVector& optionalAttachmentRelativeLocation, const struct FRotator& optionalAttachmentRelativeRotation, const struct FName& optionalAttachmentPointName);
	class UIWorldBody* GetWorldBodyFirstPersonAttachmentBase();
	class UIWorldBody* GetWorldBodyAttachmentBase();
	struct FName GetWorldBodyAttachmentBoneForComponent(class UActorComponent* AttachedComponent);
	bool GetWorldBodyAttachmentLocationAndRotation(const struct FName& AttachmentPointName, struct FVector& OutLocation, struct FRotator& OutRotation);
	bool GetWorldBodyAttachmentRotation(const struct FName& AttachmentPointName, struct FRotator& OutRotation);
	bool GetWorldBodyAttachmentLocation(const struct FName& AttachmentPointName, struct FVector& OutLocation);
	struct FVector GetWorldBodyVelocity();
	struct FRotator GetWorldBodyRotation();
	struct FVector GetWorldBodyLocation();
	bool IsPlayerOwnedBy(class AActor* PotentialPlayerOwner);
	void SetPlayerOwner(class AActor* NewPlayerOwner);
	void DetachFromAny();
	void ForceUpdate(bool bTransformOnly);
	void SetComponentRBFixed(bool bFixed);
	void SetTickGroup(ETickingGroup NewTickGroup);
};

// Class Engine.AkComponent
// 0x01E0 (0x0090 - 0x0270)
class UAkComponent : public UActorComponent
{
public:
	struct FName                                       SocketName;                                    // 0x0090 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bAbsolutelyPositioned : 1;                     // 0x0098 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bShouldAllSourcesActAsOneSound : 1;            // 0x0098 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bSupportsSecondaryOutput : 1;                  // 0x0098 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bHaveCalculatedInitialOcclusion : 1;           // 0x0098 (0x0004) [0x0000000000002000] [0x00000008] (CPF_Transient)
	uint32_t                                           bRespondsToOcclusionAndEnvironmentalEffects : 1;// 0x0098 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bRegistered : 1;                               // 0x0098 (0x0004) [0x0000000000002000] [0x00000020] (CPF_Transient)
	uint32_t                                           bIsReattaching : 1;                            // 0x0098 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bEnvironmentalEffectsActive : 1;               // 0x0098 (0x0004) [0x0000000000002000] [0x00000080] (CPF_Transient)
	uint32_t                                           bDetachWhenFinished : 1;                       // 0x0098 (0x0004) [0x0000000000002000] [0x00000100] (CPF_Transient)
	class TArray<struct FSoundSourcePosition>          SourcePositions;                               // 0x00A0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FMatrix                                     ComponentTransform;                            // 0x00B0 (0x0040) [0x0000000000000000]               
	EAkComponentType                                   AkComponentType;                               // 0x00F0 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                            FramesUntilNextEnvOccUpdate;                   // 0x00F1 (0x0001) [0x0000000000000000]               
	float                                              LastSubtitleUpdateTime;                        // 0x00F4 (0x0004) [0x0000000000000000]               
	struct FAkPlaybackTrackerList                      PlayingObjects;                                // 0x00F8 (0x0018) [0x0000000000003000] (CPF_Native | CPF_Transient)
	struct FAkOcclusionLevels                          OcclusionLevels;                               // 0x0110 (0x0080) [0x0000000000002000] (CPF_Transient)
	class UISpecialOcclusionProvider*                  SpecialOcclusionProvider_Object;               // 0x0190 (0x0008) [0x0000000000002000] (CPF_Transient)
	class UISpecialOcclusionProvider*                  SpecialOcclusionProvider_Interface;            // 0x0198 (0x0008) [0x0000000000002000] (CPF_Transient)
	class UIAkComponentPositionProvider*               PositionProvider_Object;                       // 0x01A0 (0x0008) [0x0000000000002000] (CPF_Transient)
	class UIAkComponentPositionProvider*               PositionProvider_Interface;                    // 0x01A8 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FAkComponentDebugTracking                   DebugTracking;                                 // 0x01B0 (0x00A0) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class UWorld*                                      PendingAttachToWorldSoundManager;              // 0x0250 (0x0008) [0x0000000000000000]               
	int32_t                                            MixState;                                      // 0x0258 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            PreviousMixState;                              // 0x025C (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FScriptDelegate                             __OnAkEventCompleted__Delegate;                // 0x0260 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkComponent");
		}

		return uClassPointer;
	};

	float GetMaxAttenuationRadius();
	bool IsPlayingId(int32_t InPlayingId);
	bool IsPlayingEvent(class UAkEvent* AkEvent);
	void OnAkEventCompleted(class UAkComponent* Source, class UAkEvent* Event, int32_t EventInstanceId);
	struct FAkPlayingInfo PostEvent(class UAkEvent* in_pEvent, bool optionalIn_bNotifyEventComplete, bool optionalIn_bEnableGetPlaybackPosition, bool optionalIn_bStopWhenOwnerDestroyed);
};

// Class Engine.ComponentLifetimeManagerComponent
// 0x0018 (0x0090 - 0x00A8)
class UComponentLifetimeManagerComponent : public UActorComponent
{
public:
	class TArray<class UActorComponent*>               ManagedComponents;                             // 0x0090 (0x0010) [0x0000000004480008] (CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	float                                              ManagedComponentsLifeSpan;                     // 0x00A0 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ComponentLifetimeManagerComponent");
		}

		return uClassPointer;
	};

	void RemoveManagedComponent(class UActorComponent* ComponentToRemove);
	void AddManagedComponent(class UActorComponent* NewComponent);
};

// Class Engine.ExponentialHeightFogComponent
// 0x0030 (0x0090 - 0x00C0)
class UExponentialHeightFogComponent : public UActorComponent
{
public:
	uint32_t                                           bEnabled : 1;                                  // 0x0090 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bUseFogDirection : 1;                          // 0x0090 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              FogHeight;                                     // 0x0094 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              FogDensity;                                    // 0x0098 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              FogHeightFalloff;                              // 0x009C (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              FogMaxOpacity;                                 // 0x00A0 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              StartDistance;                                 // 0x00A4 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              LightTerminatorAngle;                          // 0x00A8 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              OppositeLightBrightness;                       // 0x00AC (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	struct FColor                                      OppositeLightColor;                            // 0x00B0 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              LightInscatteringBrightness;                   // 0x00B4 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	struct FColor                                      LightInscatteringColor;                        // 0x00B8 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ExponentialHeightFogComponent");
		}

		return uClassPointer;
	};

	void SetEnabled(bool bSetEnabled);
};

// Class Engine.FogVolumeDensityComponent
// 0x0050 (0x0090 - 0x00E0)
class UFogVolumeDensityComponent : public UActorComponent
{
public:
	class UMaterialInterface*                          FogMaterial;                                   // 0x0090 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UMaterialInterface*                          DefaultFogVolumeMaterial;                      // 0x0098 (0x0008) [0x0000000000000000]               
	uint32_t                                           bEnabled : 1;                                  // 0x00A0 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bAffectsTranslucency : 1;                      // 0x00A0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bOnlyAffectsTranslucency : 1;                  // 0x00A0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	struct FLinearColor                                SimpleLightColor;                              // 0x00A4 (0x0010) [0x0000000200000001] (CPF_Edit)    
	struct FLinearColor                                ApproxFogLightColor;                           // 0x00B4 (0x0010) [0x0000000200000001] (CPF_Edit)    
	float                                              StartDistance;                                 // 0x00C4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              MaxDistance;                                   // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<class AActor*>                        FogVolumeActors;                               // 0x00D0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FogVolumeDensityComponent");
		}

		return uClassPointer;
	};

	void SetEnabled(bool bSetEnabled);
};

// Class Engine.FogVolumeConeDensityComponent
// 0x0030 (0x00E0 - 0x0110)
class UFogVolumeConeDensityComponent : public UFogVolumeDensityComponent
{
public:
	float                                              MaxDensity;                                    // 0x00E0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	struct FVector                                     ConeVertex;                                    // 0x00E4 (0x000C) [0x0000000200000001] (CPF_Edit)    
	float                                              ConeRadius;                                    // 0x00F0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	struct FVector                                     ConeAxis;                                      // 0x00F4 (0x000C) [0x0000000200000001] (CPF_Edit)    
	float                                              ConeMaxAngle;                                  // 0x0100 (0x0004) [0x0000000200000001] (CPF_Edit)    
	class UDrawLightConeComponent*                     PreviewCone;                                   // 0x0108 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FogVolumeConeDensityComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.FogVolumeConstantDensityComponent
// 0x0008 (0x00E0 - 0x00E8)
class UFogVolumeConstantDensityComponent : public UFogVolumeDensityComponent
{
public:
	float                                              Density;                                       // 0x00E0 (0x0004) [0x0000000200000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FogVolumeConstantDensityComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.FogVolumeLinearHalfspaceDensityComponent
// 0x0020 (0x00E0 - 0x0100)
class UFogVolumeLinearHalfspaceDensityComponent : public UFogVolumeDensityComponent
{
public:
	float                                              PlaneDistanceFactor;                           // 0x00E0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	uint8_t                                           UnknownData00[0xC];                            // 0x00E4 (0x000C) MISSED OFFSET
	struct FPlane                                      HalfspacePlane;                                // 0x00F0 (0x0010) [0x0000000200000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FogVolumeLinearHalfspaceDensityComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.FogVolumeSphericalDensityComponent
// 0x0020 (0x00E0 - 0x0100)
class UFogVolumeSphericalDensityComponent : public UFogVolumeDensityComponent
{
public:
	float                                              MaxDensity;                                    // 0x00E0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	struct FVector                                     SphereCenter;                                  // 0x00E4 (0x000C) [0x0000000000000000]               
	float                                              SphereRadius;                                  // 0x00F0 (0x0004) [0x0000000000000000]               
	class UDrawLightRadiusComponent*                   PreviewSphereRadius;                           // 0x00F8 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FogVolumeSphericalDensityComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.GearboxCollisionGridComponent
// 0x0048 (0x0090 - 0x00D8)
class UGearboxCollisionGridComponent : public UActorComponent
{
public:
	float                                              Radius;                                        // 0x0090 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              HalfHeight;                                    // 0x0094 (0x0004) [0x0000000000002000] (CPF_Transient)
	uint32_t                                           bUseOwnerCollisionComponent : 1;               // 0x0098 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)
	struct FVector                                     Location;                                      // 0x009C (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     Offset;                                        // 0x00A8 (0x000C) [0x0000000000002000] (CPF_Transient)
	class UGearboxCollisionGrid*                       CollisionGrid;                                 // 0x00B8 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FPointer                                    Node;                                          // 0x00C0 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)
	struct FPointer                                    PrevPtr;                                       // 0x00C8 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)
	struct FPointer                                    Next;                                          // 0x00D0 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GearboxCollisionGridComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.HeadTrackingComponent
// 0x00C8 (0x0090 - 0x0158)
class UHeadTrackingComponent : public UActorComponent
{
public:
	class TArray<struct FName>                         TrackControllerName;                           // 0x0090 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              LookAtActorRadius;                             // 0x00A0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDisableBeyondLimit : 1;                       // 0x00A4 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              MaxLookAtTime;                                 // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MinLookAtTime;                                 // 0x00AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxInterestTime;                               // 0x00B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<class UClass*>                        ActorClassesToLookAt;                          // 0x00B8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FName>                         TargetBoneNames;                               // 0x00C8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint8_t                                           UnknownData00[0x50];                           // 0x00D8 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.HeadTrackingComponent.CurrentActorMap
	class USkeletalMeshComponent*                      SkeletalMeshComp;                              // 0x0128 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	class TArray<class USkelControlLookAt*>            TrackControls;                                 // 0x0130 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	struct FVector                                     RootMeshLocation;                              // 0x0140 (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FRotator                                    RootMeshRotation;                              // 0x014C (0x000C) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.HeadTrackingComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.HeightFogComponent
// 0x0020 (0x0090 - 0x00B0)
class UHeightFogComponent : public UActorComponent
{
public:
	uint32_t                                           bEnabled : 1;                                  // 0x0090 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	float                                              Height;                                        // 0x0094 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              Density;                                       // 0x0098 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              LightBrightness;                               // 0x009C (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	struct FColor                                      LightColor;                                    // 0x00A0 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              ExtinctionDistance;                            // 0x00A4 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              StartDistance;                                 // 0x00A8 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.HeightFogComponent");
		}

		return uClassPointer;
	};

	void SetEnabled(bool bSetEnabled);
};

// Class Engine.LightComponent
// 0x0150 (0x0090 - 0x01E0)
class ULightComponent : public UActorComponent
{
public:
	struct FPointer                                    VfTable_IIAppearanceBehavior;                  // 0x0090 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    SceneInfo;                                     // 0x0098 (0x0008) [0x0000000001003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FMatrix                                     WorldToLight;                                  // 0x00A0 (0x0040) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FMatrix                                     LightToWorld;                                  // 0x00E0 (0x0040) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FMatrix                                     LastProxyLightToWorld;                         // 0x0120 (0x0040) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FGuid                                       LightGuid;                                     // 0x0160 (0x0010) [0x0000000000200002] (CPF_Const)   
	struct FGuid                                       LightmapGuid;                                  // 0x0170 (0x0010) [0x0000000000200002] (CPF_Const)   
	float                                              Brightness;                                    // 0x0180 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	struct FColor                                      LightColor;                                    // 0x0184 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	class ULightFunction*                              Function;                                      // 0x0188 (0x0008) [0x000000000440000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	uint32_t                                           bEnabled : 1;                                  // 0x0190 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           CastShadows : 1;                               // 0x0190 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           CastStaticShadows : 1;                         // 0x0190 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           CastDynamicShadows : 1;                        // 0x0190 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bNonModulatedSelfShadowing : 1;                // 0x0190 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bSelfShadowOnly : 1;                           // 0x0190 (0x0004) [0x0000000200000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bForceDynamicLight : 1;                        // 0x0190 (0x0004) [0x0000000000000002] [0x00000040] (CPF_Const)
	uint32_t                                           UseDirectLightMap : 1;                         // 0x0190 (0x0004) [0x0000000000000002] [0x00000080] (CPF_Const)
	uint32_t                                           bHasLightEverBeenBuiltIntoLightMap : 1;        // 0x0190 (0x0004) [0x0000000000000002] [0x00000100] (CPF_Const)
	uint32_t                                           bCanAffectDynamicPrimitivesOutsideDynamicChannel : 1;// 0x0190 (0x0004) [0x0000000000000002] [0x00000200] (CPF_Const)
	uint32_t                                           bAllowProjectedShadowing : 1;                  // 0x0190 (0x0004) [0x0000000000020002] [0x00000400] (CPF_Const | CPF_EditConst)
	uint32_t                                           bRenderLightShafts : 1;                        // 0x0190 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bAffectsGDPG_World : 1;                        // 0x0190 (0x0004) [0x0000000000002001] [0x00001000] (CPF_Edit | CPF_Transient)
	uint32_t                                           bAffectsGDPG_Foreground : 1;                   // 0x0190 (0x0004) [0x0000000000002001] [0x00002000] (CPF_Edit | CPF_Transient)
	uint32_t                                           bPrecomputedLightingIsValid : 1;               // 0x0190 (0x0004) [0x0000000000000002] [0x00004000] (CPF_Const)
	uint32_t                                           bExplicitlyAssignedLight : 1;                  // 0x0190 (0x0004) [0x0000000000000002] [0x00008000] (CPF_Const)
	uint32_t                                           bAllowCompositingIntoDLE : 1;                  // 0x0190 (0x0004) [0x0000000000000001] [0x00010000] (CPF_Edit)
	class ULightEnvironmentComponent*                  LightEnvironment;                              // 0x0198 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FLightingChannelContainer                   LightingChannels;                              // 0x01A0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ELightAffectsClassification                        LightAffectsClassification;                    // 0x01A4 (0x0001) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	int32_t                                            LightListIndex;                                // 0x01A8 (0x0004) [0x0000000000201002] (CPF_Const | CPF_Native)
	float                                              OcclusionDepthRange;                           // 0x01AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BloomScale;                                    // 0x01B0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              BloomThreshold;                                // 0x01B4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BloomScreenBlendThreshold;                     // 0x01B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FColor                                      BloomTint;                                     // 0x01BC (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              RadialBlurPercent;                             // 0x01C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OcclusionMaskDarkness;                         // 0x01C4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	EGameDepthPriorityGroup                            GameDepthPriorityGroup;                        // 0x01C8 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EGameRenderPhase                                   GameRenderPhase;                               // 0x01C9 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ESceneViewSeeType                                  ViewSeeType;                                   // 0x01CA (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ESceneViewHideViewportType                         ViewHideViewportType;                          // 0x01CB (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint8_t                                            ViewActorFlags;                                // 0x01CC (0x0001) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              TeamIndexForRendering;                         // 0x01D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUseTeamIndexForLightColor : 1;                // 0x01D4 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint8_t                                           UnknownData00[0x8];                            // 0x01D8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LightComponent");
		}

		return uClassPointer;
	};

	void Behavior_ChangeVisibility(bool bVisible);
	void Behavior_ToggleVisibility();
	void OnUpdatePropertyLightColor();
	void OnUpdatePropertyBrightness();
	void OnUpdatePropertyOcclusionMaskDarkness();
	void OnUpdatePropertyBloomTint();
	void OnUpdatePropertyBloomScale();
	void UpdateLightShaftParameters();
	void UpdateColorAndBrightness();
	struct FVector GetDirection();
	struct FVector GetOrigin();
	void SetLightProperties(float optionalNewBrightness, const struct FColor& optionalNewLightColor, class ULightFunction* optionalNewLightFunction);
	void SetGameRenderPhase(EGameRenderPhase NewGameRenderPhase);
	void SetEnabled(bool bSetEnabled);
};

// Class Engine.DirectionalLightComponent
// 0x0030 (0x01E0 - 0x0210)
class UDirectionalLightComponent : public ULightComponent
{
public:
	struct FVector                                     LightShaftDirectionOverride;                   // 0x01E0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              TraceDistance;                                 // 0x01EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WholeSceneDynamicShadowRadius;                 // 0x01F0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	int32_t                                            NumWholeSceneDynamicShadowCascades;            // 0x01F4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FLightmassDirectionalLightSettings          LightmassSettings;                             // 0x01F8 (0x0010) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData00[0x8];                            // 0x0208 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DirectionalLightComponent");
		}

		return uClassPointer;
	};

	void OnUpdatePropertyLightEnv_BouncedLightBrightness();
	void OnUpdatePropertyLightEnv_BouncedModulationColor();
	void OnUpdatePropertyBrightness();
	void OnUpdatePropertyLightColor();
};

// Class Engine.DominantDirectionalLightComponent
// 0x00C0 (0x0210 - 0x02D0)
class UDominantDirectionalLightComponent : public UDirectionalLightComponent
{
public:
	struct FDominantShadowInfo                         DominantLightShadowInfo;                       // 0x0210 (0x00B0) [0x0000000000000002] (CPF_Const)   
	struct FArray_Mirror                               DominantLightShadowMap;                        // 0x02C0 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DominantDirectionalLightComponent");
		}

		return uClassPointer;
	};

	void OnUpdatePropertyTimeOfDaySpecularColor();
	void OnUpdatePropertyTimeOfDaySpecularBrightness();
	void OnUpdatePropertyTimeOfDayDiffuseColor();
	void OnUpdatePropertyTimeOfDayDiffuseBrightness();
};

// Class Engine.PointLightComponent
// 0x0090 (0x01E0 - 0x0270)
class UPointLightComponent : public ULightComponent
{
public:
	float                                              ShadowRadiusMultiplier;                        // 0x01E0 (0x0004) [0x0000000000000000]               
	float                                              Radius;                                        // 0x01E4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              FalloffExponent;                               // 0x01E8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              MinShadowFalloffRadius;                        // 0x01EC (0x0004) [0x0000000000000000]               
	struct FMatrix                                     CachedParentToWorld;                           // 0x01F0 (0x0040) [0x0000000000000002] (CPF_Const)   
	struct FVector                                     Translation;                                   // 0x0230 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UDrawLightRadiusComponent*                   PreviewLightRadius;                            // 0x0240 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              LastProxyRadius;                               // 0x0248 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FLightmassPointLightSettings                LightmassSettings;                             // 0x024C (0x0010) [0x0000000000000001] (CPF_Edit)    
	class UDrawLightRadiusComponent*                   PreviewLightSourceRadius;                      // 0x0260 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	uint8_t                                           UnknownData00[0x8];                            // 0x0268 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PointLightComponent");
		}

		return uClassPointer;
	};

	void OnUpdatePropertyLightEnv_BouncedLightBrightness();
	void OnUpdatePropertyLightEnv_BouncedModulationColor();
	void OnUpdatePropertyRadius();
	void OnUpdatePropertyBrightness();
	void OnUpdatePropertyLightColor();
	void SetTranslation(const struct FVector& NewTranslation);
};

// Class Engine.DominantPointLightComponent
// 0x0000 (0x0270 - 0x0270)
class UDominantPointLightComponent : public UPointLightComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DominantPointLightComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.SpotLightComponent
// 0x0030 (0x0270 - 0x02A0)
class USpotLightComponent : public UPointLightComponent
{
public:
	float                                              InnerConeAngle;                                // 0x0270 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OuterConeAngle;                                // 0x0274 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LightShaftConeAngle;                           // 0x0278 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UDrawLightConeComponent*                     PreviewInnerCone;                              // 0x0280 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	class UDrawLightConeComponent*                     PreviewOuterCone;                              // 0x0288 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FRotator                                    Rotation;                                      // 0x0290 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpotLightComponent");
		}

		return uClassPointer;
	};

	void SetRotation(const struct FRotator& NewRotation);
};

// Class Engine.DominantSpotLightComponent
// 0x00C0 (0x02A0 - 0x0360)
class UDominantSpotLightComponent : public USpotLightComponent
{
public:
	struct FDominantShadowInfo                         DominantLightShadowInfo;                       // 0x02A0 (0x00B0) [0x0000000000000002] (CPF_Const)   
	struct FArray_Mirror                               DominantLightShadowMap;                        // 0x0350 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DominantSpotLightComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.SkyLightComponent
// 0x0010 (0x01E0 - 0x01F0)
class USkyLightComponent : public ULightComponent
{
public:
	float                                              LowerBrightness;                               // 0x01E0 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	struct FColor                                      LowerColor;                                    // 0x01E4 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	uint8_t                                           UnknownData00[0x8];                            // 0x01E8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkyLightComponent");
		}

		return uClassPointer;
	};

	void OnUpdatePropertyLowerBrightness();
	void OnUpdatePropertyLowerColor();
	void OnUpdatePropertyLightEnv_BouncedLightBrightness();
	void OnUpdatePropertyLightEnv_BouncedModulationColor();
	void OnUpdatePropertyBrightness();
	void OnUpdatePropertyLightColor();
};

// Class Engine.SphericalHarmonicLightComponent
// 0x0040 (0x01E0 - 0x0220)
class USphericalHarmonicLightComponent : public ULightComponent
{
public:
	struct FSHVectorRGB2                               WorldSpaceIncidentLighting;                    // 0x01E0 (0x0030) [0x0000000000000001] (CPF_Edit)    
	float                                              DirectionalLightShadowing;                     // 0x0210 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData00[0xC];                            // 0x0214 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SphericalHarmonicLightComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.LightEnvironmentComponent
// 0x0018 (0x0090 - 0x00A8)
class ULightEnvironmentComponent : public UActorComponent
{
public:
	uint32_t                                           bEnabled : 1;                                  // 0x0090 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bAllowDynamicShadowsOnTranslucency : 1;        // 0x0090 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              DominantShadowFactor;                          // 0x0094 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class TArray<class UPrimitiveComponent*>           AffectedComponents;                            // 0x0098 (0x0010) [0x000000000448200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LightEnvironmentComponent");
		}

		return uClassPointer;
	};

	bool IsEnabled();
	void SetEnabled(bool bNewEnabled);
};

// Class Engine.DynamicLightEnvironmentComponent
// 0x0068 (0x00A8 - 0x0110)
class UDynamicLightEnvironmentComponent : public ULightEnvironmentComponent
{
public:
	struct FPointer                                    State;                                         // 0x00A8 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	float                                              InvisibleUpdateTime;                           // 0x00B0 (0x0004) [0x0000000000000000]               
	float                                              MinTimeBetweenFullUpdates;                     // 0x00B4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              VelocityUpdateTimeScale;                       // 0x00B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ShadowInterpolationSpeed;                      // 0x00BC (0x0004) [0x0000000000000000]               
	int32_t                                            NumVolumeVisibilitySamples;                    // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LightingBoundsScale;                           // 0x00C4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FLinearColor                                AmbientGlow;                                   // 0x00C8 (0x0010) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bAffectedBySmallDynamicLights : 1;             // 0x00D8 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bShadowFromEnvironment : 1;                    // 0x00D8 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bDynamic : 1;                                  // 0x00D8 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bRequiresNonLatentUpdates : 1;                 // 0x00D8 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bTraceFromClosestBoundsPoint : 1;              // 0x00D8 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bOverrideOwnerLightingChannels : 1;            // 0x00D8 (0x0004) [0x0000000000000000] [0x00000020] 
	EDynamicLightEnvironmentBoundsMethod               BoundsMethod;                                  // 0x00DC (0x0001) [0x0000000000000000]               
	struct FBoxSphereBounds                            OverriddenBounds;                              // 0x00E0 (0x001C) [0x0000000000000000]               
	struct FLightingChannelContainer                   OverriddenLightingChannels;                    // 0x00FC (0x0004) [0x0000000000000000]               
	class TArray<class ULightComponent*>               OverriddenLightComponents;                     // 0x0100 (0x0010) [0x000000000448000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DynamicLightEnvironmentComponent");
		}

		return uClassPointer;
	};

	void ResetEnvironment();
};

// Class Engine.ParticleLightEnvironmentComponent
// 0x0020 (0x0110 - 0x0130)
class UParticleLightEnvironmentComponent : public UDynamicLightEnvironmentComponent
{
public:
	int32_t                                            ReferenceCount;                                // 0x0110 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            NumPooledReuses;                               // 0x0114 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class AActor*                                      SharedInstigator;                              // 0x0118 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class UParticleSystem*                             SharedParticleSystem;                          // 0x0120 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	uint32_t                                           bAllowDLESharing : 1;                          // 0x0128 (0x0004) [0x0000000000000000] [0x00000001] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleLightEnvironmentComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.PrimitiveComponent
// 0x02D0 (0x0090 - 0x0360)
class UPrimitiveComponent : public UActorComponent
{
public:
	struct FPointer                                    VfTable_IIAppearanceBehavior;                  // 0x0090 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIScaleBehavior;                       // 0x0098 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIChangeCollisionBehavior;             // 0x00A0 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	int32_t                                            Tag;                                           // 0x00A8 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FBoxSphereBounds                            Bounds;                                        // 0x00AC (0x001C) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    SceneInfo;                                     // 0x00C8 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            DetachFence;                                   // 0x00D0 (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)
	float                                              _LocalToWorldDeterminant;                      // 0x00D4 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint8_t                                           UnknownData00[0x8];                            // 0x00D8 (0x0008) MISSED OFFSET
	struct FMatrix                                     _LocalToWorld;                                 // 0x00E0 (0x0040) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FMatrix                                     _WorldToLocal;                                 // 0x0120 (0x0040) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FMatrix                                     LastProxyLocalToWorld;                         // 0x0160 (0x0040) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FBoxSphereBounds                            LastProxyBounds;                               // 0x01A0 (0x001C) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	float                                              TeamIndexForRendering;                         // 0x01BC (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MotionBlurInfoIndex;                           // 0x01C0 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FSharedPtr_Mirror>             DecalList;                                     // 0x01C8 (0x0010) [0x0000000001001002] (CPF_Const | CPF_Native)
	class TArray<class UDecalComponent*>               DecalsToReattach;                              // 0x01D8 (0x0010) [0x000000000448200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	class UFogVolumeDensityComponent*                  FogVolumeComponent;                            // 0x01E8 (0x0008) [0x000000000408200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	class ULightComponent*                             OverrideLightComponent;                        // 0x01F0 (0x0008) [0x000000000408200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	class UTextureCube*                                CurrentEnvMapTexture;                          // 0x01F8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FVector                                     LocalEnvMapLerpCenter;                         // 0x0200 (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FVector                                     LocalEnvMapLerpExtents;                        // 0x020C (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              LocalEnvMapLerpWidth;                          // 0x0218 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class UTextureCube*                                PreviousEnvMapTexture;                         // 0x0220 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class ULightEnvironmentComponent*                  LightEnvironment;                              // 0x0228 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	class ULightEnvironmentComponent*                  PreviousLightEnvironment;                      // 0x0230 (0x0008) [0x000000000408200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	float                                              MinDrawDistance;                               // 0x0238 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxDrawDistance;                               // 0x023C (0x0004) [0x0000000000800003] (CPF_Edit | CPF_Const | CPF_NoExport)
	float                                              CachedMaxDrawDistance;                         // 0x0240 (0x0004) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	float                                              MotionBlurInstanceScale;                       // 0x0244 (0x0004) [0x0000000000000001] (CPF_Edit)    
	ESceneDepthPriorityGroup                           DepthPriorityGroup;                            // 0x0248 (0x0001) [0x0000000000000002] (CPF_Const)   
	EGameDepthPriorityGroup                            GameDepthPriorityGroup;                        // 0x0249 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EGameRenderPhase                                   GameRenderPhase;                               // 0x024A (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EDetailMode                                        DetailMode;                                    // 0x024B (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ERBCollisionChannel                                RBChannel;                                     // 0x024C (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EWeaponCollisionType                               WeaponCollisionType;                           // 0x024D (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint8_t                                            RBDominanceGroup;                              // 0x024E (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                            ScriptRigidBodyCollisionThresholdCompiled;     // 0x024F (0x0001) [0x0000000000000000]               
	uint8_t                                            ViewActorFlags;                                // 0x0250 (0x0001) [0x0000000000002002] (CPF_Const | CPF_Transient)
	ESceneViewSeeType                                  ViewSeeType;                                   // 0x0251 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ESceneViewHideViewportType                         ViewHideViewportType;                          // 0x0252 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            TranslucencySortPriority;                      // 0x0254 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bAllowCullDistanceVolume : 1;                  // 0x0258 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           HiddenGame : 1;                                // 0x0258 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           HiddenEditor : 1;                              // 0x0258 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           bOwnerNoSee : 1;                               // 0x0258 (0x0004) [0x0000000020000002] [0x00000008] (CPF_Const | CPF_Deprecated)
	uint32_t                                           bOnlyOwnerSee : 1;                             // 0x0258 (0x0004) [0x0000000020000002] [0x00000010] (CPF_Const | CPF_Deprecated)
	uint32_t                                           bOnlyPlayerOwnerSee : 1;                       // 0x0258 (0x0004) [0x0000000020000002] [0x00000020] (CPF_Const | CPF_Deprecated)
	uint32_t                                           bPlayerOwnerNoSee : 1;                         // 0x0258 (0x0004) [0x0000000020000002] [0x00000040] (CPF_Const | CPF_Deprecated)
	uint32_t                                           bIgnoreOwnerHidden : 1;                        // 0x0258 (0x0004) [0x0000000000000003] [0x00000080] (CPF_Edit | CPF_Const)
	uint32_t                                           bUseAsOccluder : 1;                            // 0x0258 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bAllowApproximateOcclusion : 1;                // 0x0258 (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bFirstFrameOcclusion : 1;                      // 0x0258 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bIgnoreNearPlaneIntersection : 1;              // 0x0258 (0x0004) [0x0000000000000000] [0x00000800] 
	uint32_t                                           bSelectable : 1;                               // 0x0258 (0x0004) [0x0000000000000000] [0x00001000] 
	uint32_t                                           bForceMipStreaming : 1;                        // 0x0258 (0x0004) [0x0000000000000003] [0x00002000] (CPF_Edit | CPF_Const)
	uint32_t                                           bAcceptsStaticDecals : 1;                      // 0x0258 (0x0004) [0x0000000000000003] [0x00004000] (CPF_Edit | CPF_Const)
	uint32_t                                           bAcceptsDynamicDecals : 1;                     // 0x0258 (0x0004) [0x0000000000000003] [0x00008000] (CPF_Edit | CPF_Const)
	uint32_t                                           bAllowDecalAutomaticReAttach : 1;              // 0x0258 (0x0004) [0x0000000000003000] [0x00010000] (CPF_Native | CPF_Transient)
	uint32_t                                           bAcceptsFoliage : 1;                           // 0x0258 (0x0004) [0x0000000000000003] [0x00020000] (CPF_Edit | CPF_Const)
	uint32_t                                           CastShadow : 1;                                // 0x0258 (0x0004) [0x0000000000000001] [0x00040000] (CPF_Edit)
	uint32_t                                           bForceDirectLightMap : 1;                      // 0x0258 (0x0004) [0x0000000000000002] [0x00080000] (CPF_Const)
	uint32_t                                           bCastDynamicShadow : 1;                        // 0x0258 (0x0004) [0x0000000000000001] [0x00100000] (CPF_Edit)
	uint32_t                                           bCastStaticShadow : 1;                         // 0x0258 (0x0004) [0x0000000000000001] [0x00200000] (CPF_Edit)
	uint32_t                                           bSelfShadowOnly : 1;                           // 0x0258 (0x0004) [0x0000000000000001] [0x00400000] (CPF_Edit)
	uint32_t                                           bCastHiddenShadow : 1;                         // 0x0258 (0x0004) [0x0000000000000001] [0x00800000] (CPF_Edit)
	uint32_t                                           bCastShadowAsTwoSided : 1;                     // 0x0258 (0x0004) [0x0000000000000001] [0x01000000] (CPF_Edit)
	uint32_t                                           bAcceptsLights : 1;                            // 0x0258 (0x0004) [0x0000000000000003] [0x02000000] (CPF_Edit | CPF_Const)
	uint32_t                                           bAcceptsDynamicLights : 1;                     // 0x0258 (0x0004) [0x0000000000000003] [0x04000000] (CPF_Edit | CPF_Const)
	uint32_t                                           bAcceptsSkyLight : 1;                          // 0x0258 (0x0004) [0x0000000000000003] [0x08000000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsePrecomputedShadows : 1;                    // 0x0258 (0x0004) [0x0000000000000003] [0x10000000] (CPF_Edit | CPF_Const)
	uint32_t                                           bInstancedStaticRB : 1;                        // 0x0258 (0x0004) [0x0000000000002002] [0x20000000] (CPF_Const | CPF_Transient)
	uint32_t                                           CollideActors : 1;                             // 0x0258 (0x0004) [0x0000000000000003] [0x40000000] (CPF_Edit | CPF_Const)
	uint32_t                                           AlwaysCheckCollision : 1;                      // 0x0258 (0x0004) [0x0000000000000002] [0x80000000] (CPF_Const)
	uint32_t                                           BlockActors : 1;                               // 0x025C (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           BlockZeroExtent : 1;                           // 0x025C (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           BlockNonZeroExtent : 1;                        // 0x025C (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           CanBlockCamera : 1;                            // 0x025C (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           BlockRigidBody : 1;                            // 0x025C (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	uint32_t                                           bBlockFootPlacement : 1;                       // 0x025C (0x0004) [0x0000000000000003] [0x00000020] (CPF_Edit | CPF_Const)
	uint32_t                                           BulletListener : 1;                            // 0x025C (0x0004) [0x0000000000000003] [0x00000040] (CPF_Edit | CPF_Const)
	uint32_t                                           bIgnorePawnMoves : 1;                          // 0x025C (0x0004) [0x0000000000000003] [0x00000080] (CPF_Edit | CPF_Const)
	uint32_t                                           bSkipRBGeomCreation : 1;                       // 0x025C (0x0004) [0x0000000000000003] [0x00000100] (CPF_Edit | CPF_Const)
	uint32_t                                           bNotifyRigidBodyCollision : 1;                 // 0x025C (0x0004) [0x0000000000000003] [0x00000200] (CPF_Edit | CPF_Const)
	uint32_t                                           bFluidDrain : 1;                               // 0x025C (0x0004) [0x0000000000000003] [0x00000400] (CPF_Edit | CPF_Const)
	uint32_t                                           bFluidTwoWay : 1;                              // 0x025C (0x0004) [0x0000000000000003] [0x00000800] (CPF_Edit | CPF_Const)
	uint32_t                                           bIgnoreRadialImpulse : 1;                      // 0x025C (0x0004) [0x0000000000000001] [0x00001000] (CPF_Edit)
	uint32_t                                           bIgnoreRadialForce : 1;                        // 0x025C (0x0004) [0x0000000000000001] [0x00002000] (CPF_Edit)
	uint32_t                                           bIgnoreForceField : 1;                         // 0x025C (0x0004) [0x0000000000000001] [0x00004000] (CPF_Edit)
	uint32_t                                           bUseCompartment : 1;                           // 0x025C (0x0004) [0x0000000000000003] [0x00008000] (CPF_Edit | CPF_Const)
	uint32_t                                           AlwaysLoadOnClient : 1;                        // 0x025C (0x0004) [0x0000000000000002] [0x00010000] (CPF_Const)
	uint32_t                                           AlwaysLoadOnServer : 1;                        // 0x025C (0x0004) [0x0000000000000002] [0x00020000] (CPF_Const)
	uint32_t                                           bRenderDepthPass : 1;                          // 0x025C (0x0004) [0x0000000000000000] [0x00040000] 
	uint32_t                                           bRenderColorPass : 1;                          // 0x025C (0x0004) [0x0000000000000000] [0x00080000] 
	uint32_t                                           bPrimitiveRequiresOcclusionQuery : 1;          // 0x025C (0x0004) [0x0000000000000000] [0x00100000] 
	uint32_t                                           bUsePercentUnoccludedRequeries : 1;            // 0x025C (0x0004) [0x0000000000000000] [0x00200000] 
	uint32_t                                           bIgnoreHiddenActorsMembership : 1;             // 0x025C (0x0004) [0x0000000000000001] [0x00400000] (CPF_Edit)
	uint32_t                                           AbsoluteTranslation : 1;                       // 0x025C (0x0004) [0x0000000000000003] [0x00800000] (CPF_Edit | CPF_Const)
	uint32_t                                           AbsoluteRotation : 1;                          // 0x025C (0x0004) [0x0000000000000003] [0x01000000] (CPF_Edit | CPF_Const)
	uint32_t                                           AbsoluteScale : 1;                             // 0x025C (0x0004) [0x0000000000000003] [0x02000000] (CPF_Edit | CPF_Const)
	uint32_t                                           bBoundToGFxMovie : 1;                          // 0x025C (0x0004) [0x0000000000002000] [0x04000000] (CPF_Transient)
	uint32_t                                           bWasSNFiltered : 1;                            // 0x025C (0x0004) [0x0000000000003002] [0x08000000] (CPF_Const | CPF_Native | CPF_Transient)
	struct FOctreeArray_Mirror                         OctreeNodes;                                   // 0x0260 (0x0050) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            VisibilityId;                                  // 0x02B0 (0x0004) [0x0000000000200000]               
	struct FLightingChannelContainer                   LightingChannels;                              // 0x02B4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FRBCollisionChannelContainer                RBCollideWithChannels;                         // 0x02B8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UPhysicalMaterial*                           PhysMaterialOverride;                          // 0x02C0 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class URB_BodyInstance*                            BodyInstance;                                  // 0x02C8 (0x0008) [0x0000000000201002] (CPF_Const | CPF_Native)
	struct FMatrix                                     CachedParentToWorld;                           // 0x02D0 (0x0040) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FVector                                     Translation;                                   // 0x0310 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FRotator                                    Rotation;                                      // 0x031C (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              Scale;                                         // 0x0328 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     Scale3D;                                       // 0x032C (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FDouble                                     PrimitiveOriginGameTime;                       // 0x0338 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FDouble                                     PrimitiveOriginRealTime;                       // 0x0340 (0x0008) [0x0000000000002000] (CPF_Transient)
	float                                              BoundsScale;                                   // 0x0348 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LastRenderTime;                                // 0x034C (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FPointer                                    GpuTimer;                                      // 0x0350 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint8_t                                           UnknownData01[0x8];                            // 0x0358 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PrimitiveComponent");
		}

		return uClassPointer;
	};

	void Behavior_ChangeCollisionSize(float NewRadius, float NewHeight);
	void Behavior_ChangeCollision(uint8_t NewCollisionType);
	void Behavior_ChangeScale3D(const struct FVector& InScale3D);
	void Behavior_ChangeScale(float InScale);
	void Behavior_ChangeVisibility(bool bVisible);
	void Behavior_ToggleVisibility();
	EGJKResult ClosestPointOnComponentToComponent(class UPrimitiveComponent*& OtherComponent, struct FVector& PointOnComponentA, struct FVector& PointOnComponentB);
	EGJKResult ClosestPointOnComponentToPoint(struct FVector& POI, struct FVector& Extent, struct FVector& OutPointA, struct FVector& OutPointB);
	struct FRotator GetRotation();
	struct FVector GetPosition();
	void SetAbsolute(bool optionalNewAbsoluteTranslation, bool optionalNewAbsoluteRotation, bool optionalNewAbsoluteScale);
	void SetScale3D(const struct FVector& NewScale3D);
	void SetScale(float NewScale);
	void SetRotation(const struct FRotator& NewRotation);
	void SetTranslation(const struct FVector& NewTranslation);
	void SetActorCollision(bool NewCollideActors, bool NewBlockActors, bool optionalNewAlwaysCheckCollision);
	void SetTraceBlocking(bool NewBlockZeroExtent, bool NewBlockNonZeroExtent);
	void SetForeground(bool bRenderInForeground);
	void SetGameRenderPhase(EGameRenderPhase NewGameRenderPhase);
	void SetLightingChannels(const struct FLightingChannelContainer& NewLightingChannels);
	void SetCullDistance(float NewCullDistance);
	void SetLightEnvironment(class ULightEnvironmentComponent* NewLightEnvironment);
	void SetIgnoreOwnerHidden(bool bNewIgnoreOwnerHidden);
	void SetHidden(bool NewHidden);
	bool ShouldComponentAddToScene();
	void SetRBDominanceGroup(uint8_t InDomGroup);
	class URB_BodyInstance* GetRootBodyInstance();
	class UPhysicalMaterial* GetPhysicalMaterial(bool optionalBSearchArrays);
	void SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial);
	void InitRBPhys();
	void SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision);
	void SetRBChannel(ERBCollisionChannel Channel);
	void SetRBCollisionChannels(const struct FRBCollisionChannelContainer& Channels);
	void SetRBCollidesWithChannel(ERBCollisionChannel Channel, bool bNewCollides);
	void SetBlockRigidBody(bool bNewBlockRigidBody);
	bool RigidBodyIsAwake(const struct FName& optionalBoneName);
	void PutRigidBodyToSleep(const struct FName& optionalBoneName);
	void WakeRigidBody(const struct FName& optionalBoneName);
	void SetRBRotation(const struct FRotator& NewRot, const struct FName& optionalBoneName);
	void SetRBPosition(const struct FVector& NewPos, const struct FName& optionalBoneName);
	void RetardRBLinearVelocity(const struct FVector& RetardDir, float VelScale);
	void SetRBAngularVelocity(const struct FVector& NewAngVel, bool optionalBAddToCurrent);
	void SetRBLinearVelocity(const struct FVector& NewVel, bool optionalBAddToCurrent);
	void AddTorque(const struct FVector& Torque, const struct FName& optionalBoneName);
	void AddRadialForce(const struct FVector& Origin, float Radius, float Strength, ERadialImpulseFalloff Falloff);
	void AddForce(const struct FVector& Force, const struct FVector& optionalPosition, const struct FName& optionalBoneName);
	void AddRadialImpulse(const struct FVector& Origin, float Radius, float Strength, ERadialImpulseFalloff Falloff, bool optionalBVelChange);
	void AddImpulse(const struct FVector& Impulse, const struct FVector& optionalPosition, const struct FName& optionalBoneName, bool optionalBVelChange);
};

// Class Engine.ArrowComponent
// 0x0010 (0x0360 - 0x0370)
class UArrowComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      ArrowColor;                                    // 0x0360 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ArrowSize;                                     // 0x0364 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bTreatAsASprite : 1;                           // 0x0368 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bIsDebugBeacon : 1;                            // 0x0368 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ArrowComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.BrushComponent
// 0x0090 (0x0360 - 0x03F0)
class UBrushComponent : public UPrimitiveComponent
{
public:
	class UModel*                                      Brush;                                         // 0x0360 (0x0008) [0x0000000000000002] (CPF_Const)   
	struct FKAggregateGeom                             BrushAggGeom;                                  // 0x0368 (0x0068) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FPointer                                    BrushPhysDesc;                                 // 0x03D0 (0x0008) [0x0000000000201000] (CPF_Native)  
	struct FPointer                                    CachedPhysBrushData;                           // 0x03D8 (0x0008) [0x0000000001201002] (CPF_Const | CPF_Native)
	int32_t                                            CachedPhysBrushDataVersion;                    // 0x03E0 (0x0004) [0x0000000000000002] (CPF_Const)   
	uint32_t                                           bBlockComplexCollisionTrace : 1;               // 0x03E4 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint8_t                                           UnknownData00[0x8];                            // 0x03E8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BrushComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.CameraConeComponent
// 0x0000 (0x0360 - 0x0360)
class UCameraConeComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CameraConeComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.CoverGroupRenderingComponent
// 0x0000 (0x0360 - 0x0360)
class UCoverGroupRenderingComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CoverGroupRenderingComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.CoverSlotComponent
// 0x0060 (0x0360 - 0x03C0)
class UCoverSlotComponent : public UPrimitiveComponent
{
public:
	class APawn*                                       SlotOwner;                                     // 0x0360 (0x0008) [0x0000000000002000] (CPF_Transient)
	class ACoverLink*                                  CoverLinkOwner;                                // 0x0368 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FVector                                     NearestNavMeshLoc;                             // 0x0370 (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	uint32_t                                           bManualEdit : 1;                               // 0x037C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bCanMantle : 1;                                // 0x037C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bEnabled : 1;                                  // 0x037C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bAllowPopup : 1;                               // 0x037C (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bAllowMantle : 1;                              // 0x037C (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bForceNoGroundAdjust : 1;                      // 0x037C (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bSelected : 1;                                 // 0x037C (0x0004) [0x0000000000002000] [0x00000040] (CPF_Transient)
	uint32_t                                           bFailedToFindSurface : 1;                      // 0x037C (0x0004) [0x0000000000022001] [0x00000080] (CPF_Edit | CPF_Transient | CPF_EditConst)
	ECoverType                                         CoverType;                                     // 0x0380 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ECoverType                                         ForceCoverType;                                // 0x0381 (0x0001) [0x0000000000000001] (CPF_Edit)    
	class TArray<class UCoverTag*>                     SupportedTags;                                 // 0x0388 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class UCoverSlotComponent*                         NextSlot;                                      // 0x0398 (0x0008) [0x0000000004082008] (CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	class UCoverSlotComponent*                         PrevSlot;                                      // 0x03A0 (0x0008) [0x0000000004082008] (CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	class AGBXInfluenceMap*                            InfluenceMap;                                  // 0x03A8 (0x0008) [0x0000200000000000]               
	class TArray<struct FCoverSightData>               SightData;                                     // 0x03B0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CoverSlotComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.CylinderComponent
// 0x0010 (0x0360 - 0x0370)
class UCylinderComponent : public UPrimitiveComponent
{
public:
	float                                              CollisionHeight;                               // 0x0360 (0x0004) [0x000000000000000B] (CPF_Edit | CPF_Const | CPF_ExportObject)
	float                                              CollisionRadius;                               // 0x0364 (0x0004) [0x000000000000000B] (CPF_Edit | CPF_Const | CPF_ExportObject)
	uint32_t                                           bDrawBoundingBox : 1;                          // 0x0368 (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)
	uint32_t                                           bDrawNonColliding : 1;                         // 0x0368 (0x0004) [0x0000000000000002] [0x00000002] (CPF_Const)
	uint32_t                                           bAlwaysRenderIfSelected : 1;                   // 0x0368 (0x0004) [0x0000000000000002] [0x00000004] (CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CylinderComponent");
		}

		return uClassPointer;
	};

	void SetCylinderSize(float NewRadius, float NewHeight);
};

// Class Engine.DecalComponent
// 0x0170 (0x0360 - 0x04D0)
class UDecalComponent : public UPrimitiveComponent
{
public:
	class UMaterialInterface*                          DecalMaterial;                                 // 0x0360 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              Width;                                         // 0x0368 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Height;                                        // 0x036C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TileX;                                         // 0x0370 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TileY;                                         // 0x0374 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OffsetX;                                       // 0x0378 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OffsetY;                                       // 0x037C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DecalRotation;                                 // 0x0380 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              NearPlane;                                     // 0x0384 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FarPlane;                                      // 0x0388 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              PivotOffsetPctX;                               // 0x038C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              PivotOffsetPctY;                               // 0x0390 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Location;                                      // 0x0394 (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FRotator                                    Orientation;                                   // 0x03A0 (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     HitLocation;                                   // 0x03AC (0x000C) [0x0000000000000000]               
	struct FVector                                     HitNormal;                                     // 0x03B8 (0x000C) [0x0000000000000000]               
	struct FVector                                     HitTangent;                                    // 0x03C4 (0x000C) [0x0000000000000000]               
	struct FVector                                     HitBinormal;                                   // 0x03D0 (0x000C) [0x0000000000000000]               
	EDecalMode                                         DecalMode;                                     // 0x03DC (0x0001) [0x0000000000022001] (CPF_Edit | CPF_Transient | CPF_EditConst)
	EDecalTransform                                    DecalTransform;                                // 0x03DD (0x0001) [0x0000000000000000]               
	EFilterMode                                        FilterMode;                                    // 0x03DE (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bNoClip : 1;                                   // 0x03E0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bStaticDecal : 1;                              // 0x03E0 (0x0004) [0x0000000000000002] [0x00000002] (CPF_Const)
	uint32_t                                           bProjectOnBackfaces : 1;                       // 0x03E0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bProjectOnHidden : 1;                          // 0x03E0 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bProjectOnBSP : 1;                             // 0x03E0 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bProjectOnStaticMeshes : 1;                    // 0x03E0 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bProjectOnSkeletalMeshes : 1;                  // 0x03E0 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bProjectOnTerrain : 1;                         // 0x03E0 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bAffectsStaticWorld : 1;                       // 0x03E0 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bAffectsDynamicWorld : 1;                      // 0x03E0 (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bFlipBackfaceDirection : 1;                    // 0x03E0 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bMovableDecal : 1;                             // 0x03E0 (0x0004) [0x0000000000000000] [0x00000800] 
	uint32_t                                           bHasBeenAttached : 1;                          // 0x03E0 (0x0004) [0x0000000000002000] [0x00001000] (CPF_Transient)
	uint32_t                                           bDecalMaterialSetAtRunTime : 1;                // 0x03E0 (0x0004) [0x0000000000000001] [0x00002000] (CPF_Edit)
	class UPrimitiveComponent*                         HitComponent;                                  // 0x03E8 (0x0008) [0x0000000004082008] (CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	struct FName                                       HitBone;                                       // 0x03F0 (0x0008) [0x0000000000002000] (CPF_Transient)
	int32_t                                            HitNodeIndex;                                  // 0x03F8 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            HitLevelIndex;                                 // 0x03FC (0x0004) [0x0000000000002000] (CPF_Transient)
	class TArray<int32_t>                              HitNodeIndices;                                // 0x0400 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FDecalReceiver>                DecalReceivers;                                // 0x0410 (0x0010) [0x0000000001680002] (CPF_Const | CPF_Component | CPF_NeedCtorLink)
	class TArray<struct FPointer>                      StaticReceivers;                               // 0x0420 (0x0010) [0x0000000001203002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    ReleaseResourcesFence;                         // 0x0430 (0x0008) [0x0000000000203002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPlane>                        OrthoPlanes;                                   // 0x0438 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	uint8_t                                           UnknownData00[0x8];                            // 0x0448 (0x0008) MISSED OFFSET
	struct FPlane                                      DecalBasisX;                                   // 0x0450 (0x0010) [0x0000000000002000] (CPF_Transient)
	struct FPlane                                      DecalBasisY;                                   // 0x0460 (0x0010) [0x0000000000002000] (CPF_Transient)
	struct FPlane                                      DecalBasisZ;                                   // 0x0470 (0x0010) [0x0000000000002000] (CPF_Transient)
	float                                              SlopeScaleDepthBias;                           // 0x0480 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            SortOrder;                                     // 0x0484 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BackfaceAngle;                                 // 0x0488 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   BlendRange;                                    // 0x048C (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              StreamingDistanceMultiplier;                   // 0x0494 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<class AActor*>                        Filter;                                        // 0x0498 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UPrimitiveComponent*>           ReceiverImages;                                // 0x04A8 (0x0010) [0x0000000004480009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	struct FVector                                     ParentRelativeLocation;                        // 0x04B8 (0x000C) [0x0000000020000000]  CPF_Deprecated)
	struct FRotator                                    ParentRelativeOrientation;                     // 0x04C4 (0x000C) [0x0000000020000000]  CPF_Deprecated)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DecalComponent");
		}

		return uClassPointer;
	};

	bool IsWaitingForResetToDefaultsToComplete();
	class UMaterialInterface* GetDecalMaterial();
	void SetDecalMaterial(class UMaterialInterface* NewDecalMaterial);
	void ResetToDefaults();
};

// Class Engine.DrawBoxComponent
// 0x0020 (0x0360 - 0x0380)
class UDrawBoxComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      BoxColor;                                      // 0x0360 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UMaterial*                                   BoxMaterial;                                   // 0x0368 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     BoxExtent;                                     // 0x0370 (0x000C) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDrawWireBox : 1;                              // 0x037C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDrawLitBox : 1;                               // 0x037C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bDrawOnlyIfSelected : 1;                       // 0x037C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DrawBoxComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.DrawCapsuleComponent
// 0x0020 (0x0360 - 0x0380)
class UDrawCapsuleComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      CapsuleColor;                                  // 0x0360 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UMaterial*                                   CapsuleMaterial;                               // 0x0368 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              CapsuleHeight;                                 // 0x0370 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CapsuleRadius;                                 // 0x0374 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDrawWireCapsule : 1;                          // 0x0378 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDrawLitCapsule : 1;                           // 0x0378 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bDrawOnlyIfSelected : 1;                       // 0x0378 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DrawCapsuleComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.DrawConeComponent
// 0x0010 (0x0360 - 0x0370)
class UDrawConeComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      ConeColor;                                     // 0x0360 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ConeRadius;                                    // 0x0364 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ConeAngle;                                     // 0x0368 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            ConeSides;                                     // 0x036C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DrawConeComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.DrawLightConeComponent
// 0x0000 (0x0370 - 0x0370)
class UDrawLightConeComponent : public UDrawConeComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DrawLightConeComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.DrawCylinderComponent
// 0x0030 (0x0360 - 0x0390)
class UDrawCylinderComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      CylinderColor;                                 // 0x0360 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UMaterial*                                   CylinderMaterial;                              // 0x0368 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              CylinderRadius;                                // 0x0370 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CylinderTopRadius;                             // 0x0374 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CylinderHeight;                                // 0x0378 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CylinderHeightOffset;                          // 0x037C (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            CylinderSides;                                 // 0x0380 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDrawWireCylinder : 1;                         // 0x0384 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDrawLitCylinder : 1;                          // 0x0384 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bDrawOnlyIfSelected : 1;                       // 0x0384 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint8_t                                           UnknownData00[0x8];                            // 0x0388 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DrawCylinderComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.DrawFrustumComponent
// 0x0020 (0x0360 - 0x0380)
class UDrawFrustumComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      FrustumColor;                                  // 0x0360 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FrustumAngle;                                  // 0x0364 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FrustumAspectRatio;                            // 0x0368 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FrustumStartDist;                              // 0x036C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FrustumEndDist;                                // 0x0370 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData00[0xC];                            // 0x0374 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DrawFrustumComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.DrawQuadComponent
// 0x0010 (0x0360 - 0x0370)
class UDrawQuadComponent : public UPrimitiveComponent
{
public:
	class UTexture*                                    Texture;                                       // 0x0360 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              Width;                                         // 0x0368 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Height;                                        // 0x036C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DrawQuadComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.DrawSphereComponent
// 0x0020 (0x0360 - 0x0380)
class UDrawSphereComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      SphereColor;                                   // 0x0360 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UMaterial*                                   SphereMaterial;                                // 0x0368 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              SphereRadius;                                  // 0x0370 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            SphereSides;                                   // 0x0374 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDrawWireSphere : 1;                           // 0x0378 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDrawLitSphere : 1;                            // 0x0378 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bDrawOnlyIfSelected : 1;                       // 0x0378 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DrawSphereComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.DrawLightRadiusComponent
// 0x0000 (0x0380 - 0x0380)
class UDrawLightRadiusComponent : public UDrawSphereComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DrawLightRadiusComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.DrawPylonRadiusComponent
// 0x0000 (0x0380 - 0x0380)
class UDrawPylonRadiusComponent : public UDrawSphereComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DrawPylonRadiusComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.DrawSoundRadiusComponent
// 0x0000 (0x0380 - 0x0380)
class UDrawSoundRadiusComponent : public UDrawSphereComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DrawSoundRadiusComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.FluidSurfaceComponent
// 0x0010 (0x0360 - 0x0370)
class UFluidSurfaceComponent : public UPrimitiveComponent
{
public:
	struct FLightMapRef                                LightMap;                                      // 0x0360 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	uint8_t                                           UnknownData00[0x8];                            // 0x0368 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FluidSurfaceComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.GBXInfluenceMapRenderingComponent
// 0x0000 (0x0360 - 0x0360)
class UGBXInfluenceMapRenderingComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXInfluenceMapRenderingComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.GBXNavMeshRenderingComponent
// 0x0020 (0x0360 - 0x0380)
class UGBXNavMeshRenderingComponent : public UPrimitiveComponent
{
public:
	uint32_t                                           bDrawPolys : 1;                                // 0x0360 (0x0004) [0x0000000000002001] [0x00000001] (CPF_Edit | CPF_Transient)
	uint32_t                                           bDrawSplitPlanes : 1;                          // 0x0360 (0x0004) [0x0000000000006001] [0x00000002] (CPF_Edit | CPF_Transient | CPF_Config)
	uint32_t                                           bDrawEdgeConnections : 1;                      // 0x0360 (0x0004) [0x0000000000006001] [0x00000004] (CPF_Edit | CPF_Transient | CPF_Config)
	uint32_t                                           bDrawSimplificationConnections : 1;            // 0x0360 (0x0004) [0x0000000000006001] [0x00000008] (CPF_Edit | CPF_Transient | CPF_Config)
	uint32_t                                           bDrawSimplifiedShapes : 1;                     // 0x0360 (0x0004) [0x0000000000006001] [0x00000010] (CPF_Edit | CPF_Transient | CPF_Config)
	uint32_t                                           bDrawFailedSimplificationShapes : 1;           // 0x0360 (0x0004) [0x0000000000006001] [0x00000020] (CPF_Edit | CPF_Transient | CPF_Config)
	uint32_t                                           bDrawFailedTriangulationShapes : 1;            // 0x0360 (0x0004) [0x0000000000006001] [0x00000040] (CPF_Edit | CPF_Transient | CPF_Config)
	uint32_t                                           bDrawBlockedEdges : 1;                         // 0x0360 (0x0004) [0x0000000000006001] [0x00000080] (CPF_Edit | CPF_Transient | CPF_Config)
	uint32_t                                           bDrawSourcePolys : 1;                          // 0x0360 (0x0004) [0x0000000000006001] [0x00000100] (CPF_Edit | CPF_Transient | CPF_Config)
	class TArray<int32_t>                              MeshSpacingHullsToDraw;                        // 0x0368 (0x0010) [0x0000000000402001] (CPF_Edit | CPF_Transient | CPF_NeedCtorLink)
	struct FPointer                                    NavMeshRenderingData;                          // 0x0378 (0x0008) [0x0000000000001000] (CPF_Native)  

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXNavMeshRenderingComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.GearboxCollisionGridRenderingComponent
// 0x0020 (0x0360 - 0x0380)
class UGearboxCollisionGridRenderingComponent : public UPrimitiveComponent
{
public:
	uint32_t                                           bDrawGridLines : 1;                            // 0x0360 (0x0004) [0x0000000000002001] [0x00000001] (CPF_Edit | CPF_Transient)
	uint32_t                                           bDrawActorLocations : 1;                       // 0x0360 (0x0004) [0x0000000000002001] [0x00000002] (CPF_Edit | CPF_Transient)
	struct FPointer                                    CylinderRenderingData;                         // 0x0368 (0x0008) [0x0000000000001000] (CPF_Native)  
	struct FPointer                                    VolumeRenderingData;                           // 0x0370 (0x0008) [0x0000000000001000] (CPF_Native)  
	uint8_t                                           UnknownData00[0x8];                            // 0x0378 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GearboxCollisionGridRenderingComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.LandscapeComponent
// 0x0000 (0x0360 - 0x0360)
class ULandscapeComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LandscapeComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.LandscapeHeightfieldCollisionComponent
// 0x0000 (0x0360 - 0x0360)
class ULandscapeHeightfieldCollisionComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LandscapeHeightfieldCollisionComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.LensFlareComponent
// 0x0070 (0x0360 - 0x03D0)
class ULensFlareComponent : public UPrimitiveComponent
{
public:
	class ULensFlare*                                  Template;                                      // 0x0360 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UDrawLightConeComponent*                     PreviewInnerCone;                              // 0x0368 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	class UDrawLightConeComponent*                     PreviewOuterCone;                              // 0x0370 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	class UDrawLightRadiusComponent*                   PreviewRadius;                                 // 0x0378 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	uint32_t                                           bAutoActivate : 1;                             // 0x0380 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bIsActive : 1;                                 // 0x0380 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	uint32_t                                           bHasTranslucency : 1;                          // 0x0380 (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)
	uint32_t                                           bHasUnlitTranslucency : 1;                     // 0x0380 (0x0004) [0x0000000000002000] [0x00000008] (CPF_Transient)
	uint32_t                                           bHasUnlitDistortion : 1;                       // 0x0380 (0x0004) [0x0000000000002000] [0x00000010] (CPF_Transient)
	uint32_t                                           bUsesSceneColor : 1;                           // 0x0380 (0x0004) [0x0000000000002000] [0x00000020] (CPF_Transient)
	uint32_t                                           bUseTrueConeCalculation : 1;                   // 0x0380 (0x0004) [0x0000000000002000] [0x00000040] (CPF_Transient)
	uint32_t                                           bVisibleForMobile : 1;                         // 0x0380 (0x0004) [0x0000000000000000] [0x00000080] 
	float                                              OuterCone;                                     // 0x0384 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              InnerCone;                                     // 0x0388 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              ConeFudgeFactor;                               // 0x038C (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              Radius;                                        // 0x0390 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              MinStrength;                                   // 0x0394 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FLinearColor                                SourceColor;                                   // 0x0398 (0x0010) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FLensFlareElementMaterials>    Materials;                                     // 0x03A8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	struct FPointer                                    ReleaseResourcesFence;                         // 0x03B8 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	float                                              NextTraceTime;                                 // 0x03C0 (0x0004) [0x0000000000000000]               
	uint8_t                                           UnknownData00[0xC];                            // 0x03C4 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LensFlareComponent");
		}

		return uClassPointer;
	};

	void SetIsActive(bool bInIsActive);
	void SetSourceColor(const struct FLinearColor& InSourceColor);
	void SetTemplate(class ULensFlare* NewTemplate, bool optionalBForceSet);
};

// Class Engine.LevelGridVolumeRenderingComponent
// 0x0000 (0x0360 - 0x0360)
class ULevelGridVolumeRenderingComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LevelGridVolumeRenderingComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.LineBatchComponent
// 0x0040 (0x0360 - 0x03A0)
class ULineBatchComponent : public UPrimitiveComponent
{
public:
	struct FPointer                                    FPrimitiveDrawInterfaceVfTable;                // 0x0360 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    FPrimitiveDrawInterfaceView;                   // 0x0368 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class TArray<struct FPointer>                      BatchedLines;                                  // 0x0370 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      BatchedPoints;                                 // 0x0380 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	float                                              DefaultLifeTime;                               // 0x0390 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint8_t                                           UnknownData00[0xC];                            // 0x0394 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LineBatchComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.MeshBatchComponent
// 0x0060 (0x0360 - 0x03C0)
class UMeshBatchComponent : public UPrimitiveComponent
{
public:
	class TArray<struct FPointer>                      BatchedSpheres;                                // 0x0360 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      BatchedBoxes;                                  // 0x0370 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      BatchedCylinders;                              // 0x0380 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      BatchedCones;                                  // 0x0390 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      BatchedMeshes;                                 // 0x03A0 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	float                                              DefaultLifeTime;                               // 0x03B0 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class UMaterial*                                   DefaultMaterial;                               // 0x03B8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MeshBatchComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.MeshComponent
// 0x0040 (0x0360 - 0x03A0)
class UMeshComponent : public UPrimitiveComponent
{
public:
	struct FPointer                                    VfTable_IIParameterBehavior;                   // 0x0360 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class TArray<class UMaterialInterface*>            Materials;                                     // 0x0368 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FOutlineInfoStruct>            OutlineEffectInfo;                             // 0x0378 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	EOutlineStyle                                      OutlineStyle_Debug;                            // 0x0388 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FLinearColor                                OutlineColor_Debug;                            // 0x038C (0x0010) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           NoOutlines : 1;                                // 0x039C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MeshComponent");
		}

		return uClassPointer;
	};

	class UMaterialInstance* GetInstancedMaterialInstanceConstant(int32_t ElementIndex);
	class UMaterialInstance* CreateAndSetMaterialInstanceConstant(int32_t ElementIndex);
	void Behavior_SetObjectParameterValue(class UObject* Value, int32_t& SectionIndex, struct FName& ParameterName);
	void Behavior_SetFloatParameterValue(int32_t& SectionIndex, struct FName& ParameterName, float& Value);
	void Behavior_SetVectorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FVector& Value);
	void Behavior_SetColorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FLinearColor& Value);
	bool Behavior_GetColorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FLinearColor& OutValue);
	bool Behavior_GetFloatParameterValue(int32_t& SectionIndex, struct FName& ParameterName, float& OutValue);
	bool Behavior_GetObjectParameterValueW(int32_t& SectionIndex, struct FName& ParameterName, class UObject*& OutValue);
	bool Behavior_GetVectorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FVector& OutValue);
	void PrestreamTextures(float Seconds, bool bPrioritizeCharacterTextures, const struct FQWord& CinematicTextureGroups);
	int32_t GetNumElements();
	void SetMaterial(int32_t ElementIndex, class UMaterialInterface* Material);
	class UMaterialInterface* GetMaterial(int32_t ElementIndex);
};

// Class Engine.ApexComponentBase
// 0x0020 (0x03A0 - 0x03C0)
class UApexComponentBase : public UMeshComponent
{
public:
	struct FPointer                                    ComponentBaseResources;                        // 0x03A0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FRenderCommandFence_Mirror                  ReleaseResourcesFence;                         // 0x03A8 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class UApexAsset*                                  Asset;                                         // 0x03B0 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FColor                                      WireframeColor;                                // 0x03B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bAssetChanged : 1;                             // 0x03BC (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ApexComponentBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ApexDynamicComponent
// 0x0010 (0x03C0 - 0x03D0)
class UApexDynamicComponent : public UApexComponentBase
{
public:
	struct FPointer                                    ComponentDynamicResources;                     // 0x03C0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint8_t                                           UnknownData00[0x8];                            // 0x03C8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ApexDynamicComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.ApexStaticComponent
// 0x0000 (0x03C0 - 0x03C0)
class UApexStaticComponent : public UApexComponentBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ApexStaticComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.ApexStaticDestructibleComponent
// 0x0020 (0x03C0 - 0x03E0)
class UApexStaticDestructibleComponent : public UApexStaticComponent
{
public:
	float                                              SleepEnergyThreshold;                          // 0x03C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SleepDamping;                                  // 0x03C4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    ApexDestructibleActor;                         // 0x03C8 (0x0008) [0x0000000000201000] (CPF_Native)  
	struct FPointer                                    ApexDestructiblePreview;                       // 0x03D0 (0x0008) [0x0000000000201000] (CPF_Native)  
	uint32_t                                           bIsThumbnailComponent : 1;                     // 0x03D8 (0x0004) [0x0000000000001000] [0x00000001] (CPF_Native)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ApexStaticDestructibleComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.SkeletalMeshComponent
// 0x05E0 (0x03A0 - 0x0980)
class USkeletalMeshComponent : public UMeshComponent
{
public:
	struct FPointer                                    VfTable_IIAnimBehavior;                        // 0x03A0 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_FSkeletalPoseProvider;                 // 0x03A8 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class USkeletalMesh*                               SkeletalMesh;                                  // 0x03B0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class USkeletalMeshComponent*                      AttachedToSkelComponent;                       // 0x03B8 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FGestaltDataContainer                       GestaltData;                                   // 0x03C0 (0x0060) [0x0000000000420001] (CPF_Edit | CPF_EditConst | CPF_NeedCtorLink)
	class UAnimTree*                                   AnimTreeTemplate;                              // 0x0420 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UAnimNode*                                   Animations;                                    // 0x0428 (0x0008) [0x000000000440000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UAnimNode*>                     AnimTickArray;                                 // 0x0430 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<class UAnimNode*>                     AnimAlwaysTickArray;                           // 0x0440 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<int32_t>                              AnimTickRelevancyArray;                        // 0x0450 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<float>                                AnimTickWeightsArray;                          // 0x0460 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<class USkelControlBase*>              SkelControlTickArray;                          // 0x0470 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class UPhysicsAsset*                               PhysicsAsset;                                  // 0x0480 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UPhysicsAssetInstance*                       PhysicsAssetInstance;                          // 0x0488 (0x0008) [0x000000000440200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_NeedCtorLink | CPF_EditInline)
	struct FPointer                                    ApexClothing;                                  // 0x0490 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    ApexClothingAsyncUpdateData;                   // 0x0498 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	float                                              PhysicsWeight;                                 // 0x04A0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              GlobalAnimRateScale;                           // 0x04A4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StreamingDistanceMultiplier;                   // 0x04A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    MeshObject;                                    // 0x04B0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FBoneAtom>                     SpaceBases;                                    // 0x04B8 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    PrevSpaceBases;                                // 0x04C8 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)
	class TArray<struct FBoneAtom>                     LocalAtoms;                                    // 0x04D0 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FBoneAtom>                     CachedLocalAtoms;                              // 0x04E0 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FBoneAtom>                     CachedSpaceBases;                              // 0x04F0 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            LowUpdateFrameRate;                            // 0x0500 (0x0004) [0x0000000000044002] (CPF_Const | CPF_Config | CPF_GlobalConfig)
	class TArray<uint8_t>                              RequiredBones;                                 // 0x0508 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<uint8_t>                              PxBones;                                       // 0x0518 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<uint8_t>                              ComposeOrderedRequiredBones;                   // 0x0528 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class USkeletalMeshComponent*                      ParentAnimComponent;                           // 0x0538 (0x0008) [0x000000000408000B] (CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	class TArray<int32_t>                              ParentBoneMap;                                 // 0x0540 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<class UAnimSet*>                      AnimSets;                                      // 0x0550 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UAnimSet*>                      TemporarySavedAnimSets;                        // 0x0560 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<class UMorphTargetSet*>               MorphSets;                                     // 0x0570 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FActiveMorph>                  ActiveMorphs;                                  // 0x0580 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FActiveMorph>                  ActiveCurveMorphs;                             // 0x0590 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	uint8_t                                           UnknownData00[0x50];                           // 0x05A0 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.SkeletalMeshComponent.MorphTargetIndexMap
	class TArray<struct FAttachment>                   Attachments;                                   // 0x05F0 (0x0010) [0x0000000000680002] (CPF_Const | CPF_Component | CPF_NeedCtorLink)
	class TArray<uint8_t>                              SkelControlIndex;                              // 0x0600 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<uint8_t>                              PostPhysSkelControlIndex;                      // 0x0610 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	int32_t                                            ForcedLodModel;                                // 0x0620 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MinLodModel;                                   // 0x0624 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            PredictedLODLevel;                             // 0x0628 (0x0004) [0x0000000000000000]               
	int32_t                                            OldPredictedLODLevel;                          // 0x062C (0x0004) [0x0000000000000000]               
	float                                              AnimationLODDistanceFactor;                    // 0x0630 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            AnimationLODFrameRate;                         // 0x0634 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxDistanceFactor;                             // 0x0638 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            bForceWireframe;                               // 0x063C (0x0004) [0x0000000000000000]               
	int32_t                                            bForceRefpose;                                 // 0x0640 (0x0004) [0x0000000000000000]               
	int32_t                                            bOldForceRefPose;                              // 0x0644 (0x0004) [0x0000000000000000]               
	uint32_t                                           bNoSkeletonUpdate : 1;                         // 0x0648 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bForceFrameZero : 1;                           // 0x0648 (0x0004) [0x0000000000000000] [0x00000002] 
	int32_t                                            bDisplayBones;                                 // 0x064C (0x0004) [0x0000000000000000]               
	int32_t                                            bShowPrePhysBones;                             // 0x0650 (0x0004) [0x0000000000000000]               
	int32_t                                            bHideSkin;                                     // 0x0654 (0x0004) [0x0000000000000000]               
	int32_t                                            bForceRawOffset;                               // 0x0658 (0x0004) [0x0000000000000000]               
	int32_t                                            bIgnoreControllers;                            // 0x065C (0x0004) [0x0000000000000000]               
	int32_t                                            bTransformFromAnimParent;                      // 0x0660 (0x0004) [0x0000000000000000]               
	int32_t                                            TickTag;                                       // 0x0664 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            InitTag;                                       // 0x0668 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            CachedAtomsTag;                                // 0x066C (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            bUseSingleBodyPhysics;                         // 0x0670 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            bRequiredBonesUpToDate;                        // 0x0674 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              MinDistFactorForKinematicUpdate;               // 0x0678 (0x0004) [0x0000000000000000]               
	int32_t                                            FramesPhysicsAsleep;                           // 0x067C (0x0004) [0x0000000000002000] (CPF_Transient)
	uint32_t                                           bHasValidBodies : 1;                           // 0x0680 (0x0004) [0x0000000000002002] [0x00000001] (CPF_Const | CPF_Transient)
	uint32_t                                           bSkipAllUpdateWhenPhysicsAsleep : 1;           // 0x0680 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bComponentUseFixedSkelBounds : 1;              // 0x0680 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bUseBoundsFromParentAnimComponent : 1;         // 0x0680 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bDoKinematicUpdatePostPose : 1;                // 0x0680 (0x0004) [0x0000000000002000] [0x00000010] (CPF_Transient)
	uint32_t                                           bConsiderAllBodiesForBounds : 1;               // 0x0680 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bUpdateSkelWhenNotRendered : 1;                // 0x0680 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bIgnoreControllersWhenNotRendered : 1;         // 0x0680 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bTickAnimNodesWhenNotRendered : 1;             // 0x0680 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bNotUpdatingKinematicDueToDistance : 1;        // 0x0680 (0x0004) [0x0000000000000002] [0x00000200] (CPF_Const)
	uint32_t                                           bForceKinematicBoneUpdating : 1;               // 0x0680 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bForceTeleportNextPhysicsUpdate : 1;           // 0x0680 (0x0004) [0x0000000000000000] [0x00000800] 
	uint32_t                                           bForceDiscardRootMotion : 1;                   // 0x0680 (0x0004) [0x0000000000000001] [0x00001000] (CPF_Edit)
	uint32_t                                           bNotifyRootMotionProcessed : 1;                // 0x0680 (0x0004) [0x0000000000000001] [0x00002000] (CPF_Edit)
	uint32_t                                           bDisableRootMotion : 1;                        // 0x0680 (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bRootMotionModeChangeNotify : 1;               // 0x0680 (0x0004) [0x0000000000000000] [0x00008000] 
	uint32_t                                           bRootMotionExtractedNotify : 1;                // 0x0680 (0x0004) [0x0000000000000000] [0x00010000] 
	uint32_t                                           bProcessingRootMotion : 1;                     // 0x0680 (0x0004) [0x0000000000002000] [0x00020000] (CPF_Transient)
	uint32_t                                           bDisableFaceFXMaterialInstanceCreation : 1;    // 0x0680 (0x0004) [0x0000000000000001] [0x00040000] (CPF_Edit)
	uint32_t                                           bDisableFaceFX : 1;                            // 0x0680 (0x0004) [0x0000000000000001] [0x00080000] (CPF_Edit)
	uint32_t                                           bAnimTreeInitialised : 1;                      // 0x0680 (0x0004) [0x0000000000002002] [0x00100000] (CPF_Const | CPF_Transient)
	uint32_t                                           bForceMeshObjectUpdate : 1;                    // 0x0680 (0x0004) [0x0000000000002000] [0x00200000] (CPF_Transient)
	uint32_t                                           bHasPhysicsAssetInstance : 1;                  // 0x0680 (0x0004) [0x0000000000000003] [0x00400000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUpdateKinematicBonesFromAnimation : 1;        // 0x0680 (0x0004) [0x0000000000000001] [0x00800000] (CPF_Edit)
	uint32_t                                           bUpdateJointsFromAnimation : 1;                // 0x0680 (0x0004) [0x0000000000000001] [0x01000000] (CPF_Edit)
	uint32_t                                           bSkelCompFixed : 1;                            // 0x0680 (0x0004) [0x0000000000000002] [0x02000000] (CPF_Const)
	uint32_t                                           bHasHadPhysicsBlendedIn : 1;                   // 0x0680 (0x0004) [0x0000000000000002] [0x04000000] (CPF_Const)
	uint32_t                                           bForceUpdateAttachmentsInTick : 1;             // 0x0680 (0x0004) [0x0000000000000001] [0x08000000] (CPF_Edit)
	uint32_t                                           bPerBoneVolumeEffects : 1;                     // 0x0680 (0x0004) [0x0000000000000001] [0x10000000] (CPF_Edit)
	uint32_t                                           bPerBoneMotionBlur : 1;                        // 0x0680 (0x0004) [0x0000000000000001] [0x20000000] (CPF_Edit)
	uint32_t                                           bSyncActorLocationToRootRigidBody : 1;         // 0x0680 (0x0004) [0x0000000000000001] [0x40000000] (CPF_Edit)
	uint32_t                                           bUseRawData : 1;                               // 0x0680 (0x0004) [0x0000000000000002] [0x80000000] (CPF_Const)
	uint32_t                                           bDisableWarningWhenAnimNotFound : 1;           // 0x0684 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bOverrideAttachmentOwnerVisibility : 1;        // 0x0684 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bPauseAnims : 1;                               // 0x0684 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bChartDistanceFactor : 1;                      // 0x0684 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bEnableLineCheckWithBounds : 1;                // 0x0684 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bCanHighlightSelectedSections : 1;             // 0x0684 (0x0004) [0x0000000000002000] [0x00000020] (CPF_Transient)
	uint32_t                                           bIgnorePitchRollForRootRotation : 1;           // 0x0684 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bIgnoredByFXCoordinator : 1;                   // 0x0684 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bSkipUpdateSkelPose : 1;                       // 0x0684 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bForceNonThreadedSkelUpdate : 1;               // 0x0684 (0x0004) [0x0000000000002000] [0x00000200] (CPF_Transient)
	uint32_t                                           bWaitingForThreadedAnimResults : 1;            // 0x0684 (0x0004) [0x0000000000002000] [0x00000400] (CPF_Transient)
	int32_t                                            ThreadedPosingStatus;                          // 0x0688 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     LineCheckBoundsScale;                          // 0x068C (0x000C) [0x0000000000000000]               
	uint32_t                                           bEnableClothSimulation : 1;                    // 0x0698 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bDisableClothCollision : 1;                    // 0x0698 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           bClothFrozen : 1;                              // 0x0698 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           bAutoFreezeClothWhenNotRendered : 1;           // 0x0698 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bClothAwakeOnStartup : 1;                      // 0x0698 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bClothBaseVelClamp : 1;                        // 0x0698 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bClothBaseVelInterp : 1;                       // 0x0698 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bAttachClothVertsToBaseBody : 1;               // 0x0698 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bIsClothOnStaticObject : 1;                    // 0x0698 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bUpdatedFixedClothVerts : 1;                   // 0x0698 (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bClothPositionalDampening : 1;                 // 0x0698 (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	uint32_t                                           bClothWindRelativeToOwner : 1;                 // 0x0698 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bRecentlyRendered : 1;                         // 0x0698 (0x0004) [0x0000000000002000] [0x00001000] (CPF_Transient)
	uint32_t                                           bCacheAnimSequenceNodes : 1;                   // 0x0698 (0x0004) [0x0000000000000000] [0x00002000] 
	uint32_t                                           bIsGestaltAccessoryMesh : 1;                   // 0x0698 (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bNeedsInstanceWeightUpdate : 1;                // 0x0698 (0x0004) [0x0000000000002002] [0x00008000] (CPF_Const | CPF_Transient)
	uint32_t                                           bAlwaysUseInstanceWeights : 1;                 // 0x0698 (0x0004) [0x0000000000002002] [0x00010000] (CPF_Const | CPF_Transient)
	uint32_t                                           bUpdateComposeSkeletonPasses : 1;              // 0x0698 (0x0004) [0x0000000000002002] [0x00020000] (CPF_Const | CPF_Transient)
	uint32_t                                           bValidTemporarySavedAnimSets : 1;              // 0x0698 (0x0004) [0x0000000000003002] [0x00040000] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FBonePair>                     InstanceVertexWeightBones;                     // 0x06A0 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FSkelMeshComponentLODInfo>     LODInfo;                                       // 0x06B0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	struct FVector                                     FrozenLocalToWorldPos;                         // 0x06C0 (0x000C) [0x0000000000000002] (CPF_Const)   
	struct FRotator                                    FrozenLocalToWorldRot;                         // 0x06CC (0x000C) [0x0000000000000002] (CPF_Const)   
	struct FVector                                     ClothExternalForce;                            // 0x06D8 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     ClothWind;                                     // 0x06E4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     ClothBaseVelClampRange;                        // 0x06F0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              ClothBlendWeight;                              // 0x06FC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ClothDynamicBlendWeight;                       // 0x0700 (0x0004) [0x0000000000000000]               
	float                                              ClothBlendMinDistanceFactor;                   // 0x0704 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ClothBlendMaxDistanceFactor;                   // 0x0708 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MinPosDampRange;                               // 0x070C (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MaxPosDampRange;                               // 0x0718 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MinPosDampScale;                               // 0x0724 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MaxPosDampScale;                               // 0x0730 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    ClothSim;                                      // 0x0740 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            SceneIndex;                                    // 0x0748 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FVector>                       ClothMeshPosData;                              // 0x0750 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FVector>                       ClothMeshNormalData;                           // 0x0760 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<int32_t>                              ClothMeshIndexData;                            // 0x0770 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	int32_t                                            NumClothMeshVerts;                             // 0x0780 (0x0004) [0x0000000000000000]               
	int32_t                                            NumClothMeshIndices;                           // 0x0784 (0x0004) [0x0000000000000000]               
	class TArray<int32_t>                              ClothMeshParentData;                           // 0x0788 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	int32_t                                            NumClothMeshParentIndices;                     // 0x0798 (0x0004) [0x0000000000000000]               
	int32_t                                            LastClothHitVertexId;                          // 0x079C (0x0004) [0x0000000000000000]               
	class TArray<struct FVector>                       ClothMeshWeldedPosData;                        // 0x07A0 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FVector>                       ClothMeshWeldedNormalData;                     // 0x07B0 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<int32_t>                              ClothMeshWeldedIndexData;                      // 0x07C0 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            ClothDirtyBufferFlag;                          // 0x07D0 (0x0004) [0x0000000000000000]               
	ERBCollisionChannel                                ClothRBChannel;                                // 0x07D4 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FRBCollisionChannelContainer                ClothRBCollideWithChannels;                    // 0x07D8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothForceScale;                               // 0x07DC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothImpulseScale;                             // 0x07E0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ClothAttachmentTearFactor;                     // 0x07E4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bClothUseCompartment : 1;                      // 0x07E8 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	float                                              MinDistanceForClothReset;                      // 0x07EC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     LastClothLocation;                             // 0x07F0 (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	ERBCollisionChannel                                ApexClothingRBChannel;                         // 0x07FC (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FRBCollisionChannelContainer                ApexClothingRBCollideWithChannels;             // 0x0800 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ERBCollisionChannel                                ApexClothingCollisionRBChannel;                // 0x0804 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bAutoFreezeApexClothingWhenNotRendered : 1;    // 0x0808 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bLocalSpaceWind : 1;                           // 0x0808 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	struct FVector                                     WindVelocity;                                  // 0x080C (0x000C) [0x0000000200000001] (CPF_Edit)    
	float                                              WindVelocityBlendTime;                         // 0x0818 (0x0004) [0x0000000200000001] (CPF_Edit)    
	uint32_t                                           bSkipInitClothing : 1;                         // 0x081C (0x0004) [0x0000000000002002] [0x00000001] (CPF_Const | CPF_Transient)
	struct FPointer                                    SoftBodySim;                                   // 0x0820 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            SoftBodySceneIndex;                            // 0x0828 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint32_t                                           bEnableSoftBodySimulation : 1;                 // 0x082C (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	class TArray<struct FVector>                       SoftBodyTetraPosData;                          // 0x0830 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<int32_t>                              SoftBodyTetraIndexData;                        // 0x0840 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	int32_t                                            NumSoftBodyTetraVerts;                         // 0x0850 (0x0004) [0x0000000000000000]               
	int32_t                                            NumSoftBodyTetraIndices;                       // 0x0854 (0x0004) [0x0000000000000000]               
	float                                              SoftBodyImpulseScale;                          // 0x0858 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bSoftBodyFrozen : 1;                           // 0x085C (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bAutoFreezeSoftBodyWhenNotRendered : 1;        // 0x085C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bSoftBodyAwakeOnStartup : 1;                   // 0x085C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bSoftBodyUseCompartment : 1;                   // 0x085C (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	ERBCollisionChannel                                SoftBodyRBChannel;                             // 0x0860 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FRBCollisionChannelContainer                SoftBodyRBCollideWithChannels;                 // 0x0864 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FPointer                                    SoftBodyASVPlane;                              // 0x0868 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class UMaterial*                                   LimitMaterial;                                 // 0x0870 (0x0008) [0x0000000000000000]               
	uint8_t                                           UnknownData01[0x8];                            // 0x0878 (0x0008) MISSED OFFSET
	struct FBoneAtom                                   RootMotionDelta;                               // 0x0880 (0x0020) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     RootMotionVelocity;                            // 0x08A0 (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     RootBoneTranslation;                           // 0x08AC (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FVector                                     RootMotionAccelScale;                          // 0x08B8 (0x000C) [0x0000000000000000]               
	ERootMotionMode                                    RootMotionMode;                                // 0x08C4 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ERootMotionMode                                    PreviousRMM;                                   // 0x08C5 (0x0001) [0x0000000000000002] (CPF_Const)   
	ERootMotionMode                                    PendingRMM;                                    // 0x08C6 (0x0001) [0x0000000000000000]               
	ERootMotionMode                                    OldPendingRMM;                                 // 0x08C7 (0x0001) [0x0000000000000000]               
	int32_t                                            bRMMOneFrameDelay;                             // 0x08C8 (0x0004) [0x0000000000000002] (CPF_Const)   
	ERootMotionRotationMode                            RootMotionRotationMode;                        // 0x08CC (0x0001) [0x0000000000000001] (CPF_Edit)    
	EAnimRotationOnly                                  AnimRotationOnly;                              // 0x08CD (0x0001) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            bRemoveRootBoneScale;                          // 0x08D0 (0x0004) [0x0000000000000002] (CPF_Const)   
	uint32_t                                           bOverrideRootMotionSpace : 1;                  // 0x08D4 (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)
	struct FRotator                                    RootMotionSpace;                               // 0x08D8 (0x000C) [0x0000000000000002] (CPF_Const)   
	EFaceFXBlendMode                                   FaceFXBlendMode;                               // 0x08E4 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    FaceFXActorInstance;                           // 0x08E8 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)
	class TArray<uint8_t>                              BoneVisibilityStates;                          // 0x08F0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class UAkEvent*                                    CachedFaceFxAkEvent;                           // 0x0900 (0x0008) [0x0000000000000000]               
	float                                              FaceFXPlayTime;                                // 0x0908 (0x0004) [0x0000000000000000]               
	struct FAkPlayingInfo                              CachedPlayingInfo;                             // 0x0910 (0x0010) [0x0000000000080000] (CPF_Component)
	class UFaceFXAnimSet*                              PlayingFXAnimSet;                              // 0x0920 (0x0008) [0x0000000000000000]               
	uint8_t                                           UnknownData02[0x8];                            // 0x0928 (0x0008) MISSED OFFSET
	struct FBoneAtom                                   LocalToWorldBoneAtom;                          // 0x0930 (0x0020) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              ProgressiveDrawingFraction;                    // 0x0950 (0x0004) [0x0000000000002000] (CPF_Transient)
	uint8_t                                            CustomSortAlternateIndexMode;                  // 0x0954 (0x0001) [0x0000000000002000] (CPF_Transient)
	uint8_t                                            ViewZeroOffset;                                // 0x0955 (0x0001) [0x0000000000000000]               
	uint8_t                                            ViewOneOffset;                                 // 0x0956 (0x0001) [0x0000000000000000]               
	class UMorphNodeWeight*                            BlendMorphNode;                                // 0x0958 (0x0008) [0x0000000000002000] (CPF_Transient)
	float                                              MorphWeightTarget;                             // 0x0960 (0x0004) [0x0000000000000000]               
	float                                              MorphWeightStart;                              // 0x0964 (0x0004) [0x0000000000000000]               
	float                                              MorphBlendTime;                                // 0x0968 (0x0004) [0x0000000000000000]               
	float                                              MorphBlendCurr;                                // 0x096C (0x0004) [0x0000000000000000]               
	int32_t                                            BoundsUpdatedFrame;                            // 0x0970 (0x0004) [0x0000000000000000]               
	uint8_t                                           UnknownData03[0xC];                            // 0x0974 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkeletalMeshComponent");
		}

		return uClassPointer;
	};

	void Behavior_ChangeBoneVisibility(const struct FName& InBoneName, bool bVisible);
	void Behavior_ToggleBoneVisibility(const struct FName& InBoneName);
	void Behavior_InstanceVertexWeight(const struct FName& InBoneName);
	void SetViewportMaterialOffsets(uint8_t view0, uint8_t view1);
	void SetForceDiscardRootMotion(bool bDiscardRootMotion);
	void Behavior_SetMorphNodeWeight(const struct FName& NodeName, float NewWeight, float optionalWeightBlendTime);
	void SetRootMotionSpaceOverride(bool bInOverrideRootMotionSpace, const struct FRotator& optionalNewRootMotionSpace);
	void SetRemoveRootBoneScale(bool bNewRemoveRootBoneScale);
	bool GetAnimTreeNodes(const struct FName& NodeName, class UClass* optionalNodeClass, class TArray<class UAnimNode*>& AnimNodeList);
	void Behavior_SetSkelControlStrength(const struct FName& SkelControlName, bool bActive);
	struct FRotator GetRotation();
	struct FVector GetPosition();
	void BreakConstraintByIndex(const struct FVector& Impulse, const struct FVector& HitLocation, int32_t ConstraintIndex, bool optionalBVelChange);
	void BreakConstraint(const struct FVector& Impulse, const struct FVector& HitLocation, const struct FName& InBoneName, bool optionalBVelChange);
	void BreakAllConstraints(const struct FVector& Impulse, const struct FVector& HitLocation, bool optionalBVelChange);
	void SkelMeshCompOnParticleSystemFinished(class UParticleSystemComponent* PSC);
	bool eventPlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	bool eventCreateForceField(class UAnimNotify_ForceField* AnimNotifyData);
	void StopAnim();
	void PlayAnim(const struct FName& AnimName, float optionalDuration, bool optionalBLoop, bool optionalBRestartIfAlreadyPlaying, float optionalStartTime, bool optionalBPlayBackwards);
	void Blink(float CloseTime, float OpenTime);
	void ShowMaterialSection(int32_t MaterialID, bool bShow, int32_t LODIndex);
	void UpdateMeshForBrokenConstraints();
	void InitBoneVisibilityStates();
	void UnHideBoneByName(const struct FName& BoneName);
	void HideBoneByName(const struct FName& BoneName, EPhysBodyOp PhysBodyOption);
	bool IsBoneHidden(int32_t BoneIndex);
	void UnHideBone(int32_t BoneIndex);
	void HideBone(int32_t BoneIndex, EPhysBodyOp PhysBodyOption);
	void SetFaceFXRegisterEx(const class FString& RegName, EFaceFXRegOp RegOp, float FirstValue, float FirstInterpDuration, float NextValue, float NextInterpDuration);
	void SetFaceFXRegister(const class FString& RegName, float RegVal, EFaceFXRegOp RegOp, float optionalInterpDuration);
	float GetFaceFXRegister(const class FString& RegName);
	void DeclareFaceFXRegister(const class FString& RegName);
	bool IsPlayingFaceFXAnim();
	void StopFaceFXAnim();
	bool PlayFaceFXAnim(class UFaceFXAnimSet* FaceFXAnimSetRef, const class FString& AnimName, const class FString& GroupName, class UAkEvent* AkEventToPlay, const struct FAkPlayingInfo& optionalAkPlayingInfo);
	void ToggleInstanceVertexWeights(bool bEnable, int32_t LODIdx);
	void UpdateInstanceVertexWeightBones(const class TArray<struct FBonePair>& BonePairs);
	int32_t FindInstanceVertexweightBonePair(const struct FBonePair& Bones);
	void RemoveInstanceVertexWeightBoneParented(const struct FName& BoneName);
	void AddInstanceVertexWeightBoneParented(const struct FName& BoneName, bool optionalBPairWithParent);
	bool GetBonesWithinRadius(const struct FVector& Origin, float Radius, int32_t TraceFlags, class TArray<struct FName>& out_Bones);
	void UpdateAnimations();
	void ForceSkelUpdate();
	void UpdateRBBonesFromSpaceBases(bool bMoveUnfixedBodies, bool bTeleport);
	void SetHasPhysicsAssetInstance(bool bHasInstance, bool optionalBUseCurrentPosition);
	class URB_BodyInstance* FindBodyInstanceNamed(const struct FName& BoneName);
	struct FName FindConstraintBoneName(int32_t ConstraintIndex);
	int32_t FindConstraintIndex(const struct FName& ConstraintName);
	void InitMorphTargets();
	void InitSkelControls();
	void UpdateParentBoneMap();
	void SetParentAnimComponent(class USkeletalMeshComponent* NewParentAnimComp);
	void SetAnimTreeTemplate(class UAnimTree* NewTemplate);
	struct FVector GetClosestCollidingBoneLocation(const struct FVector& TestLocation, bool bCheckZeroExtent, bool bCheckNonZeroExtent);
	struct FName FindClosestBone(const struct FVector& TestLocation, float optionalIgnoreScale, struct FVector& BoneLocation);
	void TransformFromBoneSpace(const struct FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector& OutPosition, struct FRotator& OutRotation);
	void TransformToBoneSpace(const struct FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector& OutPosition, struct FRotator& OutRotation);
	struct FVector GetBoneAxis(const struct FName& BoneName, EAxis Axis);
	struct FVector GetRefPosePosition(int32_t BoneIndex);
	bool BoneIsChildOf(const struct FName& BoneName, const struct FName& ParentBoneName);
	void GetBoneNames(class TArray<struct FName>& BoneNames);
	struct FName GetParentBone(const struct FName& BoneName);
	struct FMatrix GetBoneMatrix(int32_t BoneIndex, int32_t optionalSpace);
	struct FName GetBoneName(int32_t BoneIndex);
	int32_t MatchRefBone(const struct FName& BoneName);
	struct FRotator GetBoneRotation(const struct FName& BoneName);
	struct FVector GetBoneLocationEx(const struct FName& BoneName, int32_t Space, uint8_t& Found);
	struct FVector GetBoneLocation(const struct FName& BoneName, int32_t optionalSpace);
	struct FQuat GetBoneQuaternion(const struct FName& BoneName, int32_t optionalSpace);
	void DrawAnimDebug(class UCanvas* Canvas, const struct FName& StartingPoint);
	class UMorphNodeBase* FindMorphNode(const struct FName& InNodeName);
	class USkelControlBase* FindSkelControl(const struct FName& InControlName);
	class UAnimNode* FindAnimNode(const struct FName& InNodeName);
	class UMorphTarget* FindMorphTarget(const struct FName& MorphTargetName);
	float GetAnimLength(const struct FName& AnimSeqName);
	float GetAnimRateByDuration(const struct FName& AnimSeqName, float Duration);
	void RestoreSavedAnimSets();
	void SaveAnimSets();
	class UAnimSequence* FindAnimSequence(const struct FName& AnimSeqName, bool optionalBReverseSearchOrder);
	void WakeSoftBody();
	void SetSoftBodyFrozen(bool bNewFrozen);
	void UpdateSoftBodyParams();
	void SetClothValidBounds(const struct FVector& ClothValidBoundsMin, const struct FVector& ClothValidBoundsMax);
	void EnableClothValidBounds(bool IfEnableClothValidBounds);
	void AttachClothToCollidingShapes(bool AttatchTwoWay, bool AttachTearable);
	void SetClothVelocity(const struct FVector& VelocityOffSet);
	void SetClothPosition(const struct FVector& ClothOffSet);
	void SetClothSleep(bool IfClothSleep);
	void SetClothThickness(float ClothThickness);
	void SetClothTearFactor(float ClothTearFactor);
	void SetClothStretchingStiffness(float ClothStretchingStiffness);
	void SetClothSolverIterations(int32_t ClothSolverIterations);
	void SetClothSleepLinearVelocity(float ClothSleepLinearVelocity);
	void SetClothPressure(float ClothPressure);
	void SetClothFriction(float ClothFriction);
	void SetClothFlags(int32_t ClothFlags);
	void SetClothDampingCoefficient(float ClothDampingCoefficient);
	void SetClothCollisionResponseCoefficient(float ClothCollisionResponseCoefficient);
	void SetClothBendingStiffness(float ClothBendingStiffness);
	void SetClothAttachmentTearFactor(float ClothAttachTearFactor);
	void SetClothAttachmentResponseCoefficient(float ClothAttachmentResponseCoefficient);
	float GetClothThickness();
	float GetClothTearFactor();
	float GetClothStretchingStiffness();
	int32_t GetClothSolverIterations();
	float GetClothSleepLinearVelocity();
	float GetClothPressure();
	float GetClothFriction();
	int32_t GetClothFlags();
	float GetClothDampingCoefficient();
	float GetClothCollisionResponseCoefficient();
	float GetClothBendingStiffness();
	float GetClothAttachmentTearFactor();
	float GetClothAttachmentResponseCoefficient();
	void ForceApexClothingTeleport();
	void ForceApexClothingTeleportAndReset();
	void AddImpulseAtClothPos(const struct FVector& Position, const struct FVector& Impulse, float Radius);
	void ResetClothVertsToRefPose();
	void SetAttachClothVertsToBaseBody(bool bAttachVerts);
	void SetClothExternalForce(const struct FVector& InForce);
	void UpdateClothParams();
	void SetEnableClothingSimulation(bool bInEnable);
	void SetClothFrozen(bool bNewFrozen);
	void SetEnableClothSimulation(bool bInEnable);
	void SetForceRefPose(bool bNewForceRefPose);
	void SetPhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool optionalBForceReInit);
	void InitGestaltMeshDataFromOther(class USkeletalMeshComponent* ComponentToCopyFrom);
	void SetSkeletalMesh(class USkeletalMesh* NewMesh, bool optionalBKeepSpaceBases);
	struct FMatrix GetTransformMatrix();
	bool IsComponentAttachedToAny(class UActorComponent* Component, bool optionalBSearchChildren);
	bool IsComponentAttached(class UActorComponent* Component, const struct FName& optionalBoneName);
	class UActorComponent* FindComponentAttachedToBone(const struct FName& InBoneName);
	struct FName GetSocketBoneName(const struct FName& InSocketName);
	class USkeletalMeshSocket* GetSocketByName(const struct FName& InSocketName);
	bool GetBoneOrSocketMeshDeltaTransform(const struct FName& AnimSeqName, const struct FName& InBoneOrSocketName, float StartOffset, float EndOffset, struct FVector& OutDeltaLocation, struct FRotator& OutDeltaRotation);
	bool GetBoneOrSocketMeshTransformAtTime(const struct FName& AnimSeqName, float FrameTime, const struct FName& InBoneOrSocketName, struct FVector& OutLocation, struct FRotator& OutRotation);
	bool GetSocketWorldLocationAndRotation(const struct FName& InSocketName, int32_t optionalSpace, struct FVector& OutLocation, struct FRotator& OutRotation);
	void AttachComponentToSocket(class UActorComponent* Component, const struct FName& SocketName);
	void DetachComponent(class UActorComponent* Component);
	void AttachComponent(class UActorComponent* Component, const struct FName& BoneName, const struct FVector& optionalRelativeLocation, const struct FRotator& optionalRelativeRotation, const struct FVector& optionalRelativeScale);
};

// Class Engine.StaticMeshComponent
// 0x0070 (0x03A0 - 0x0410)
class UStaticMeshComponent : public UMeshComponent
{
public:
	struct FPointer                                    VfTable_FStaticMeshTransformProvider;          // 0x03A0 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class UStaticMesh*                                 StaticMesh;                                    // 0x03A8 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bOverrideWireframeColor : 1;                   // 0x03B0 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              OverriddenLODMaxRange;                         // 0x03B4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StreamingDistanceMultiplier;                   // 0x03B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUseSubDivisions : 1;                          // 0x03BC (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)
	uint32_t                                           bForceStaticDecals : 1;                        // 0x03BC (0x0004) [0x0000000000002002] [0x00000002] (CPF_Const | CPF_Transient)
	uint32_t                                           bCanHighlightSelectedSections : 1;             // 0x03BC (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)
	uint32_t                                           bNeverBecomeDynamic : 1;                       // 0x03BC (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bIgnoreInstanceForTextureStreaming : 1;        // 0x03BC (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bOverrideLightMapRes : 1;                      // 0x03BC (0x0004) [0x0000000000000003] [0x00000020] (CPF_Edit | CPF_Const)
	uint32_t                                           bIgnoredByFXCoordinator : 1;                   // 0x03BC (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	class TArray<struct FGuid>                         IrrelevantLights;                              // 0x03C0 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	struct FBoxSphereBounds                            PrecomputedBounds;                             // 0x03D0 (0x001C) [0x0000000000000002] (CPF_Const)   
	class TArray<struct FStaticMeshComponentLODInfo>   LODData;                                       // 0x03F0 (0x0010) [0x0000000080001002] (CPF_Const | CPF_Native)
	uint8_t                                            ViewZeroOffset;                                // 0x0400 (0x0001) [0x0000000000000000]               
	uint8_t                                            ViewOneOffset;                                 // 0x0401 (0x0001) [0x0000000000000000]               
	uint8_t                                            ForcedLodModel;                                // 0x0402 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                            PreviousLODLevel;                              // 0x0403 (0x0001) [0x0000000000000000]               
	uint8_t                                           UnknownData00[0xC];                            // 0x0404 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.StaticMeshComponent");
		}

		return uClassPointer;
	};

	void SetViewportMaterialOffsets(uint8_t view0, uint8_t view1);
	bool CanBecomeDynamic();
	void SetForceStaticDecals(bool bInForceStaticDecals);
	void DisableRBCollisionWithSMC(class UPrimitiveComponent* OtherSMC, bool bDisabled);
	bool SetStaticMesh(class UStaticMesh* NewMesh, bool optionalBForce);
};

// Class Engine.BlockingMeshComponent
// 0x0010 (0x0410 - 0x0420)
class UBlockingMeshComponent : public UStaticMeshComponent
{
public:
	uint32_t                                           bBlockPlayers : 1;                             // 0x0410 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bBlockNPCs : 1;                                // 0x0410 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           bBlockVehicles : 1;                            // 0x0410 (0x0004) [0x0000000020000002] [0x00000004] (CPF_Const | CPF_Deprecated)
	uint32_t                                           bBlockRocketsAndGrenades : 1;                  // 0x0410 (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           bBlockBullets : 1;                             // 0x0410 (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	uint32_t                                           bBlockTossedItems : 1;                         // 0x0410 (0x0004) [0x0000000000000003] [0x00000020] (CPF_Edit | CPF_Const)
	uint32_t                                           bBlockEnemyPawns : 1;                          // 0x0410 (0x0004) [0x0000000020000002] [0x00000040] (CPF_Const | CPF_Deprecated)
	uint32_t                                           bBlockFriendlyPawns : 1;                       // 0x0410 (0x0004) [0x0000000020000002] [0x00000080] (CPF_Const | CPF_Deprecated)
	uint32_t                                           bBlockPlayerVehicles : 1;                      // 0x0410 (0x0004) [0x0000000000000003] [0x00000100] (CPF_Edit | CPF_Const)
	uint32_t                                           bBlockEnemyVehicles : 1;                       // 0x0410 (0x0004) [0x0000000000000003] [0x00000200] (CPF_Edit | CPF_Const)
	uint32_t                                           bIsDisabled : 1;                               // 0x0410 (0x0004) [0x0000000000000000] [0x00000400] 
	uint8_t                                           UnknownData00[0xC];                            // 0x0414 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BlockingMeshComponent");
		}

		return uClassPointer;
	};

	void SetBlockingMeshComponentCollision();
};

// Class Engine.CoverMeshComponent
// 0x0040 (0x0410 - 0x0450)
class UCoverMeshComponent : public UStaticMeshComponent
{
public:
	class TArray<struct FCoverMeshes>                  Meshes;                                        // 0x0410 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FVector                                     LocationOffset;                                // 0x0420 (0x000C) [0x0000000000000000]               
	class UStaticMesh*                                 AutoAdjustOn;                                  // 0x0430 (0x0008) [0x0000000000000000]               
	class UStaticMesh*                                 AutoAdjustOff;                                 // 0x0438 (0x0008) [0x0000000000000000]               
	class UStaticMesh*                                 Disabled;                                      // 0x0440 (0x0008) [0x0000000000000000]               
	uint32_t                                           bShowWhenNotSelected : 1;                      // 0x0448 (0x0004) [0x0000000800002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CoverMeshComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.FracturedBaseComponent
// 0x0000 (0x0410 - 0x0410)
class UFracturedBaseComponent : public UStaticMeshComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FracturedBaseComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.FracturedStaticMeshComponent
// 0x0000 (0x0410 - 0x0410)
class UFracturedStaticMeshComponent : public UFracturedBaseComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FracturedStaticMeshComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.SplineMeshComponent
// 0x0070 (0x0410 - 0x0480)
class USplineMeshComponent : public UStaticMeshComponent
{
public:
	struct FSplineMeshParams                           SplineParams;                                  // 0x0410 (0x0058) [0x0000000000000000]               
	struct FVector                                     SplineXDir;                                    // 0x0468 (0x000C) [0x0000000000000000]               
	uint32_t                                           bSmoothInterpRollScale : 1;                    // 0x0474 (0x0004) [0x0000000000000000] [0x00000001] 
	uint8_t                                           UnknownData00[0x8];                            // 0x0478 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SplineMeshComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.ModelComponent
// 0x0050 (0x0360 - 0x03B0)
class UModelComponent : public UPrimitiveComponent
{
public:
	class UObject*                                     Model;                                         // 0x0360 (0x0008) [0x0000000000803002] (CPF_Const | CPF_Native | CPF_Transient | CPF_NoExport)
	int32_t                                            ZoneIndex;                                     // 0x0368 (0x0004) [0x0000000000803002] (CPF_Const | CPF_Native | CPF_Transient | CPF_NoExport)
	int32_t                                            ComponentIndex;                                // 0x036C (0x0004) [0x0000000000803002] (CPF_Const | CPF_Native | CPF_Transient | CPF_NoExport)
	class TArray<struct FPointer>                      Nodes;                                         // 0x0370 (0x0010) [0x0000000000803002] (CPF_Const | CPF_Native | CPF_Transient | CPF_NoExport)
	class TArray<struct FPointer>                      Elements;                                      // 0x0380 (0x0010) [0x0000000000803002] (CPF_Const | CPF_Native | CPF_Transient | CPF_NoExport)
	int32_t                                            bShadowmapProxy;                               // 0x0390 (0x0004) [0x0000000000803002] (CPF_Const | CPF_Native | CPF_Transient | CPF_NoExport)
	class TArray<struct FPointer>                      ShadowmapProxyParents;                         // 0x0398 (0x0010) [0x0000000000803002] (CPF_Const | CPF_Native | CPF_Transient | CPF_NoExport)
	uint8_t                                           UnknownData00[0x8];                            // 0x03A8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ModelComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.NxForceFieldComponent
// 0x0070 (0x0360 - 0x03D0)
class UNxForceFieldComponent : public UPrimitiveComponent
{
public:
	class UForceFieldShape*                            Shape;                                         // 0x0360 (0x0008) [0x0000000004400009] (CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class UActorComponent*                             DrawComponent;                                 // 0x0368 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	int32_t                                            ExcludeChannel;                                // 0x0370 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bForceActive : 1;                              // 0x0374 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDestroyWhenInactive : 1;                      // 0x0374 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	struct FRBCollisionChannelContainer                CollideWithChannels;                           // 0x0378 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              Duration;                                      // 0x037C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    ForceField;                                    // 0x0380 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      ConvexMeshes;                                  // 0x0388 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      ExclusionShapes;                               // 0x0398 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FPointer>                      ExclusionShapePoses;                           // 0x03A8 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            SceneIndex;                                    // 0x03B8 (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)
	float                                              ElapsedTime;                                   // 0x03BC (0x0004) [0x0000000000000000]               
	class UPrimitiveComponent*                         RenderComponent;                               // 0x03C0 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FPointer                                    RBPhysScene;                                   // 0x03C8 (0x0008) [0x0000000000001000] (CPF_Native)  

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxForceFieldComponent");
		}

		return uClassPointer;
	};

	void DoInitRBPhys();
};

// Class Engine.NxForceFieldCylindricalComponent
// 0x0030 (0x03D0 - 0x0400)
class UNxForceFieldCylindricalComponent : public UNxForceFieldComponent
{
public:
	float                                              RadialStrength;                                // 0x03D0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              RotationalStrength;                            // 0x03D4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftStrength;                                  // 0x03D8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceRadius;                                   // 0x03DC (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceTopRadius;                                // 0x03E0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftFalloffHeight;                             // 0x03E4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              EscapeVelocity;                                // 0x03E8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceHeight;                                   // 0x03EC (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              HeightOffset;                                  // 0x03F0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	uint32_t                                           UseSpecialRadialForce : 1;                     // 0x03F4 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FPointer                                    Kernel;                                        // 0x03F8 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxForceFieldCylindricalComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.NxForceFieldGenericComponent
// 0x00B0 (0x03D0 - 0x0480)
class UNxForceFieldGenericComponent : public UNxForceFieldComponent
{
public:
	float                                              RoughExtentX;                                  // 0x03D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RoughExtentY;                                  // 0x03D4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RoughExtentZ;                                  // 0x03D8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	EFFG_ForceFieldCoordinates                         Coordinates;                                   // 0x03DC (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Constant;                                      // 0x03E0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierX;                           // 0x03EC (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierY;                           // 0x03F8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionMultiplierZ;                           // 0x0404 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     PositionTarget;                                // 0x0410 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierX;                           // 0x041C (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierY;                           // 0x0428 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityMultiplierZ;                           // 0x0434 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     VelocityTarget;                                // 0x0440 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Noise;                                         // 0x044C (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     FalloffLinear;                                 // 0x0458 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     FalloffQuadratic;                              // 0x0464 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              TorusRadius;                                   // 0x0470 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    Kernel;                                        // 0x0478 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxForceFieldGenericComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.NxForceFieldRadialComponent
// 0x0020 (0x03D0 - 0x03F0)
class UNxForceFieldRadialComponent : public UNxForceFieldComponent
{
public:
	float                                              ForceStrength;                                 // 0x03D0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceRadius;                                   // 0x03D4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              SelfRotationStrength;                          // 0x03D8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	ERadialImpulseFalloff                              ForceFalloff;                                  // 0x03DC (0x0001) [0x0000000000080009] (CPF_Edit | CPF_ExportObject | CPF_Component)
	struct FPointer                                    Kernel;                                        // 0x03E0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint8_t                                           UnknownData00[0x8];                            // 0x03E8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxForceFieldRadialComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.NxForceFieldTornadoComponent
// 0x0040 (0x03D0 - 0x0410)
class UNxForceFieldTornadoComponent : public UNxForceFieldComponent
{
public:
	float                                              RadialStrength;                                // 0x03D0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              RotationalStrength;                            // 0x03D4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftStrength;                                  // 0x03D8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceRadius;                                   // 0x03DC (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceTopRadius;                                // 0x03E0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              LiftFalloffHeight;                             // 0x03E4 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              EscapeVelocity;                                // 0x03E8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              ForceHeight;                                   // 0x03EC (0x0004) [0x0000000200000001] (CPF_Edit)    
	float                                              HeightOffset;                                  // 0x03F0 (0x0004) [0x0000000200000001] (CPF_Edit)    
	uint32_t                                           BSpecialRadialForceMode : 1;                   // 0x03F4 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              SelfRotationStrength;                          // 0x03F8 (0x0004) [0x0000000200000001] (CPF_Edit)    
	struct FPointer                                    Kernel;                                        // 0x0400 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint8_t                                           UnknownData00[0x8];                            // 0x0408 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NxForceFieldTornadoComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleSystemComponent
// 0x01F0 (0x0360 - 0x0550)
class UParticleSystemComponent : public UPrimitiveComponent
{
public:
	struct FPointer                                    VfTable_IIParticleSystemBehavior;              // 0x0360 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IIParameterBehavior;                   // 0x0368 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class UParticleSystem*                             Template;                                      // 0x0370 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UClass*                                      LightEnvironmentClass;                         // 0x0378 (0x0008) [0x0000000000000000]               
	class AActor*                                      LightEnvironmentSharedInstigator;              // 0x0380 (0x0008) [0x0000000000002000] (CPF_Transient)
	int32_t                                            MaxLightEnvironmentPooledReuses;               // 0x0388 (0x0004) [0x0000000000002000] (CPF_Transient)
	class TArray<struct FPointer>                      EmitterInstances;                              // 0x0390 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<class UStaticMeshComponent*>          SMComponents;                                  // 0x03A0 (0x0010) [0x000000000468200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UMaterialInterface*>            SMMaterialInterfaces;                          // 0x03B0 (0x0010) [0x0000000000602002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<class USkeletalMeshComponent*>        SkelMeshComponents;                            // 0x03C0 (0x0010) [0x000000000468200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<struct FViewParticleEmitterInstanceMotionBlurInfo> ViewMBInfoArray;                               // 0x03D0 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint32_t                                           bFullResolution : 1;                           // 0x03E0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAutoActivate : 1;                             // 0x03E0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bWasCompleted : 1;                             // 0x03E0 (0x0004) [0x0000000000002002] [0x00000004] (CPF_Const | CPF_Transient)
	uint32_t                                           bSuppressSpawning : 1;                         // 0x03E0 (0x0004) [0x0000000000002002] [0x00000008] (CPF_Const | CPF_Transient)
	uint32_t                                           bWasDeactivated : 1;                           // 0x03E0 (0x0004) [0x0000000000002002] [0x00000010] (CPF_Const | CPF_Transient)
	uint32_t                                           bResetOnDetach : 1;                            // 0x03E0 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bUpdateOnDedicatedServer : 1;                  // 0x03E0 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bAllowParticleMaxCullDistanceOverride : 1;     // 0x03E0 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bJustAttached : 1;                             // 0x03E0 (0x0004) [0x0000000000002000] [0x00000100] (CPF_Transient)
	uint32_t                                           bIsActive : 1;                                 // 0x03E0 (0x0004) [0x0000000000002000] [0x00000200] (CPF_Transient)
	uint32_t                                           bEnableAsyncThreading : 1;                     // 0x03E0 (0x0004) [0x0000000000002000] [0x00000400] (CPF_Transient)
	uint32_t                                           bWarmingUp : 1;                                // 0x03E0 (0x0004) [0x0000000000002000] [0x00000800] (CPF_Transient)
	uint32_t                                           bJustActivated : 1;                            // 0x03E0 (0x0004) [0x0000000000002000] [0x00001000] (CPF_Transient)
	uint32_t                                           bJustDeactivated : 1;                          // 0x03E0 (0x0004) [0x0000000000002000] [0x00002000] (CPF_Transient)
	uint32_t                                           bIsCachedInPool : 1;                           // 0x03E0 (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bCanBeReclaimedByPool : 1;                     // 0x03E0 (0x0004) [0x0000000000002000] [0x00008000] (CPF_Transient)
	uint32_t                                           bIgnoreEditorRealtimeLOD : 1;                  // 0x03E0 (0x0004) [0x0000000800000000] [0x00010000] 
	uint32_t                                           bOverrideLODMethod : 1;                        // 0x03E0 (0x0004) [0x0000000000000001] [0x00020000] (CPF_Edit)
	uint32_t                                           bSkipBoundsUpdate : 1;                         // 0x03E0 (0x0004) [0x0000000000000000] [0x00040000] 
	uint32_t                                           bUpdateComponentInTick : 1;                    // 0x03E0 (0x0004) [0x0000000000000000] [0x00080000] 
	uint32_t                                           bDeferredBeamUpdate : 1;                       // 0x03E0 (0x0004) [0x0000000000000000] [0x00100000] 
	uint32_t                                           bIgnoreCollision : 1;                          // 0x03E0 (0x0004) [0x0000000000000000] [0x00200000] 
	uint32_t                                           bForcedInActive : 1;                           // 0x03E0 (0x0004) [0x0000000000002000] [0x00400000] (CPF_Transient)
	uint32_t                                           bIsViewRelevanceDirty : 1;                     // 0x03E0 (0x0004) [0x0000000000002000] [0x00800000] (CPF_Transient)
	uint32_t                                           bRecacheViewRelevance : 1;                     // 0x03E0 (0x0004) [0x0000000000002000] [0x01000000] (CPF_Transient)
	uint32_t                                           bLODUpdatePending : 1;                         // 0x03E0 (0x0004) [0x0000000000002000] [0x02000000] (CPF_Transient)
	uint32_t                                           AudioEnabled : 1;                              // 0x03E0 (0x0004) [0x0000000000002000] [0x04000000] (CPF_Transient)
	uint32_t                                           bStartEventPlayed : 1;                         // 0x03E0 (0x0004) [0x0000000000002000] [0x08000000] (CPF_Transient)
	uint32_t                                           bCheckForKillWhileIdle : 1;                    // 0x03E0 (0x0004) [0x0000000000002000] [0x10000000] (CPF_Transient)
	uint32_t                                           bIgnoredByFXCoordinator : 1;                   // 0x03E0 (0x0004) [0x0000000000000001] [0x20000000] (CPF_Edit)
	float                                              ParticleMaxCullDistanceScaleFactor;            // 0x03E4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FParticleSysParam>             InstanceParameters;                            // 0x03E8 (0x0010) [0x0000000004400001] (CPF_Edit | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<struct FParticleSysParam>             AsyncInstanceParameters;                       // 0x03F8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	struct FVector                                     OldPosition;                                   // 0x0408 (0x000C) [0x0000000000000000]               
	struct FVector                                     PartSysVelocity;                               // 0x0414 (0x000C) [0x0000000000000000]               
	float                                              WarmupTime;                                    // 0x0420 (0x0004) [0x0000000000000000]               
	int32_t                                            LODLevel;                                      // 0x0424 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              AccumTickTime;                                 // 0x0428 (0x0004) [0x0000000000002000] (CPF_Transient)
	EParticleSystemLODMethod                           LODMethod;                                     // 0x042C (0x0001) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FMaterialViewRelevance>        CachedViewRelevanceFlags;                      // 0x0430 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              AccumLODDistanceCheckTime;                     // 0x0440 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FParticleEventBuffers                       ParticleEvents;                                // 0x0448 (0x0060) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	struct FParticleEventBuffers                       AsyncParticleEvents;                           // 0x04A8 (0x0060) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	int32_t                                            SeqObjCounter;                                 // 0x0508 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FPointer                                    ReleaseResourcesFence;                         // 0x0510 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    AsyncEmitterTickCounter;                       // 0x0518 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	float                                              CustomTimeDilation;                            // 0x0520 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              EmitterDelay;                                  // 0x0524 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              AudioEventDelay;                               // 0x0528 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FAkPlayingInfo                              LoopingAkPlayingInfo;                          // 0x0530 (0x0010) [0x0000000000082000] (CPF_Transient | CPF_Component)
	struct FScriptDelegate                             __OnSystemFinished__Delegate;                  // 0x0540 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleSystemComponent");
		}

		return uClassPointer;
	};

	void Behavior_ChangeParticleSystemActiveState(EChangeStatus ChangeType);
	void Behavior_SetVectorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FVector& Value);
	void Behavior_SetColorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FLinearColor& Value);
	void Behavior_SetObjectParameterValue(class UObject* Value, int32_t& SectionIndex, struct FName& ParameterName);
	void Behavior_SetFloatParameterValue(int32_t& SectionIndex, struct FName& ParameterName, float& Value);
	bool Behavior_GetObjectParameterValueW(int32_t& SectionIndex, struct FName& ParameterName, class UObject*& Value);
	bool Behavior_GetVectorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FVector& Value);
	bool Behavior_GetColorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FLinearColor& Value);
	bool Behavior_GetFloatParameterValue(int32_t& SectionIndex, struct FName& ParameterName, float& Value);
	void SetStopSpawning(int32_t InEmitterIndex, bool bInStopSpawning);
	void ResetToDefaults();
	void SetActive(bool bNowActive, bool optionalBFlagAsJustAttached);
	void ClearParameter(const struct FName& ParameterName, EParticleSysParamType optionalParameterType);
	bool GetMaterialParameter(const struct FName& InName, class UMaterialInterface*& OutMaterial);
	bool GetActorParameter(const struct FName& InName, class AActor*& OutActor);
	bool GetColorParameter(const struct FName& InName, struct FColor& OutColor);
	bool GetVectorParameter(const struct FName& InName, struct FVector& OutVector);
	bool GetFloatParameter(const struct FName& InName, float& OutFloat);
	void SetDepthPriorityGroupAndSortPriority(ESceneDepthPriorityGroup NewDPG, int32_t optionalSortPriority);
	void SetMaterialParameter(const struct FName& ParameterName, class UMaterialInterface* Param);
	void SetActorParameter(const struct FName& ParameterName, class AActor* Param, const struct FName& SocketParam);
	void SetColorParameter(const struct FName& ParameterName, const struct FColor& Param);
	void SetVectorRandParameter(const struct FName& ParameterName, struct FVector& Param, struct FVector& ParamLow);
	void SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param);
	void SetFloatRandParameter(const struct FName& ParameterName, float Param, float ParamLow);
	void SetFloatParameter(const struct FName& ParameterName, float Param);
	int32_t GetEditorLODLevel();
	int32_t GetLODLevel();
	void SetEditorLODLevel(int32_t InLODLevel);
	void SetLODLevel(int32_t InLODLevel);
	bool SystemHasCompleted();
	float GetMaxLifespan();
	int32_t DetermineLODLevelForLocation(struct FVector& EffectLocation);
	void RewindEmitterInstances();
	void RewindEmitterInstance(int32_t EmitterIndex);
	void SetKillOnCompleted(int32_t EmitterIndex, bool bKill);
	void SetKillOnDeactivate(int32_t EmitterIndex, bool bKill);
	bool GetSkipBoundsUpdate();
	void SetSkipBoundsUpdate(bool bInSkipBoundsUpdate);
	void KillParticlesInEmitter(const struct FName& InEmitterName);
	void KillParticlesForced();
	void DeactivateSystem();
	void ActivateSystem(bool optionalBFlagAsJustAttached);
	void SetTemplate(class UParticleSystem* NewTemplate);
	void OnSystemFinished(class UParticleSystemComponent* PSystem);
};

// Class Engine.RB_ConstraintDrawComponent
// 0x0010 (0x0360 - 0x0370)
class URB_ConstraintDrawComponent : public UPrimitiveComponent
{
public:
	class UMaterialInterface*                          LimitMaterial;                                 // 0x0360 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData00[0x8];                            // 0x0368 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_ConstraintDrawComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_RadialImpulseComponent
// 0x0020 (0x0360 - 0x0380)
class URB_RadialImpulseComponent : public UPrimitiveComponent
{
public:
	ERadialImpulseFalloff                              ImpulseFalloff;                                // 0x0360 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              ImpulseStrength;                               // 0x0364 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ImpulseRadius;                                 // 0x0368 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bVelChange : 1;                                // 0x036C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class UDrawSphereComponent*                        PreviewSphere;                                 // 0x0370 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	uint8_t                                           UnknownData00[0x8];                            // 0x0378 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_RadialImpulseComponent");
		}

		return uClassPointer;
	};

	void FireImpulse(const struct FVector& Origin);
};

// Class Engine.RealTimeShatterComponent
// 0x0010 (0x0360 - 0x0370)
class URealTimeShatterComponent : public UPrimitiveComponent
{
public:
	struct FPointer                                    ShatterInfo;                                   // 0x0360 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint8_t                                           UnknownData00[0x8];                            // 0x0368 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RealTimeShatterComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.SocketComponent
// 0x0010 (0x0360 - 0x0370)
class USocketComponent : public UPrimitiveComponent
{
public:
	struct FName                                       SocketName;                                    // 0x0360 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData00[0x8];                            // 0x0368 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SocketComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.HomingTargetComponent
// 0x0000 (0x0370 - 0x0370)
class UHomingTargetComponent : public USocketComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.HomingTargetComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.SpeedTreeComponent
// 0x0000 (0x0360 - 0x0360)
class USpeedTreeComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpeedTreeComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.SplineComponent
// 0x0050 (0x0360 - 0x03B0)
class USplineComponent : public UPrimitiveComponent
{
public:
	struct FInterpCurveVector                          SplineInfo;                                    // 0x0360 (0x0018) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              SplineCurviness;                               // 0x0378 (0x0004) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	struct FColor                                      SplineColor;                                   // 0x037C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SplineDrawRes;                                 // 0x0380 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SplineArrowSize;                               // 0x0384 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bSplineDisabled : 1;                           // 0x0388 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FInterpCurveFloat                           SplineReparamTable;                            // 0x0390 (0x0018) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint8_t                                           UnknownData00[0x8];                            // 0x03A8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SplineComponent");
		}

		return uClassPointer;
	};

	struct FVector GetTangentAtDistanceAlongSpline(float Distance);
	struct FVector GetLocationAtDistanceAlongSpline(float Distance);
	float GetSplineLength();
	void UpdateSplineReparamTable();
	void UpdateSplineCurviness();
};

// Class Engine.SpriteComponent
// 0x0020 (0x0360 - 0x0380)
class USpriteComponent : public UPrimitiveComponent
{
public:
	class UTexture2D*                                  Sprite;                                        // 0x0360 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bIsScreenSizeScaled : 1;                       // 0x0368 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              ScreenSize;                                    // 0x036C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              U;                                             // 0x0370 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              UL;                                            // 0x0374 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              V;                                             // 0x0378 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              VL;                                            // 0x037C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpriteComponent");
		}

		return uClassPointer;
	};

	void SetSpriteAndUV(class UTexture2D* NewSprite, int32_t NewU, int32_t NewUL, int32_t NewV, int32_t NewVL);
	void SetUV(int32_t NewU, int32_t NewUL, int32_t NewV, int32_t NewVL);
	void SetSprite(class UTexture2D* NewSprite);
};

// Class Engine.SpriteRTTComponent
// 0x0010 (0x0380 - 0x0390)
class USpriteRTTComponent : public USpriteComponent
{
public:
	class UTextureRenderTarget2D*                      SpriteRTT;                                     // 0x0380 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData00[0x8];                            // 0x0388 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpriteRTTComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.TerrainComponent
// 0x00A0 (0x0360 - 0x0400)
class UTerrainComponent : public UPrimitiveComponent
{
public:
	class UShadowMap2D*                                DominantShadowMap;                             // 0x0360 (0x0008) [0x0000000000000000]               
	class TArray<class UShadowMap2D*>                  ShadowMaps;                                    // 0x0368 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FGuid>                         IrrelevantLights;                              // 0x0378 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	struct FPointer                                    TerrainObject;                                 // 0x0388 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    TerrainRenderResources;                        // 0x0390 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            SectionBaseX;                                  // 0x0398 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            SectionBaseY;                                  // 0x039C (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            SectionSizeX;                                  // 0x03A0 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            SectionSizeY;                                  // 0x03A4 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            TrueSectionSizeX;                              // 0x03A8 (0x0004) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	int32_t                                            TrueSectionSizeY;                              // 0x03AC (0x0004) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	struct FPointer                                    LightMap;                                      // 0x03B0 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<int32_t>                              BatchMaterials;                                // 0x03B8 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            FullBatch;                                     // 0x03C8 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FTerrainBVTree                              GameBVTree;                                    // 0x03D0 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FTerrainBVTree                              EditorBVTree;                                  // 0x03E0 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    RBHeightfield;                                 // 0x03F0 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	uint8_t                                           UnknownData00[0x8];                            // 0x03F8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TerrainComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.RadialBlurComponent
// 0x0070 (0x0090 - 0x0100)
class URadialBlurComponent : public UActorComponent
{
public:
	class UMaterialInterface*                          Material;                                      // 0x0090 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ESceneDepthPriorityGroup                           DepthPriorityGroup;                            // 0x0098 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BlurScale;                                     // 0x009C (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              BlurFalloffExponent;                           // 0x00A0 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              BlurOpacity;                                   // 0x00A4 (0x0004) [0x0000000200000003] (CPF_Edit | CPF_Const)
	float                                              MaxCullDistance;                               // 0x00A8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              DistanceFalloffExponent;                       // 0x00AC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bRenderAsVelocity : 1;                         // 0x00B0 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnabled : 1;                                  // 0x00B0 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint8_t                                           UnknownData00[0xC];                            // 0x00B4 (0x000C) MISSED OFFSET
	struct FMatrix                                     LocalToWorld;                                  // 0x00C0 (0x0040) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RadialBlurComponent");
		}

		return uClassPointer;
	};

	void OnUpdatePropertyBlurOpacity();
	void OnUpdatePropertyBlurFalloffExponent();
	void OnUpdatePropertyBlurScale();
	void SetEnabled(bool bInEnabled);
	void SetBlurOpacity(float InBlurOpacity);
	void SetBlurFalloffExponent(float InBlurFalloffExponent);
	void SetBlurScale(float InBlurScale);
	void SetMaterial(class UMaterialInterface* InMaterial);
};

// Class Engine.RB_Handle
// 0x0078 (0x0090 - 0x0108)
class URB_Handle : public UActorComponent
{
public:
	class UPrimitiveComponent*                         GrabbedComponent;                              // 0x0090 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FName                                       GrabbedBoneName;                               // 0x0098 (0x0008) [0x0000000000000000]               
	int32_t                                            SceneIndex;                                    // 0x00A0 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint32_t                                           bInHardware : 1;                               // 0x00A4 (0x0004) [0x0000000000003002] [0x00000001] (CPF_Const | CPF_Native | CPF_Transient)
	uint32_t                                           bRotationConstrained : 1;                      // 0x00A4 (0x0004) [0x0000000000003002] [0x00000002] (CPF_Const | CPF_Native | CPF_Transient)
	uint32_t                                           bInterpolating : 1;                            // 0x00A4 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FPointer                                    HandleData;                                    // 0x00A8 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    KinActorData;                                  // 0x00B0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	float                                              LinearDamping;                                 // 0x00B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LinearStiffness;                               // 0x00BC (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     LinearStiffnessScale3D;                        // 0x00C0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     LinearDampingScale3D;                          // 0x00CC (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              AngularDamping;                                // 0x00D8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AngularStiffness;                              // 0x00DC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AngularForceLimit;                             // 0x00E0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Destination;                                   // 0x00E4 (0x000C) [0x0000000000000000]               
	struct FVector                                     StepSize;                                      // 0x00F0 (0x000C) [0x0000000000000000]               
	struct FVector                                     Location;                                      // 0x00FC (0x000C) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_Handle");
		}

		return uClassPointer;
	};

	struct FQuat GetOrientation();
	void SetOrientation(struct FQuat& NewOrientation);
	void UpdateSmoothLocation(struct FVector& NewLocation);
	void SetSmoothLocation(const struct FVector& NewLocation, float MoveTime);
	void SetLocation(const struct FVector& NewLocation);
	void ReleaseComponent();
	void GrabComponent(class UPrimitiveComponent* Component, const struct FName& InBoneName, const struct FVector& GrabLocation, bool bConstrainRotation);
};

// Class Engine.RB_Spring
// 0x0068 (0x0090 - 0x00F8)
class URB_Spring : public UActorComponent
{
public:
	class UPrimitiveComponent*                         Component1;                                    // 0x0090 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FName                                       BoneName1;                                     // 0x0098 (0x0008) [0x0000000000000002] (CPF_Const)   
	class UPrimitiveComponent*                         Component2;                                    // 0x00A0 (0x0008) [0x000000000408000A] (CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FName                                       BoneName2;                                     // 0x00A8 (0x0008) [0x0000000000000002] (CPF_Const)   
	int32_t                                            SceneIndex;                                    // 0x00B0 (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)
	uint32_t                                           bInHardware : 1;                               // 0x00B4 (0x0004) [0x0000000000001002] [0x00000001] (CPF_Const | CPF_Native)
	uint32_t                                           bEnableForceMassRatio : 1;                     // 0x00B4 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	struct FPointer                                    SpringData;                                    // 0x00B8 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	float                                              TimeSinceActivation;                           // 0x00C0 (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)
	float                                              MinBodyMass;                                   // 0x00C4 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              SpringSaturateDist;                            // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SpringMaxForce;                                // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxForceMassRatio;                             // 0x00D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FInterpCurveFloat                           SpringMaxForceTimeScale;                       // 0x00D8 (0x0018) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              DampSaturateVel;                               // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DampMaxForce;                                  // 0x00F4 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_Spring");
		}

		return uClassPointer;
	};

	void Clear();
	void SetComponents(class UPrimitiveComponent* InComponent1, const struct FName& InBoneName1, const struct FVector& Position1, class UPrimitiveComponent* InComponent2, const struct FName& InBoneName2, const struct FVector& Position2);
};

// Class Engine.SVehicleSimBase
// 0x0040 (0x0090 - 0x00D0)
class USVehicleSimBase : public UActorComponent
{
public:
	float                                              EnginePeakTorque;                              // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              EngineMaxRPM;                                  // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelSuspensionStiffness;                      // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelSuspensionDamping;                        // 0x009C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelSuspensionBias;                           // 0x00A0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelLongExtremumSlip;                         // 0x00A4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelLongExtremumValue;                        // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelLongAsymptoteSlip;                        // 0x00AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelLongAsymptoteValue;                       // 0x00B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelLatExtremumSlip;                          // 0x00B4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelLatExtremumValue;                         // 0x00B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelLatAsymptoteSlip;                         // 0x00BC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelLatAsymptoteValue;                        // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelInertia;                                  // 0x00C4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bWheelSpeedOverride : 1;                       // 0x00C8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bClampedFrictionModel : 1;                     // 0x00C8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bAutoDrive : 1;                                // 0x00C8 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	float                                              AutoDriveSteer;                                // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SVehicleSimBase");
		}

		return uClassPointer;
	};

};

// Class Engine.SVehicleSimCar
// 0x0040 (0x00D0 - 0x0110)
class USVehicleSimCar : public USVehicleSimBase
{
public:
	float                                              ChassisTorqueScale;                            // 0x00D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FInterpCurveFloat                           MaxSteerAngleCurve;                            // 0x00D8 (0x0018) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              SteerSpeed;                                    // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ReverseThrottle;                               // 0x00F4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              EngineBrakeFactor;                             // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxBrakeTorque;                                // 0x00FC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StopThreshold;                                 // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bIsDriving : 1;                                // 0x0104 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              ActualSteering;                                // 0x0108 (0x0004) [0x0000000000000000]               
	float                                              TimeSinceThrottle;                             // 0x010C (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SVehicleSimCar");
		}

		return uClassPointer;
	};

};

// Class Engine.SVehicleSimTank
// 0x0030 (0x0110 - 0x0140)
class USVehicleSimTank : public USVehicleSimCar
{
public:
	float                                              LeftTrackVel;                                  // 0x0110 (0x0004) [0x0000000000000000]               
	float                                              RightTrackVel;                                 // 0x0114 (0x0004) [0x0000000000000000]               
	float                                              LeftTrackTorque;                               // 0x0118 (0x0004) [0x0000000000000000]               
	float                                              RightTrackTorque;                              // 0x011C (0x0004) [0x0000000000000000]               
	float                                              MaxEngineTorque;                               // 0x0120 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              EngineDamping;                                 // 0x0124 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              InsideTrackTorqueFactor;                       // 0x0128 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SteeringLatStiffnessFactor;                    // 0x012C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TurnInPlaceThrottle;                           // 0x0130 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TurnMaxGripReduction;                          // 0x0134 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TurnGripScaleRate;                             // 0x0138 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bTurnInPlaceOnSteer : 1;                       // 0x013C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SVehicleSimTank");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactory
// 0x0068 (0x0058 - 0x00C0)
class UActorFactory : public UObject
{
public:
	class UClass*                                      GameplayActorClass;                            // 0x0058 (0x0008) [0x0000000000000000]               
	class FString                                      MenuName;                                      // 0x0060 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            MenuPriority;                                  // 0x0070 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            AlternateMenuPriority;                         // 0x0074 (0x0004) [0x0000000020000000]  CPF_Deprecated)
	class UClass*                                      NewActorClass;                                 // 0x0078 (0x0008) [0x0000000000000000]               
	uint32_t                                           bPlaceable : 1;                                // 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bShowInEditorQuickMenu : 1;                    // 0x0080 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bUseCustomPropertyEditor : 1;                  // 0x0080 (0x0004) [0x0000000000000000] [0x00000004] 
	class FString                                      SpecificGameName;                              // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      CustomPropertyEditorDelegateClassName;         // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class UActorFactoryCustomPropertyEditorDelegate*   CustomPropertyEditorDelegateInstance;          // 0x00A8 (0x0008) [0x0000000000000000]               
	class UClass*                                      CustomPropertyEditorDelegateTargetClass;       // 0x00B0 (0x0008) [0x0000000000000000]               
	struct FName                                       CustomPropertyEditorDelegatePropertyName;      // 0x00B8 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactory");
		}

		return uClassPointer;
	};

	void eventPostCreateActor(class AActor* NewActor);
};

// Class Engine.ActorFactoryActor
// 0x0008 (0x00C0 - 0x00C8)
class UActorFactoryActor : public UActorFactory
{
public:
	class UClass*                                      ActorClass;                                    // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryActor");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryAI
// 0x0040 (0x00C0 - 0x0100)
class UActorFactoryAI : public UActorFactory
{
public:
	class UClass*                                      ControllerClass;                               // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UClass*                                      PawnClass;                                     // 0x00C8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class FString                                      PawnName;                                      // 0x00D0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bGiveDefaultInventory : 1;                     // 0x00E0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class TArray<class UClass*>                        InventoryList;                                 // 0x00E8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	int32_t                                            TeamIndex;                                     // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryAI");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryApexDestructible
// 0x0018 (0x00C0 - 0x00D8)
class UActorFactoryApexDestructible : public UActorFactory
{
public:
	uint32_t                                           bStartAwake : 1;                               // 0x00C0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	ERBCollisionChannel                                RBChannel;                                     // 0x00C4 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FRBCollisionChannelContainer                CollideWithChannels;                           // 0x00C8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UApexDestructibleAsset*                      DestructibleAsset;                             // 0x00D0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryApexDestructible");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryArchetype
// 0x0008 (0x00C0 - 0x00C8)
class UActorFactoryArchetype : public UActorFactory
{
public:
	class AActor*                                      ArchetypeActor;                                // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryArchetype");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryCoverLink
// 0x0000 (0x00C0 - 0x00C0)
class UActorFactoryCoverLink : public UActorFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryCoverLink");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryDecal
// 0x0008 (0x00C0 - 0x00C8)
class UActorFactoryDecal : public UActorFactory
{
public:
	class UMaterialInterface*                          DecalMaterial;                                 // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryDecal");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryDecalMovable
// 0x0000 (0x00C8 - 0x00C8)
class UActorFactoryDecalMovable : public UActorFactoryDecal
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryDecalMovable");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryDominantDirectionalLight
// 0x0000 (0x00C0 - 0x00C0)
class UActorFactoryDominantDirectionalLight : public UActorFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryDominantDirectionalLight");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryDominantDirectionalLightMovable
// 0x0000 (0x00C0 - 0x00C0)
class UActorFactoryDominantDirectionalLightMovable : public UActorFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryDominantDirectionalLightMovable");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryDynamicSM
// 0x0020 (0x00C0 - 0x00E0)
class UActorFactoryDynamicSM : public UActorFactory
{
public:
	class UStaticMesh*                                 StaticMesh;                                    // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     DrawScale3D;                                   // 0x00C8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bNoEncroachCheck : 1;                          // 0x00D4 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bNotifyRigidBodyCollision : 1;                 // 0x00D4 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bBlockRigidBody : 1;                           // 0x00D4 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bUseCompartment : 1;                           // 0x00D4 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bCastDynamicShadow : 1;                        // 0x00D4 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	ECollisionType                                     CollisionType;                                 // 0x00D8 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryDynamicSM");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryMover
// 0x0000 (0x00E0 - 0x00E0)
class UActorFactoryMover : public UActorFactoryDynamicSM
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryMover");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryRigidBody
// 0x0030 (0x00E0 - 0x0110)
class UActorFactoryRigidBody : public UActorFactoryDynamicSM
{
public:
	uint32_t                                           bStartAwake : 1;                               // 0x00E0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDamageAppliesImpulse : 1;                     // 0x00E0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bLocalSpaceInitialVelocity : 1;                // 0x00E0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bEnableStayUprightSpring : 1;                  // 0x00E0 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	struct FVector                                     InitialVelocity;                               // 0x00E4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	class UDistributionVector*                         AdditionalVelocity;                            // 0x00F0 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	class UDistributionVector*                         InitialAngularVelocity;                        // 0x00F8 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	ERBCollisionChannel                                RBChannel;                                     // 0x0100 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              StayUprightTorqueFactor;                       // 0x0104 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StayUprightMaxTorque;                          // 0x0108 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryRigidBody");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryEmitter
// 0x0008 (0x00C0 - 0x00C8)
class UActorFactoryEmitter : public UActorFactory
{
public:
	class UParticleSystem*                             ParticleSystem;                                // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryEmitter");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryFogVolumeConstantDensityInfo
// 0x0010 (0x00C0 - 0x00D0)
class UActorFactoryFogVolumeConstantDensityInfo : public UActorFactory
{
public:
	class UMaterialInterface*                          SelectedMaterial;                              // 0x00C0 (0x0008) [0x0000000000000000]               
	uint32_t                                           bNothingSelected : 1;                          // 0x00C8 (0x0004) [0x0000000000000000] [0x00000001] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryFogVolumeConstantDensityInfo");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryFogVolumeLinearHalfspaceDensityInfo
// 0x0000 (0x00D0 - 0x00D0)
class UActorFactoryFogVolumeLinearHalfspaceDensityInfo : public UActorFactoryFogVolumeConstantDensityInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryFogVolumeLinearHalfspaceDensityInfo");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryFogVolumeSphericalDensityInfo
// 0x0000 (0x00D0 - 0x00D0)
class UActorFactoryFogVolumeSphericalDensityInfo : public UActorFactoryFogVolumeConstantDensityInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryFogVolumeSphericalDensityInfo");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryLensFlare
// 0x0008 (0x00C0 - 0x00C8)
class UActorFactoryLensFlare : public UActorFactory
{
public:
	class ULensFlare*                                  LensFlareObject;                               // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryLensFlare");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryLight
// 0x0000 (0x00C0 - 0x00C0)
class UActorFactoryLight : public UActorFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryLight");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryPhysicsAsset
// 0x0030 (0x00C0 - 0x00F0)
class UActorFactoryPhysicsAsset : public UActorFactory
{
public:
	class UPhysicsAsset*                               PhysicsAsset;                                  // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class USkeletalMesh*                               SkeletalMesh;                                  // 0x00C8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bStartAwake : 1;                               // 0x00D0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDamageAppliesImpulse : 1;                     // 0x00D0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bNotifyRigidBodyCollision : 1;                 // 0x00D0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bUseCompartment : 1;                           // 0x00D0 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bCastDynamicShadow : 1;                        // 0x00D0 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	struct FVector                                     InitialVelocity;                               // 0x00D4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     DrawScale3D;                                   // 0x00E0 (0x000C) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryPhysicsAsset");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryPlayerStart
// 0x0000 (0x00C0 - 0x00C0)
class UActorFactoryPlayerStart : public UActorFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryPlayerStart");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryPylon
// 0x0000 (0x00C0 - 0x00C0)
class UActorFactoryPylon : public UActorFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryPylon");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactorySkeletalMesh
// 0x0018 (0x00C0 - 0x00D8)
class UActorFactorySkeletalMesh : public UActorFactory
{
public:
	class USkeletalMesh*                               SkeletalMesh;                                  // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UAnimSet*                                    AnimSet;                                       // 0x00C8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AnimSequenceName;                              // 0x00D0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactorySkeletalMesh");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryApexClothing
// 0x0018 (0x00D8 - 0x00F0)
class UActorFactoryApexClothing : public UActorFactorySkeletalMesh
{
public:
	class TArray<class UApexClothingAsset*>            ClothingAssets;                                // 0x00D8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	ERBCollisionChannel                                ClothingRBChannel;                             // 0x00E8 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FRBCollisionChannelContainer                ClothingRBCollideWithChannels;                 // 0x00EC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryApexClothing");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactorySkeletalMeshCinematic
// 0x0000 (0x00D8 - 0x00D8)
class UActorFactorySkeletalMeshCinematic : public UActorFactorySkeletalMesh
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactorySkeletalMeshCinematic");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactorySkeletalMeshMAT
// 0x0000 (0x00D8 - 0x00D8)
class UActorFactorySkeletalMeshMAT : public UActorFactorySkeletalMesh
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactorySkeletalMeshMAT");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryStaticMesh
// 0x0018 (0x00C0 - 0x00D8)
class UActorFactoryStaticMesh : public UActorFactory
{
public:
	class UStaticMesh*                                 StaticMesh;                                    // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     DrawScale3D;                                   // 0x00C8 (0x000C) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryStaticMesh");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryInteractiveFoliage
// 0x0000 (0x00D8 - 0x00D8)
class UActorFactoryInteractiveFoliage : public UActorFactoryStaticMesh
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryInteractiveFoliage");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryTrigger
// 0x0000 (0x00C0 - 0x00C0)
class UActorFactoryTrigger : public UActorFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryTrigger");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryVehicle
// 0x0008 (0x00C0 - 0x00C8)
class UActorFactoryVehicle : public UActorFactory
{
public:
	class UClass*                                      VehicleClass;                                  // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryVehicle");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryCustomPropertyEditorDelegate
// 0x0000 (0x0058 - 0x0058)
class UActorFactoryCustomPropertyEditorDelegate : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryCustomPropertyEditorDelegate");
		}

		return uClassPointer;
	};

};

// Class Engine.AkAudioDevice
// 0x0950 (0x0060 - 0x09B0)
class UAkAudioDevice : public USubsystem
{
public:
	uint8_t                                           UnknownData00[0x950];                          // 0x0060 (0x0950) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkAudioDevice");
		}

		return uClassPointer;
	};

};

// Class Engine.AkObject
// 0x0008 (0x0058 - 0x0060)
class UAkObject : public UObject
{
public:
	int32_t                                            ShortId;                                       // 0x0058 (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkObject");
		}

		return uClassPointer;
	};

};

// Class Engine.AkBank
// 0x0018 (0x0060 - 0x0078)
class UAkBank : public UAkObject
{
public:
	uint32_t                                           AutoLoad : 1;                                  // 0x0060 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bSeekFreeCollection : 1;                       // 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	int32_t                                            NumAsyncLoaders;                               // 0x0064 (0x0004) [0x0000000000002000] (CPF_Transient)
	EBankLoadState                                     LoadState;                                     // 0x0068 (0x0001) [0x0000000000002000] (CPF_Transient)
	struct FThreadSafeCounter                          AsyncLoadCounter;                              // 0x006C (0x0004) [0x0000000000003000] (CPF_Native | CPF_Transient)
	class UAkBank*                                     NextSeekFreeCollectionBankPart;                // 0x0070 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkBank");
		}

		return uClassPointer;
	};

};

// Class Engine.AkDialogueEvent
// 0x0020 (0x0060 - 0x0080)
class UAkDialogueEvent : public UAkObject
{
public:
	class UAkBank*                                     RequiredBank;                                  // 0x0060 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FDialogueArgument>             Arguments;                                     // 0x0068 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class UFaceFXAnimSet*                              FaceFXAnimSet;                                 // 0x0078 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkDialogueEvent");
		}

		return uClassPointer;
	};

};

// Class Engine.AkEffect
// 0x0018 (0x0060 - 0x0078)
class UAkEffect : public UAkObject
{
public:
	class FString                                      EffectName;                                    // 0x0060 (0x0010) [0x0000000000420003] (CPF_Edit | CPF_Const | CPF_EditConst | CPF_NeedCtorLink)
	uint32_t                                           bCanBeEnvironmental : 1;                       // 0x0070 (0x0004) [0x0000000000020003] [0x00000001] (CPF_Edit | CPF_Const | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.AkEvent
// 0x0020 (0x0060 - 0x0080)
class UAkEvent : public UAkObject
{
public:
	class UAkBank*                                     RequiredBank;                                  // 0x0060 (0x0008) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	class UFaceFXAnimSet*                              FaceFXAnimSet;                                 // 0x0068 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bCanBeOccluded : 1;                            // 0x0070 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bEcho : 1;                                     // 0x0070 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bVoice : 1;                                    // 0x0070 (0x0004) [0x0000000000020003] [0x00000004] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bInCookedMap : 1;                              // 0x0070 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bIsSimpleEvent : 1;                            // 0x0070 (0x0004) [0x0000000000020003] [0x00000010] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bReliable : 1;                                 // 0x0070 (0x0004) [0x0000000000020003] [0x00000020] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bWantDistanceRTPC : 1;                         // 0x0070 (0x0004) [0x0000000000020003] [0x00000040] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bWantSpeedRTPC : 1;                            // 0x0070 (0x0004) [0x0000000000020003] [0x00000080] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bWantApproachSpeedRTPC : 1;                    // 0x0070 (0x0004) [0x0000000000020003] [0x00000100] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bWantComponentRelativeVelocityRTPC : 1;        // 0x0070 (0x0004) [0x0000000000020003] [0x00000200] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bWantElevationRTPC : 1;                        // 0x0070 (0x0004) [0x0000000000020003] [0x00000400] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bWantAzimuthRTPC : 1;                          // 0x0070 (0x0004) [0x0000000000020003] [0x00000800] (CPF_Edit | CPF_Const | CPF_EditConst)
	float                                              MaxAttenuationRadius;                          // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MinDuration;                                   // 0x0078 (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	float                                              MaxDuration;                                   // 0x007C (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkEvent");
		}

		return uClassPointer;
	};

};

// Class Engine.AkRtpc
// 0x0010 (0x0060 - 0x0070)
class UAkRtpc : public UAkObject
{
public:
	float                                              MinRange;                                      // 0x0060 (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	float                                              MaxRange;                                      // 0x0064 (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	float                                              Default;                                       // 0x0068 (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkRtpc");
		}

		return uClassPointer;
	};

};

// Class Engine.AkState
// 0x0010 (0x0060 - 0x0070)
class UAkState : public UAkObject
{
public:
	class UAkStateGroup*                               StateGroup;                                    // 0x0060 (0x0008) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bIsGroupNone : 1;                              // 0x0068 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkState");
		}

		return uClassPointer;
	};

};

// Class Engine.AkStateGroup
// 0x0018 (0x0060 - 0x0078)
class UAkStateGroup : public UAkObject
{
public:
	class TArray<class UAkState*>                      ChildStates;                                   // 0x0060 (0x0010) [0x0000000000420003] (CPF_Edit | CPF_Const | CPF_EditConst | CPF_NeedCtorLink)
	class UAkState*                                    NoneState;                                     // 0x0070 (0x0008) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkStateGroup");
		}

		return uClassPointer;
	};

};

// Class Engine.AkSwitch
// 0x0008 (0x0060 - 0x0068)
class UAkSwitch : public UAkObject
{
public:
	class UAkSwitchGroup*                              SwitchGroup;                                   // 0x0060 (0x0008) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkSwitch");
		}

		return uClassPointer;
	};

};

// Class Engine.AkSwitchGroup
// 0x0000 (0x0060 - 0x0060)
class UAkSwitchGroup : public UAkObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkSwitchGroup");
		}

		return uClassPointer;
	};

};

// Class Engine.AkTrigger
// 0x0000 (0x0060 - 0x0060)
class UAkTrigger : public UAkObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkTrigger");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimationCompressionAlgorithm
// 0x0018 (0x0058 - 0x0070)
class UAnimationCompressionAlgorithm : public UObject
{
public:
	class FString                                      Description;                                   // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bNeedsSkeleton : 1;                            // 0x0068 (0x0004) [0x0000000000000000] [0x00000001] 
	EValidTranslationCompressionFormats                TranslationCompressionChoice;                  // 0x006C (0x0001) [0x0000000000000001] (CPF_Edit)    
	EValidRotationCompressionFormats                   RotationCompressionChoice;                     // 0x006D (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimationCompressionAlgorithm");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimationCompressionAlgorithm_Automatic
// 0x0008 (0x0070 - 0x0078)
class UAnimationCompressionAlgorithm_Automatic : public UAnimationCompressionAlgorithm
{
public:
	float                                              MaxEndEffectorError;                           // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bTryFixedBitwiseCompression : 1;               // 0x0074 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bTryPerTrackBitwiseCompression : 1;            // 0x0074 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bTryLinearKeyRemovalCompression : 1;           // 0x0074 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bTryIntervalKeyRemoval : 1;                    // 0x0074 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bRunCurrentDefaultCompressor : 1;              // 0x0074 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bAutoReplaceIfExistingErrorTooGreat : 1;       // 0x0074 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bRaiseMaxErrorToExisting : 1;                  // 0x0074 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimationCompressionAlgorithm_Automatic");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimationCompressionAlgorithm_BitwiseCompressOnly
// 0x0000 (0x0070 - 0x0070)
class UAnimationCompressionAlgorithm_BitwiseCompressOnly : public UAnimationCompressionAlgorithm
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimationCompressionAlgorithm_BitwiseCompressOnly");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimationCompressionAlgorithm_GBXCustom
// 0x0010 (0x0070 - 0x0080)
class UAnimationCompressionAlgorithm_GBXCustom : public UAnimationCompressionAlgorithm
{
public:
	int32_t                                            MinKeys;                                       // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bStartAtSecondKey : 1;                         // 0x0074 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bKeepLastKey : 1;                              // 0x0074 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              MaxPosDiff;                                    // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxAngleDiff;                                  // 0x007C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimationCompressionAlgorithm_GBXCustom");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimationCompressionAlgorithm_LeastDestructive
// 0x0000 (0x0070 - 0x0070)
class UAnimationCompressionAlgorithm_LeastDestructive : public UAnimationCompressionAlgorithm
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimationCompressionAlgorithm_LeastDestructive");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimationCompressionAlgorithm_RemoveEverySecondKey
// 0x0008 (0x0070 - 0x0078)
class UAnimationCompressionAlgorithm_RemoveEverySecondKey : public UAnimationCompressionAlgorithm
{
public:
	int32_t                                            MinKeys;                                       // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bStartAtSecondKey : 1;                         // 0x0074 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimationCompressionAlgorithm_RemoveEverySecondKey");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimationCompressionAlgorithm_RemoveLinearKeys
// 0x0020 (0x0070 - 0x0090)
class UAnimationCompressionAlgorithm_RemoveLinearKeys : public UAnimationCompressionAlgorithm
{
public:
	float                                              MaxPosDiff;                                    // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxAngleDiff;                                  // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxEffectorDiff;                               // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MinEffectorDiff;                               // 0x007C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              EffectorDiffSocket;                            // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ParentKeyScale;                                // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bRetarget : 1;                                 // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bActuallyFilterLinearKeys : 1;                 // 0x0088 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimationCompressionAlgorithm_RemoveLinearKeys");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimationCompressionAlgorithm_PerTrackCompression
// 0x0060 (0x0090 - 0x00F0)
class UAnimationCompressionAlgorithm_PerTrackCompression : public UAnimationCompressionAlgorithm_RemoveLinearKeys
{
public:
	float                                              MaxZeroingThreshold;                           // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxPosDiffBitwise;                             // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxAngleDiffBitwise;                           // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<EAnimationCompressionFormat>          AllowedRotationFormats;                        // 0x00A0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<EAnimationCompressionFormat>          AllowedTranslationFormats;                     // 0x00B0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bResampleAnimation : 1;                        // 0x00C0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseAdaptiveError : 1;                         // 0x00C0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bUseOverrideForEndEffectors : 1;               // 0x00C0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bUseAdaptiveError2 : 1;                        // 0x00C0 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	float                                              ResampledFramerate;                            // 0x00C4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MinKeysForResampling;                          // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            TrackHeightBias;                               // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ParentingDivisor;                              // 0x00D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ParentingDivisorExponent;                      // 0x00D4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RotationErrorSourceRatio;                      // 0x00D8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TranslationErrorSourceRatio;                   // 0x00DC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxErrorPerTrackRatio;                         // 0x00E0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              PerturbationProbeSize;                         // 0x00E4 (0x0004) [0x0000000000000000]               
	struct FPointer                                    PerReductionCachedData;                        // 0x00E8 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimationCompressionAlgorithm_PerTrackCompression");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimationCompressionAlgorithm_RemoveTrivialKeys
// 0x0008 (0x0070 - 0x0078)
class UAnimationCompressionAlgorithm_RemoveTrivialKeys : public UAnimationCompressionAlgorithm
{
public:
	float                                              MaxPosDiff;                                    // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxAngleDiff;                                  // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimationCompressionAlgorithm_RemoveTrivialKeys");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimationCompressionAlgorithm_RevertToRaw
// 0x0000 (0x0070 - 0x0070)
class UAnimationCompressionAlgorithm_RevertToRaw : public UAnimationCompressionAlgorithm
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimationCompressionAlgorithm_RevertToRaw");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimMetaData
// 0x0000 (0x0058 - 0x0058)
class UAnimMetaData : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimMetaData");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimMetaData_SkelControl
// 0x0020 (0x0058 - 0x0078)
class UAnimMetaData_SkelControl : public UAnimMetaData
{
public:
	class TArray<struct FName>                         SkelControlNameList;                           // 0x0058 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bFullControlOverController : 1;                // 0x0068 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FName                                       SkelControlName;                               // 0x006C (0x0008) [0x0000000020000000]  CPF_Deprecated)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimMetaData_SkelControl");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimMetaData_SkelControlKeyFrame
// 0x0010 (0x0078 - 0x0088)
class UAnimMetaData_SkelControlKeyFrame : public UAnimMetaData_SkelControl
{
public:
	class TArray<struct FTimeModifier>                 KeyFrames;                                     // 0x0078 (0x0010) [0x0000000004400001] (CPF_Edit | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimMetaData_SkelControlKeyFrame");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify
// 0x0000 (0x0058 - 0x0058)
class UAnimNotify : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify");
		}

		return uClassPointer;
	};

	bool FindNextNotifyOfClass(class UAnimNodeSequence* AnimSeqInstigator, class UClass* NotifyClass, struct FAnimNotifyEvent& OutEvent);
};

// Class Engine.AnimNotify_AkEvent
// 0x0018 (0x0058 - 0x0070)
class UAnimNotify_AkEvent : public UAnimNotify
{
public:
	class UAkEvent*                                    AkEvent;                                       // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       TargetInstanceDataName;                        // 0x0060 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bRestrictPerspective : 1;                      // 0x0068 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_AkEvent");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify_AkEvent_AtLocation
// 0x0018 (0x0058 - 0x0070)
class UAnimNotify_AkEvent_AtLocation : public UAnimNotify
{
public:
	class UAkEvent*                                    AkEvent;                                       // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bAttach : 1;                                   // 0x0060 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bRestrictPerspective : 1;                      // 0x0060 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	struct FName                                       BoneOrSocketName;                              // 0x0064 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_AkEvent_AtLocation");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify_CameraEffect
// 0x0008 (0x0058 - 0x0060)
class UAnimNotify_CameraEffect : public UAnimNotify
{
public:
	class UClass*                                      CameraLensEffect;                              // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_CameraEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify_ClothingMaxDistanceScale
// 0x0010 (0x0058 - 0x0068)
class UAnimNotify_ClothingMaxDistanceScale : public UAnimNotify
{
public:
	float                                              StartScale;                                    // 0x0058 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              EndScale;                                      // 0x005C (0x0004) [0x0000000000000001] (CPF_Edit)    
	EMaxDistanceScaleMode                              ScaleMode;                                     // 0x0060 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              Duration;                                      // 0x0064 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_ClothingMaxDistanceScale");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify_Foley
// 0x0038 (0x0058 - 0x0090)
class UAnimNotify_Foley : public UAnimNotify
{
public:
	class UAkEvent*                                    AkEvent;                                       // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              Pitch;                                         // 0x0060 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Volume;                                        // 0x0064 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       BoneOrSocketName;                              // 0x0068 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bRestrictPerspective : 1;                      // 0x0070 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FFoleyParameterDetails                      DetailedSettings;                              // 0x0074 (0x0018) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_Foley");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify_Footstep
// 0x0028 (0x0058 - 0x0080)
class UAnimNotify_Footstep : public UAnimNotify
{
public:
	int32_t                                            FootDown;                                      // 0x0058 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Volume;                                        // 0x005C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Pitch;                                         // 0x0060 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FFoleyParameterDetails                      DetailedSettings;                              // 0x0064 (0x0018) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_Footstep");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify_ForceField
// 0x0020 (0x0058 - 0x0078)
class UAnimNotify_ForceField : public UAnimNotify
{
public:
	class UNxForceFieldComponent*                      ForceFieldComponent;                           // 0x0058 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)
	uint32_t                                           bAttach : 1;                                   // 0x0060 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FName                                       SocketName;                                    // 0x0064 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       BoneName;                                      // 0x006C (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_ForceField");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify_Kismet
// 0x0008 (0x0058 - 0x0060)
class UAnimNotify_Kismet : public UAnimNotify
{
public:
	struct FName                                       NotifyName;                                    // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_Kismet");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify_PlayParticleEffect
// 0x0038 (0x0058 - 0x0090)
class UAnimNotify_PlayParticleEffect : public UAnimNotify
{
public:
	class UParticleSystem*                             PSTemplate;                                    // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bIsExtremeContent : 1;                         // 0x0060 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAttach : 1;                                   // 0x0060 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bPreview : 1;                                  // 0x0060 (0x0004) [0x0000000800000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bSkipIfOwnerIsHidden : 1;                      // 0x0060 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bOwnerNoSee : 1;                               // 0x0060 (0x0004) [0x0000000020000000] [0x00000010]  CPF_Deprecated)
	uint32_t                                           bOnlyOwnerSee : 1;                             // 0x0060 (0x0004) [0x0000000020000000] [0x00000020]  CPF_Deprecated)
	uint32_t                                           bUseOwnerSeeFlags : 1;                         // 0x0060 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	class UParticleSystem*                             PSNonExtremeContentTemplate;                   // 0x0068 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       SocketName;                                    // 0x0070 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       BoneName;                                      // 0x0078 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       BoneSocketModuleActorName;                     // 0x0080 (0x0008) [0x0000000000000001] (CPF_Edit)    
	ESceneViewSeeType                                  ViewSeeType;                                   // 0x0088 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ESceneDepthPriorityGroup                           EffectDepthPriorityGroup;                      // 0x0089 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            SortPriority;                                  // 0x008C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_PlayParticleEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify_Rumble
// 0x0018 (0x0058 - 0x0070)
class UAnimNotify_Rumble : public UAnimNotify
{
public:
	class UClass*                                      PredefinedWaveForm;                            // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UForceFeedbackWaveform*                      WaveForm;                                      // 0x0060 (0x0008) [0x0000000004000001] (CPF_Edit | CPF_EditInline)
	uint32_t                                           bCheckForBasedPlayer : 1;                      // 0x0068 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              EffectRadius;                                  // 0x006C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_Rumble");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify_Script
// 0x0018 (0x0058 - 0x0070)
class UAnimNotify_Script : public UAnimNotify
{
public:
	struct FName                                       NotifyName;                                    // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       NotifyTickName;                                // 0x0060 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       NotifyEndName;                                 // 0x0068 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_Script");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNotify_Scripted
// 0x0000 (0x0058 - 0x0058)
class UAnimNotify_Scripted : public UAnimNotify
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_Scripted");
		}

		return uClassPointer;
	};

	void eventNotifyEnd(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
	void eventNotify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
};

// Class Engine.AnimNotify_PawnMaterialParam
// 0x0010 (0x0058 - 0x0068)
class UAnimNotify_PawnMaterialParam : public UAnimNotify_Scripted
{
public:
	class TArray<struct FScalarParameterInterpStruct>  ScalarParameterInterpArray;                    // 0x0058 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_PawnMaterialParam");
		}

		return uClassPointer;
	};

	void eventNotify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
};

// Class Engine.AnimNotify_PlayFaceFXAnim
// 0x0038 (0x0058 - 0x0090)
class UAnimNotify_PlayFaceFXAnim : public UAnimNotify_Scripted
{
public:
	class UFaceFXAnimSet*                              FaceFXAnimSetRef;                              // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class FString                                      GroupName;                                     // 0x0060 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class FString                                      AnimName;                                      // 0x0070 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class UAkEvent*                                    AkEventToPlay;                                 // 0x0080 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bOverridePlayingAnim : 1;                      // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              PlayFrequency;                                 // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_PlayFaceFXAnim");
		}

		return uClassPointer;
	};

	void eventNotify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
};

// Class Engine.AnimNotify_ViewShake
// 0x0058 (0x0058 - 0x00B0)
class UAnimNotify_ViewShake : public UAnimNotify_Scripted
{
public:
	float                                              Duration;                                      // 0x0058 (0x0004) [0x0000000000020000] (CPF_EditConst)
	struct FVector                                     RotAmplitude;                                  // 0x005C (0x000C) [0x0000000000020000] (CPF_EditConst)
	struct FVector                                     RotFrequency;                                  // 0x0068 (0x000C) [0x0000000000020000] (CPF_EditConst)
	struct FVector                                     LocAmplitude;                                  // 0x0074 (0x000C) [0x0000000000020000] (CPF_EditConst)
	struct FVector                                     LocFrequency;                                  // 0x0080 (0x000C) [0x0000000000020000] (CPF_EditConst)
	float                                              FOVAmplitude;                                  // 0x008C (0x0004) [0x0000000000020000] (CPF_EditConst)
	float                                              FOVFrequency;                                  // 0x0090 (0x0004) [0x0000000000020000] (CPF_EditConst)
	uint32_t                                           bDoControllerVibration : 1;                    // 0x0094 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseBoneLocation : 1;                          // 0x0094 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              ShakeRadius;                                   // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       BoneName;                                      // 0x009C (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UCameraShake*                                ShakeParams;                                   // 0x00A8 (0x0008) [0x0000000004400009] (CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_ViewShake");
		}

		return uClassPointer;
	};

	void eventNotify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
};

// Class Engine.AnimNotify_Trails
// 0x0070 (0x0058 - 0x00C8)
class UAnimNotify_Trails : public UAnimNotify
{
public:
	class UParticleSystem*                             PSTemplate;                                    // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bIsExtremeContent : 1;                         // 0x0060 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bPreview : 1;                                  // 0x0060 (0x0004) [0x0000000800000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bSkipIfOwnerIsHidden : 1;                      // 0x0060 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bOwnerNoSee : 1;                               // 0x0060 (0x0004) [0x0000000020000000] [0x00000008]  CPF_Deprecated)
	uint32_t                                           bOnlyOwnerSee : 1;                             // 0x0060 (0x0004) [0x0000000020000000] [0x00000010]  CPF_Deprecated)
	uint32_t                                           bUseOwnerSeeFlags : 1;                         // 0x0060 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bResampleRequired : 1;                         // 0x0060 (0x0004) [0x0000000000000000] [0x00000040] 
	struct FName                                       FirstEdgeSocketName;                           // 0x0064 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       ControlPointSocketName;                        // 0x006C (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       SecondEdgeSocketName;                          // 0x0074 (0x0008) [0x0000000000000001] (CPF_Edit)    
	ESceneViewSeeType                                  ViewSeeType;                                   // 0x007C (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              LastStartTime;                                 // 0x0080 (0x0004) [0x0000000000000000]               
	float                                              EndTime;                                       // 0x0084 (0x0004) [0x0000000000000000]               
	float                                              SampleTimeStep;                                // 0x0088 (0x0004) [0x0000000020000000]  CPF_Deprecated)
	class TArray<struct FTrailSamplePoint>             TrailSampleData;                               // 0x0090 (0x0010) [0x0000000020400000] (CPF_NeedCtorLink | CPF_Deprecated)
	float                                              SamplesPerSecond;                              // 0x00A0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FTrailSample>                  TrailSampledData;                              // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              CurrentTime;                                   // 0x00B8 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              TimeStep;                                      // 0x00BC (0x0004) [0x0000000000002000] (CPF_Transient)
	class UAnimNodeSequence*                           AnimNodeSeq;                                   // 0x00C0 (0x0008) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNotify_Trails");
		}

		return uClassPointer;
	};

	int32_t GetNumSteps(int32_t InLastTrailIndex);
};

// Class Engine.AnimObject
// 0x0008 (0x0058 - 0x0060)
class UAnimObject : public UObject
{
public:
	class USkeletalMeshComponent*                      SkelComponent;                                 // 0x0058 (0x0008) [0x000000000428200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimObject");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNode
// 0x00A0 (0x0060 - 0x0100)
class UAnimNode : public UAnimObject
{
public:
	uint32_t                                           bRelevant : 1;                                 // 0x0060 (0x0004) [0x0000000000002002] [0x00000001] (CPF_Const | CPF_Transient)
	uint32_t                                           bJustBecameRelevant : 1;                       // 0x0060 (0x0004) [0x0000000000002002] [0x00000002] (CPF_Const | CPF_Transient)
	uint32_t                                           bTickDuringPausedAnims : 1;                    // 0x0060 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bEditorOnly : 1;                               // 0x0060 (0x0004) [0x0000000000000002] [0x00000008] (CPF_Const)
	uint32_t                                           bDisableCaching : 1;                           // 0x0060 (0x0004) [0x0000000000002002] [0x00000010] (CPF_Const | CPF_Transient)
	uint32_t                                           bCallScriptEventOnInit : 1;                    // 0x0060 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bCallScriptEventOnBecomeRelevant : 1;          // 0x0060 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bCallScriptEventOnCeaseRelevant : 1;           // 0x0060 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	int32_t                                            NodeTickTag;                                   // 0x0064 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            NodeInitTag;                                   // 0x0068 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            TickArrayIndex;                                // 0x006C (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            NodeCachedAtomsTag;                            // 0x0070 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              NodeTotalWeight;                               // 0x0074 (0x0004) [0x0000000000000002] (CPF_Const)   
	class TArray<class UAnimNodeBlendBase*>            ParentNodes;                                   // 0x0078 (0x0010) [0x0000000000600000] (CPF_NeedCtorLink)
	struct FName                                       NodeName;                                      // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FBoneAtom>                     CachedBoneAtoms;                               // 0x0090 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	uint8_t                                            CachedNumDesiredBones;                         // 0x00A0 (0x0001) [0x0000000000002000] (CPF_Transient)
	uint8_t                                           UnknownData00[0xF];                            // 0x00A1 (0x000F) MISSED OFFSET
	struct FBoneAtom                                   CachedRootMotionDelta;                         // 0x00B0 (0x0020) [0x0000000000002000] (CPF_Transient)
	int32_t                                            bCachedHasRootMotion;                          // 0x00D0 (0x0004) [0x0000000000002000] (CPF_Transient)
	class TArray<struct FCurveKey>                     CachedCurveKeys;                               // 0x00D8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	int32_t                                            SearchTag;                                     // 0x00E8 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FPointer                                    DataGroup;                                     // 0x00F0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FName                                       DataGroupName;                                 // 0x00F8 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNode");
		}

		return uClassPointer;
	};

	void ReplayAnim();
	void StopAnim();
	void PlayAnim(bool optionalBLoop, float optionalRate, float optionalStartTime);
	void FindAllAnimNodes(const struct FName& InNodeName, class TArray<class UAnimNode*>& AnimNodeList);
	class UAnimNode* FindAnimNode(const struct FName& InNodeName);
	void eventOnCeaseRelevant();
	void eventOnBecomeRelevant();
	void eventOnInit();
};

// Class Engine.AnimNodeBlendBase
// 0x0050 (0x0100 - 0x0150)
class UAnimNodeBlendBase : public UAnimNode
{
public:
	class TArray<struct FAnimBlendChild>               Children;                                      // 0x0100 (0x0010) [0x0000000004400048] (CPF_ExportObject | CPF_EditConstArray | CPF_NeedCtorLink | CPF_EditInline)
	uint32_t                                           bFixNumChildren : 1;                           // 0x0110 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bForceMeshSpaceBlend : 1;                      // 0x0110 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           Calculate : 1;                                 // 0x0110 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	EAlphaBlendType                                    BlendType;                                     // 0x0114 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EAnimBlendMode                                     BlendMode;                                     // 0x0115 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FBoneSet                                    AffectedBones;                                 // 0x0118 (0x0030) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FPointer                                    UseAffectedBones;                              // 0x0148 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeBlendBase");
		}

		return uClassPointer;
	};

	void ReplayAnim();
	void StopAnim();
	void PlayAnim(bool optionalBLoop, float optionalRate, float optionalStartTime);
};

// Class Engine.AnimNode_MultiBlendPerBone
// 0x0020 (0x0150 - 0x0170)
class UAnimNode_MultiBlendPerBone : public UAnimNodeBlendBase
{
public:
	class APawn*                                       PawnOwner;                                     // 0x0150 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class TArray<struct FPerBoneMaskInfo>              MaskList;                                      // 0x0158 (0x0010) [0x0000000004400041] (CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink | CPF_EditInline)
	EBlendType                                         RotationBlendType;                             // 0x0168 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNode_MultiBlendPerBone");
		}

		return uClassPointer;
	};

	void SetMaskWeight(int32_t MaskIndex, float DesiredWeight, float BlendTime);
};

// Class Engine.AnimNodeAimOffset
// 0x0080 (0x0150 - 0x01D0)
class UAnimNodeAimOffset : public UAnimNodeBlendBase
{
public:
	struct FVector2D                                   Aim;                                           // 0x0150 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   AngleOffset;                                   // 0x0158 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bForceAimDir : 1;                              // 0x0160 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseFixup : 1;                                 // 0x0160 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bBakeFromAnimations : 1;                       // 0x0160 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bPassThroughWhenNotRendered : 1;               // 0x0160 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bSynchronizeNodesInEditor : 1;                 // 0x0160 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bBlendInLocalSpace : 1;                        // 0x0160 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bMoreAccurateAndMoreExpensive : 1;             // 0x0160 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	int32_t                                            PassThroughAtOrAboveLOD;                       // 0x0164 (0x0004) [0x0000000000000001] (CPF_Edit)    
	EAnimAimDir                                        ForcedAimDir;                                  // 0x0168 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       FixupBoneName;                                 // 0x016C (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FName                                       CameraBoneOrSocketName;                        // 0x0174 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            CameraBoneIndex;                               // 0x017C (0x0004) [0x0000000000000000]               
	int32_t                                            FixupBoneIndex;                                // 0x0180 (0x0004) [0x0000000000000000]               
	class TArray<uint8_t>                              RequiredBones;                                 // 0x0188 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<uint8_t>                              AimCpntIndexLUT;                               // 0x0198 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class UAnimNodeAimOffset*                          TemplateNode;                                  // 0x01A8 (0x0008) [0x0000000000002000] (CPF_Transient)
	class TArray<struct FAimOffsetProfile>             Profiles;                                      // 0x01B0 (0x0010) [0x0000000000400041] (CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink)
	int32_t                                            CurrentProfileIndex;                           // 0x01C0 (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint8_t                                           UnknownData00[0xC];                            // 0x01C4 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeAimOffset");
		}

		return uClassPointer;
	};

	void SetActiveProfileByIndex(int32_t ProfileIndex);
	void SetActiveProfileByName(const struct FName& ProfileName);
};

// Class Engine.AnimNodeBlend
// 0x0010 (0x0150 - 0x0160)
class UAnimNodeBlend : public UAnimNodeBlendBase
{
public:
	float                                              Child2Weight;                                  // 0x0150 (0x0004) [0x0000000000000000]               
	float                                              Child2WeightTarget;                            // 0x0154 (0x0004) [0x0000000000000000]               
	float                                              BlendTimeToGo;                                 // 0x0158 (0x0004) [0x0000000000000000]               
	uint32_t                                           bSkipBlendWhenNotRendered : 1;                 // 0x015C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeBlend");
		}

		return uClassPointer;
	};

	void SetBlendTarget(float BlendTarget, float BlendTime);
};

// Class Engine.AnimNodeAdditiveBlending
// 0x0010 (0x0160 - 0x0170)
class UAnimNodeAdditiveBlending : public UAnimNodeBlend
{
public:
	uint32_t                                           bPassThroughWhenNotRendered : 1;               // 0x0160 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint8_t                                           UnknownData00[0xC];                            // 0x0164 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeAdditiveBlending");
		}

		return uClassPointer;
	};

	void SetBlendTarget(float BlendTarget, float BlendTime);
};

// Class Engine.AnimNodeBlendPerBone
// 0x0050 (0x0160 - 0x01B0)
class UAnimNodeBlendPerBone : public UAnimNodeBlend
{
public:
	uint32_t                                           bForceLocalSpaceBlend : 1;                     // 0x0160 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bForceCompleteMeshSpaceBlend : 1;              // 0x0160 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	class TArray<struct FName>                         BranchStartBoneName;                           // 0x0168 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<float>                                Child2PerBoneWeight;                           // 0x0178 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<uint8_t>                              LocalToCompReqBones;                           // 0x0188 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FName                                       MatchBoneName;                                 // 0x0198 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            MatchBoneIndex;                                // 0x01A0 (0x0004) [0x0000000000000000]               
	uint8_t                                           UnknownData00[0xC];                            // 0x01A4 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeBlendPerBone");
		}

		return uClassPointer;
	};

	void SetBlendTarget(float BlendTarget, float BlendTime);
};

// Class Engine.AnimNodeCrossfader
// 0x0010 (0x0160 - 0x0170)
class UAnimNodeCrossfader : public UAnimNodeBlend
{
public:
	struct FName                                       DefaultAnimSeqName;                            // 0x0160 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDontBlendOutOneShot : 1;                      // 0x0168 (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)
	float                                              PendingBlendOutTimeOneShot;                    // 0x016C (0x0004) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeCrossfader");
		}

		return uClassPointer;
	};

	class UAnimNodeSequence* GetActiveChild();
	struct FName GetAnimName();
	void BlendToLoopingAnim(const struct FName& AnimSeqName, float optionalBlendInTime, float optionalRate);
	void PlayOneShotAnim(const struct FName& AnimSeqName, float optionalBlendInTime, float optionalBlendOutTime, bool optionalBDontBlendOut, float optionalRate);
};

// Class Engine.AnimNodePlayCustomAnim
// 0x0010 (0x0160 - 0x0170)
class UAnimNodePlayCustomAnim : public UAnimNodeBlend
{
public:
	uint32_t                                           bIsPlayingCustomAnim : 1;                      // 0x0160 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              CustomPendingBlendOutTime;                     // 0x0164 (0x0004) [0x0000000000000000]               
	uint8_t                                           UnknownData00[0x8];                            // 0x0168 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodePlayCustomAnim");
		}

		return uClassPointer;
	};

	void SetRootBoneAxisOption(ERootBoneAxis optionalAxisX, ERootBoneAxis optionalAxisY, ERootBoneAxis optionalAxisZ);
	class UAnimNodeSequence* GetCustomAnimNodeSeq();
	void SetActorAnimEndNotification(bool bNewStatus);
	void SetCustomAnim(const struct FName& AnimName);
	void StopCustomAnim(float BlendOutTime);
	void PlayCustomAnimByDuration(const struct FName& AnimName, float Duration, float optionalBlendInTime, float optionalBlendOutTime, bool optionalBLooping, bool optionalBOverride);
	float PlayCustomAnim(const struct FName& AnimName, float Rate, float optionalBlendInTime, float optionalBlendOutTime, bool optionalBLooping, bool optionalBOverride);
};

// Class Engine.AnimNodeBlendDirectional
// 0x0020 (0x0150 - 0x0170)
class UAnimNodeBlendDirectional : public UAnimNodeBlendBase
{
public:
	float                                              DirDegreesPerSecond;                           // 0x0150 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DirAngle;                                      // 0x0154 (0x0004) [0x0000000000000000]               
	int32_t                                            SingleAnimAtOrAboveLOD;                        // 0x0158 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRotator                                    RotationOffset;                                // 0x015C (0x000C) [0x0000000000000000]               
	uint32_t                                           bUseAcceleration : 1;                          // 0x0168 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeBlendDirectional");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeBlendList
// 0x0050 (0x0150 - 0x01A0)
class UAnimNodeBlendList : public UAnimNodeBlendBase
{
public:
	class TArray<float>                                TargetWeight;                                  // 0x0150 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              BlendTimeToGo;                                 // 0x0160 (0x0004) [0x0000000000000000]               
	int32_t                                            ActiveChildIndex;                              // 0x0164 (0x0004) [0x0000000000000000]               
	int32_t                                            QueuedChildIndex;                              // 0x0168 (0x0004) [0x0000000000000000]               
	uint32_t                                           bPlayActiveChild : 1;                          // 0x016C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bForceChildFullWeightWhenBecomingRelevant : 1; // 0x016C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bSkipBlendWhenNotRendered : 1;                 // 0x016C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	float                                              SliderPosition;                                // 0x0170 (0x0004) [0x0000000000000002] (CPF_Const)   
	class TArray<struct FAnimBlendListChildTransitionInfo> ChildTransitionInfo;                           // 0x0178 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FBlendListChildData>           ChildAnimData;                                 // 0x0188 (0x0010) [0x0000000000602000] (CPF_Transient | CPF_NeedCtorLink)
	uint8_t                                           UnknownData00[0x8];                            // 0x0198 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeBlendList");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeBlendByBase
// 0x0030 (0x01A0 - 0x01D0)
class UAnimNodeBlendByBase : public UAnimNodeBlendList
{
public:
	EBaseBlendType                                     Type;                                          // 0x01A0 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       ActorTag;                                      // 0x01A4 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UClass*                                      ActorClass;                                    // 0x01B0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              BlendTime;                                     // 0x01B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class AActor*                                      CachedBase;                                    // 0x01C0 (0x0008) [0x0000000000002000] (CPF_Transient)
	uint8_t                                           UnknownData00[0x8];                            // 0x01C8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeBlendByBase");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeBlendByPhysics
// 0x0020 (0x01A0 - 0x01C0)
class UAnimNodeBlendByPhysics : public UAnimNodeBlendList
{
public:
	float                                              DelayBeforeStartingBlend;                      // 0x01A0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FFlag                                       WaitingToDoBlend;                              // 0x01A4 (0x0010) [0x0000000000002000] (CPF_Transient)
	uint8_t                                           UnknownData00[0xC];                            // 0x01B4 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeBlendByPhysics");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeBlendByPosture
// 0x0010 (0x01A0 - 0x01B0)
class UAnimNodeBlendByPosture : public UAnimNodeBlendList
{
public:
	uint32_t                                           bZeroPostSprintBlendWhenFiring : 1;            // 0x01A0 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint8_t                                           UnknownData00[0xC];                            // 0x01A4 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeBlendByPosture");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeBlendByProperty
// 0x0050 (0x01A0 - 0x01F0)
class UAnimNodeBlendByProperty : public UAnimNodeBlendList
{
public:
	struct FName                                       PropertyName;                                  // 0x01A0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUseOwnersBase : 1;                            // 0x01A8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bForceUpdate : 1;                              // 0x01A8 (0x0004) [0x0000000000002002] [0x00000002] (CPF_Const | CPF_Transient)
	uint32_t                                           bUseSpecificBlendTimes : 1;                    // 0x01A8 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bSynchronizeNodesInEditor : 1;                 // 0x01A8 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	struct FName                                       CachedPropertyName;                            // 0x01AC (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FPointer                                    CachedFloatProperty;                           // 0x01B8 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    CachedBoolProperty;                            // 0x01C0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    CachedByteProperty;                            // 0x01C8 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class AActor*                                      CachedOwner;                                   // 0x01D0 (0x0008) [0x0000000000002000] (CPF_Transient)
	float                                              BlendTime;                                     // 0x01D8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FloatPropMin;                                  // 0x01DC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FloatPropMax;                                  // 0x01E0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlendToChild1Time;                             // 0x01E4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlendToChild2Time;                             // 0x01E8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeBlendByProperty");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeBlendBySpeed
// 0x0040 (0x01A0 - 0x01E0)
class UAnimNodeBlendBySpeed : public UAnimNodeBlendList
{
public:
	float                                              Speed;                                         // 0x01A0 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            LastChannel;                                   // 0x01A4 (0x0004) [0x0000000000000000]               
	float                                              BlendUpTime;                                   // 0x01A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlendDownTime;                                 // 0x01AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlendDownPerc;                                 // 0x01B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<float>                                Constraints;                                   // 0x01B8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bUseAcceleration : 1;                          // 0x01C8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseBaseSkelComponentOwner : 1;                // 0x01C8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bIgnoreZ : 1;                                  // 0x01C8 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bRestartChildrenOnBlendUpFromZero : 1;         // 0x01C8 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	float                                              BlendUpDelay;                                  // 0x01CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlendDownDelay;                                // 0x01D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlendDelayRemaining;                           // 0x01D4 (0x0004) [0x0000000000002000] (CPF_Transient)
	uint8_t                                           UnknownData00[0x8];                            // 0x01D8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeBlendBySpeed");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeRandom
// 0x0020 (0x01A0 - 0x01C0)
class UAnimNodeRandom : public UAnimNodeBlendList
{
public:
	class TArray<struct FRandomAnimInfo>               RandomInfo;                                    // 0x01A0 (0x0010) [0x0000000004400041] (CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink | CPF_EditInline)
	class UAnimNodeSequence*                           PlayingSeqNode;                                // 0x01B0 (0x0008) [0x0000000000002000] (CPF_Transient)
	int32_t                                            PendingChildIndex;                             // 0x01B8 (0x0004) [0x0000000000002000] (CPF_Transient)
	uint32_t                                           bPickedPendingChildIndex : 1;                  // 0x01BC (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeRandom");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeBlendMultiBone
// 0x0020 (0x0150 - 0x0170)
class UAnimNodeBlendMultiBone : public UAnimNodeBlendBase
{
public:
	class TArray<struct FChildBoneBlendInfo>           BlendTargetList;                               // 0x0150 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<uint8_t>                              SourceRequiredBones;                           // 0x0160 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeBlendMultiBone");
		}

		return uClassPointer;
	};

	void SetTargetStartBone(int32_t TargetIdx, const struct FName& StartBoneName, float optionalPerBoneIncrease);
};

// Class Engine.AnimNodeMirror
// 0x0010 (0x0150 - 0x0160)
class UAnimNodeMirror : public UAnimNodeBlendBase
{
public:
	uint32_t                                           bEnableMirroring : 1;                          // 0x0150 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint8_t                                           UnknownData00[0xC];                            // 0x0154 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeMirror");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeScalePlayRate
// 0x0010 (0x0150 - 0x0160)
class UAnimNodeScalePlayRate : public UAnimNodeBlendBase
{
public:
	float                                              ScaleByValue;                                  // 0x0150 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData00[0xC];                            // 0x0154 (0x000C) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeScalePlayRate");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeScaleRateBySpeed
// 0x0010 (0x0160 - 0x0170)
class UAnimNodeScaleRateBySpeed : public UAnimNodeScalePlayRate
{
public:
	float                                              BaseSpeed;                                     // 0x0160 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUseBaseSkelComponentOwner : 1;                // 0x0164 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint8_t                                           UnknownData00[0x8];                            // 0x0168 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeScaleRateBySpeed");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeSlot
// 0x0040 (0x0150 - 0x0190)
class UAnimNodeSlot : public UAnimNodeBlendBase
{
public:
	uint32_t                                           bIsPlayingCustomAnim : 1;                      // 0x0150 (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)
	uint32_t                                           bEarlyAnimEndNotify : 1;                       // 0x0150 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bSkipBlendWhenNotRendered : 1;                 // 0x0150 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bAdditiveAnimationsOverrideSource : 1;         // 0x0150 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bIsBeingUsedByInterpGroup : 1;                 // 0x0150 (0x0004) [0x0000000000002002] [0x00000010] (CPF_Const | CPF_Transient)
	uint32_t                                           bReverseAnimSeqSearchOrder : 1;                // 0x0150 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	float                                              PendingBlendOutTime;                           // 0x0154 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            CustomChildIndex;                              // 0x0158 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            TargetChildIndex;                              // 0x015C (0x0004) [0x0000000000000002] (CPF_Const)   
	class TArray<float>                                TargetWeight;                                  // 0x0160 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              BlendTimeToGo;                                 // 0x0170 (0x0004) [0x0000000000000002] (CPF_Const)   
	class UAnimNodeSynch*                              SynchNode;                                     // 0x0178 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FAnimationDelegateBase                      OnAnimationEnded;                              // 0x0180 (0x0010) [0x0000000000001000] (CPF_Native)  

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeSlot");
		}

		return uClassPointer;
	};

	void TickChildWeights(float DeltaSeconds);
	void AddToSynchGroup(const struct FName& GroupName);
	void SetRootBoneRotationOption(ERootRotationOption optionalAxisX, ERootRotationOption optionalAxisY, ERootRotationOption optionalAxisZ);
	void SetRootBoneAxisOption(ERootBoneAxis optionalAxisX, ERootBoneAxis optionalAxisY, ERootBoneAxis optionalAxisZ);
	class UAnimNodeSequence* GetCustomAnimNodeSeq();
	void SetActorAnimEndNotification(bool bNewStatus);
	void SetCustomAnim(const struct FName& AnimName);
	void StopCustomAnim(float BlendOutTime);
	struct FName GetPlayedAnimation();
	bool PlayCustomAnimByDuration(const struct FName& AnimName, float Duration, float optionalBlendInTime, float optionalBlendOutTime, bool optionalBLooping, bool optionalBOverride);
	float PlayCustomAnim(const struct FName& AnimName, float Rate, float optionalBlendInTime, float optionalBlendOutTime, bool optionalBLooping, bool optionalBOverride, float optionalStartTime, float optionalEndTime);
};

// Class Engine.AnimNodeSynch
// 0x0010 (0x0150 - 0x0160)
class UAnimNodeSynch : public UAnimNodeBlendBase
{
public:
	class TArray<struct FSynchGroup>                   Groups;                                        // 0x0150 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeSynch");
		}

		return uClassPointer;
	};

	void SetGroupRateScale(const struct FName& GroupName, float NewRateScale);
	float GetRelativePosition(const struct FName& GroupName);
	void ForceRelativePosition(const struct FName& GroupName, float RelativePosition);
	class UAnimNodeSequence* GetMasterNodeOfGroup(const struct FName& GroupName);
	void RemoveNodeFromGroup(class UAnimNodeSequence* SeqNode, const struct FName& GroupName);
	void AddNodeToGroup(class UAnimNodeSequence* SeqNode, const struct FName& GroupName);
};

// Class Engine.AnimTree
// 0x00A0 (0x0150 - 0x01F0)
class UAnimTree : public UAnimNodeBlendBase
{
public:
	class UAnimTree*                                   AnimTreeTemplate;                              // 0x0150 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnablePooling : 1;                            // 0x0158 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseSavedPose : 1;                             // 0x0158 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bBeingEdited : 1;                              // 0x0158 (0x0004) [0x0000000800002000] [0x00000004] (CPF_Transient)
	uint32_t                                           bParentNodeArrayBuilt : 1;                     // 0x0158 (0x0004) [0x0000000000200000] [0x00000008] 
	uint32_t                                           bRebuildAnimTickArray : 1;                     // 0x0158 (0x0004) [0x0000000000000000] [0x00000010] 
	class TArray<struct FAnimGroup>                    AnimGroups;                                    // 0x0160 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FAnimDataGroup>                AnimDataGroups;                                // 0x0170 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FName>                         PrioritizedSkelBranches;                       // 0x0180 (0x0010) [0x0000000020400000] (CPF_NeedCtorLink | CPF_Deprecated)
	class TArray<struct FName>                         ComposePrePassBoneNames;                       // 0x0190 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FName>                         ComposePostPassBoneNames;                      // 0x01A0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UMorphNodeBase*>                RootMorphNodes;                                // 0x01B0 (0x0010) [0x0000000004400008] (CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<struct FSkelControlListHead>          SkelControlLists;                              // 0x01C0 (0x0010) [0x0000000004400008] (CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<struct FBoneAtom>                     SavedPose;                                     // 0x01D0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<class UAnimNode*>                     AnimTickArray;                                 // 0x01E0 (0x0010) [0x0000000000600000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimTree");
		}

		return uClassPointer;
	};

	int32_t GetGroupIndex(const struct FName& GroupName);
	float GetGroupRateScale(const struct FName& GroupName);
	void SetGroupRateScale(const struct FName& GroupName, float NewRateScale);
	float GetGroupRelativePosition(const struct FName& GroupName);
	void ForceGroupRelativePosition(const struct FName& GroupName, float RelativePosition);
	class UAnimNodeSequence* GetGroupNotifyMaster(const struct FName& GroupName);
	class UAnimNodeSequence* GetGroupSynchMaster(const struct FName& GroupName);
	bool SetAnimGroupForNode(class UAnimNodeSequence* SeqNode, const struct FName& GroupName, bool optionalBCreateIfNotFound);
	void SetUseSavedPose(bool bUseSaved);
	class UMorphNodeBase* FindMorphNode(const struct FName& InNodeName);
	class USkelControlBase* FindSkelControl(const struct FName& InControlName);
};

// Class Engine.AnimNodeSequence
// 0x0090 (0x0100 - 0x0190)
class UAnimNodeSequence : public UAnimNode
{
public:
	struct FName                                       AnimSeqName;                                   // 0x0100 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              Rate;                                          // 0x0108 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bPlaying : 1;                                  // 0x010C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bLooping : 1;                                  // 0x010C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bCauseActorAnimEnd : 1;                        // 0x010C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bCauseActorAnimPlay : 1;                       // 0x010C (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bZeroRootRotation : 1;                         // 0x010C (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bZeroRootTranslation : 1;                      // 0x010C (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bDisableWarningWhenAnimNotFound : 1;           // 0x010C (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bReverseAnimSeqSearchOrder : 1;                // 0x010C (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bNoNotifies : 1;                               // 0x010C (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bForceRefposeWhenNotPlaying : 1;               // 0x010C (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bIsIssuingNotifies : 1;                        // 0x010C (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bRestartOnBecomeRelevant : 1;                  // 0x010C (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bForceAlwaysSlave : 1;                         // 0x010C (0x0004) [0x0000000000000001] [0x00001000] (CPF_Edit)
	uint32_t                                           bSynchronize : 1;                              // 0x010C (0x0004) [0x0000000000000003] [0x00002000] (CPF_Edit | CPF_Const)
	uint32_t                                           bReverseSync : 1;                              // 0x010C (0x0004) [0x0000000000000003] [0x00004000] (CPF_Edit | CPF_Const)
	uint32_t                                           bShowTimeLineSlider : 1;                       // 0x010C (0x0004) [0x0000000000000001] [0x00008000] (CPF_Edit)
	uint32_t                                           bDisableAnimNotifies : 1;                      // 0x010C (0x0004) [0x0000000000000000] [0x00010000] 
	uint32_t                                           bLoopCameraAnim : 1;                           // 0x010C (0x0004) [0x0000000000000001] [0x00020000] (CPF_Edit)
	uint32_t                                           bRandomizeCameraAnimLoopStartTime : 1;         // 0x010C (0x0004) [0x0000000000000001] [0x00040000] (CPF_Edit)
	uint32_t                                           bApplyRootMotionOffset : 1;                    // 0x010C (0x0004) [0x0000000000002002] [0x00080000] (CPF_Const | CPF_Transient)
	uint32_t                                           bEditorOnlyAddRefPoseToAdditiveAnimation : 1;  // 0x010C (0x0004) [0x0000000000000002] [0x00100000] (CPF_Const)
	float                                              CurrentTime;                                   // 0x0110 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              PreviousTime;                                  // 0x0114 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              EndTime;                                       // 0x0118 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class UAnimSequence*                               AnimSeq;                                       // 0x0120 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            AnimLinkupIndex;                               // 0x0128 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              NotifyWeightThreshold;                         // 0x012C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       SynchGroupName;                                // 0x0130 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SynchPosOffset;                                // 0x0138 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UCameraAnim*                                 CameraAnim;                                    // 0x0140 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UCameraAnimInst*                             ActiveCameraAnimInstance;                      // 0x0148 (0x0008) [0x0000000000002000] (CPF_Transient)
	float                                              CameraAnimScale;                               // 0x0150 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CameraAnimPlayRate;                            // 0x0154 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CameraAnimBlendInTime;                         // 0x0158 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CameraAnimBlendOutTime;                        // 0x015C (0x0004) [0x0000000000000001] (CPF_Edit)    
	ERootBoneAxis                                      RootBoneOption[0x3];                           // 0x0160 (0x0003) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ERootRotationOption                                RootRotationOption[0x3];                       // 0x0163 (0x0003) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     ExpectedRootMotion;                            // 0x0168 (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FVector                                     AdditionalRootMotion;                          // 0x0174 (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class TArray<class USkelControlBase*>              MetaDataSkelControlList;                       // 0x0180 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeSequence");
		}

		return uClassPointer;
	};

	void SetRootBoneRotationOption(ERootRotationOption optionalAxisX, ERootRotationOption optionalAxisY, ERootRotationOption optionalAxisZ);
	void SetRootBoneAxisOption(ERootBoneAxis optionalAxisX, ERootBoneAxis optionalAxisY, ERootBoneAxis optionalAxisZ);
	float GetTimeLeft();
	float GetAnimPlaybackLength();
	float GetGlobalPlayRate();
	float GetGroupRelativePosition();
	float FindGroupPosition(float GroupRelativePosition);
	float FindGroupRelativePosition(float GroupRelativePosition);
	float GetNormalizedPosition();
	void SetPosition(float NewTime, bool bFireNotifies);
	void ReplayAnim();
	void StopAnim();
	void PlayAnim(bool optionalBLoop, float optionalInRate, float optionalStartTime);
	void SetAnim(const struct FName& Sequence);
};

// Class Engine.AnimNodeSequenceBlendBase
// 0x0010 (0x0190 - 0x01A0)
class UAnimNodeSequenceBlendBase : public UAnimNodeSequence
{
public:
	class TArray<struct FAnimBlendInfo>                Anims;                                         // 0x0190 (0x0010) [0x0000000004400049] (CPF_Edit | CPF_ExportObject | CPF_EditConstArray | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeSequenceBlendBase");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimNodeSequenceBlendByAim
// 0x0070 (0x01A0 - 0x0210)
class UAnimNodeSequenceBlendByAim : public UAnimNodeSequenceBlendBase
{
public:
	struct FVector2D                                   Aim;                                           // 0x01A0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   PreviousAim;                                   // 0x01A8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FVector2D                                   HorizontalRange;                               // 0x01B0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   VerticalRange;                                 // 0x01B8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   AngleOffset;                                   // 0x01C0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AnimName_LU;                                   // 0x01C8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AnimName_LC;                                   // 0x01D0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AnimName_LD;                                   // 0x01D8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AnimName_CU;                                   // 0x01E0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AnimName_CC;                                   // 0x01E8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AnimName_CD;                                   // 0x01F0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AnimName_RU;                                   // 0x01F8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AnimName_RC;                                   // 0x0200 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AnimName_RD;                                   // 0x0208 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimNodeSequenceBlendByAim");
		}

		return uClassPointer;
	};

	void CheckAnimsUpToDate();
};

// Class Engine.MorphNodeBase
// 0x0010 (0x0060 - 0x0070)
class UMorphNodeBase : public UAnimObject
{
public:
	struct FName                                       NodeName;                                      // 0x0060 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDrawSlider : 1;                               // 0x0068 (0x0004) [0x0000000000000000] [0x00000001] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MorphNodeBase");
		}

		return uClassPointer;
	};

};

// Class Engine.MorphNodeMultiPose
// 0x0030 (0x0070 - 0x00A0)
class UMorphNodeMultiPose : public UMorphNodeBase
{
public:
	class TArray<class UMorphTarget*>                  Targets;                                       // 0x0070 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FName>                         MorphNames;                                    // 0x0080 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<float>                                Weights;                                       // 0x0090 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MorphNodeMultiPose");
		}

		return uClassPointer;
	};

	bool UpdateMorphTarget(class UMorphTarget* Target, float InWeight);
	void RemoveMorphTarget(const struct FName& MorphTargetName);
	bool AddMorphTarget(const struct FName& MorphTargetName, float optionalInWeight);
};

// Class Engine.MorphNodePose
// 0x0018 (0x0070 - 0x0088)
class UMorphNodePose : public UMorphNodeBase
{
public:
	class UMorphTarget*                                Target;                                        // 0x0070 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FName                                       MorphName;                                     // 0x0078 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              Weight;                                        // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MorphNodePose");
		}

		return uClassPointer;
	};

	void SetMorphTarget(const struct FName& MorphTargetName);
};

// Class Engine.MorphNodeWeightBase
// 0x0010 (0x0070 - 0x0080)
class UMorphNodeWeightBase : public UMorphNodeBase
{
public:
	class TArray<struct FMorphNodeConn>                NodeConns;                                     // 0x0070 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MorphNodeWeightBase");
		}

		return uClassPointer;
	};

};

// Class Engine.MorphNodeWeight
// 0x0008 (0x0080 - 0x0088)
class UMorphNodeWeight : public UMorphNodeWeightBase
{
public:
	float                                              NodeWeight;                                    // 0x0080 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MorphNodeWeight");
		}

		return uClassPointer;
	};

	void SetNodeWeight(float NewWeight);
};

// Class Engine.MorphNodeWeightByBoneAngle
// 0x0048 (0x0080 - 0x00C8)
class UMorphNodeWeightByBoneAngle : public UMorphNodeWeightBase
{
public:
	float                                              Angle;                                         // 0x0080 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              NodeWeight;                                    // 0x0084 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FName                                       BaseBoneName;                                  // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              BaseBoneAxis;                                  // 0x0090 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              AngleBoneAxis;                                 // 0x0091 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bInvertBaseBoneAxis : 1;                       // 0x0094 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bInvertAngleBoneAxis : 1;                      // 0x0094 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bControlMaterialParameter : 1;                 // 0x0094 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	struct FName                                       AngleBoneName;                                 // 0x0098 (0x0008) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MaterialSlotId;                                // 0x00A0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       ScalarParameterName;                           // 0x00A4 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UMaterialInstance*                           MaterialInstanceConstant;                      // 0x00B0 (0x0008) [0x0000000000002000] (CPF_Transient)
	class TArray<struct FBoneAngleMorph>               WeightArray;                                   // 0x00B8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MorphNodeWeightByBoneAngle");
		}

		return uClassPointer;
	};

};

// Class Engine.MorphNodeWeightByBoneRotation
// 0x0040 (0x0080 - 0x00C0)
class UMorphNodeWeightByBoneRotation : public UMorphNodeWeightBase
{
public:
	float                                              Angle;                                         // 0x0080 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              NodeWeight;                                    // 0x0084 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FName                                       BoneName;                                      // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              BoneAxis;                                      // 0x0090 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bInvertBoneAxis : 1;                           // 0x0094 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bControlMaterialParameter : 1;                 // 0x0094 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	class TArray<struct FBoneAngleMorph>               WeightArray;                                   // 0x0098 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	int32_t                                            MaterialSlotId;                                // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       ScalarParameterName;                           // 0x00AC (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UMaterialInstance*                           MaterialInstanceConstant;                      // 0x00B8 (0x0008) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MorphNodeWeightByBoneRotation");
		}

		return uClassPointer;
	};

};

// Class Engine.SkelControlBase
// 0x0090 (0x0060 - 0x00F0)
class USkelControlBase : public UAnimObject
{
public:
	struct FName                                       ControlName;                                   // 0x0060 (0x0008) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            BoneIndex;                                     // 0x0068 (0x0004) [0x0000000000000000]               
	float                                              ControlStrength;                               // 0x006C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlendInTime;                                   // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlendOutTime;                                  // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	EAlphaBlendType                                    BlendType;                                     // 0x0078 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bPostPhysicsController : 1;                    // 0x007C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bSetStrengthFromAnimNode : 1;                  // 0x007C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bInitializedCachedNodeList : 1;                // 0x007C (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)
	uint32_t                                           bControlledByAnimMetada : 1;                   // 0x007C (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bInvertMetadataWeight : 1;                     // 0x007C (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bPropagateSetActive : 1;                       // 0x007C (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bIgnoreWhenNotRendered : 1;                    // 0x007C (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bShouldTickInScript : 1;                       // 0x007C (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bShouldTickOwner : 1;                          // 0x007C (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bEnableEaseInOut : 1;                          // 0x007C (0x0004) [0x0000000020020001] [0x00000200] (CPF_Edit | CPF_EditConst | CPF_Deprecated)
	float                                              StrengthTarget;                                // 0x0080 (0x0004) [0x0000000000000000]               
	float                                              BlendTimeToGo;                                 // 0x0084 (0x0004) [0x0000000000002000] (CPF_Transient)
	class TArray<struct FName>                         StrengthAnimNodeNameList;                      // 0x0088 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UAnimNode*>                     CachedNodeList;                                // 0x0098 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	float                                              AnimMetadataWeight;                            // 0x00A8 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            AnimMetaDataUpdateTag;                         // 0x00AC (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              BoneScale;                                     // 0x00B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            ControlTickTag;                                // 0x00B4 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            IgnoreAtOrAboveLOD;                            // 0x00B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class USkelControlBase*                            NextControl;                                   // 0x00C0 (0x0008) [0x0000000000000000]               
	class TArray<struct FSkelControlChild>             Children;                                      // 0x00C8 (0x0010) [0x0000000004400049] (CPF_Edit | CPF_ExportObject | CPF_EditConstArray | CPF_NeedCtorLink | CPF_EditInline)
	int32_t                                            ControlPosX;                                   // 0x00D8 (0x0004) [0x0000000020000000]  CPF_Deprecated)
	int32_t                                            ControlPosY;                                   // 0x00DC (0x0004) [0x0000000020000000]  CPF_Deprecated)
	class TArray<struct FBoneInfo>                     PostPoseFixupBones;                            // 0x00E0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControlBase");
		}

		return uClassPointer;
	};

	float GetControlMetadataWeight();
	void eventTickSkelControl(float DeltaTime, class USkeletalMeshComponent* SkelComp);
	void SetSkelControlStrength(float NewStrength, float InBlendTime);
	void SetSkelControlActive(bool bInActive);
};

// Class Engine.SkelControl_CCD_IK
// 0x0050 (0x00F0 - 0x0140)
class USkelControl_CCD_IK : public USkelControlBase
{
public:
	struct FVector                                     EffectorLocation;                              // 0x00F0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	EBoneControlSpace                                  EffectorLocationSpace;                         // 0x00FC (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       EffectorSpaceBoneName;                         // 0x0100 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     EffectorTranslationFromBone;                   // 0x0108 (0x000C) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            NumBones;                                      // 0x0114 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MaxPerBoneIterations;                          // 0x0118 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            IterationsCount;                               // 0x011C (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              Precision;                                     // 0x0120 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bStartFromTail : 1;                            // 0x0124 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bNoTurnOptimization : 1;                       // 0x0124 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	class TArray<float>                                AngleConstraint;                               // 0x0128 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	float                                              MaxAngleSteps;                                 // 0x0138 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControl_CCD_IK");
		}

		return uClassPointer;
	};

};

// Class Engine.SkelControl_Multiply
// 0x0008 (0x00F0 - 0x00F8)
class USkelControl_Multiply : public USkelControlBase
{
public:
	float                                              Multiplier;                                    // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControl_Multiply");
		}

		return uClassPointer;
	};

};

// Class Engine.SkelControl_TwistBone
// 0x0010 (0x00F0 - 0x0100)
class USkelControl_TwistBone : public USkelControlBase
{
public:
	struct FName                                       SourceBoneName;                                // 0x00F0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              TwistAngleScale;                               // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControl_TwistBone");
		}

		return uClassPointer;
	};

};

// Class Engine.SkelControlLimb
// 0x0068 (0x00F0 - 0x0158)
class USkelControlLimb : public USkelControlBase
{
public:
	struct FVector                                     EffectorLocation;                              // 0x00F0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FRotator                                    EffectorRotation;                              // 0x00FC (0x000C) [0x0000000000000001] (CPF_Edit)    
	EBoneControlSpace                                  EffectorLocationSpace;                         // 0x0108 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EBoneControlSpace                                  JointTargetLocationSpace;                      // 0x0109 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EBoneControlSpace                                  JointOffsetSpace;                              // 0x010A (0x0001) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              BoneAxis;                                      // 0x010B (0x0001) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              JointAxis;                                     // 0x010C (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       EffectorSpaceBoneName;                         // 0x0110 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     JointTargetLocation;                           // 0x0118 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       JointTargetSpaceBoneName;                      // 0x0124 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     JointOffset;                                   // 0x012C (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       JointOffsetBoneName;                           // 0x0138 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bInvertBoneAxis : 1;                           // 0x0140 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bInvertJointAxis : 1;                          // 0x0140 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bRotateJoint : 1;                              // 0x0140 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bMaintainEffectorRelRot : 1;                   // 0x0140 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bTakeRotationFromEffectorSpace : 1;            // 0x0140 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bAllowStretching : 1;                          // 0x0140 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           SupportGearboxTwistBones : 1;                  // 0x0140 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bTakeRotationFromEffectorRotation : 1;         // 0x0140 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bEffectorLocationComputed : 1;                 // 0x0140 (0x0004) [0x0000000000002000] [0x00000100] (CPF_Transient)
	struct FVector2D                                   StretchLimits;                                 // 0x0144 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       StretchRollBoneName;                           // 0x014C (0x0008) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            CachedTwistBoneIndex;                          // 0x0154 (0x0004) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControlLimb");
		}

		return uClassPointer;
	};

};

// Class Engine.SkelControlFootPlacement
// 0x0028 (0x0158 - 0x0180)
class USkelControlFootPlacement : public USkelControlLimb
{
public:
	float                                              FootOffset;                                    // 0x0158 (0x0004) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              FootUpAxis;                                    // 0x015C (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FRotator                                    FootRotOffset;                                 // 0x0160 (0x000C) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bInvertFootUpAxis : 1;                         // 0x016C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bOrientFootToGround : 1;                       // 0x016C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bOnlyEnableForUpAdjustment : 1;                // 0x016C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	float                                              MaxUpAdjustment;                               // 0x0170 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxDownAdjustment;                             // 0x0174 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxFootOrientAdjust;                           // 0x0178 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControlFootPlacement");
		}

		return uClassPointer;
	};

};

// Class Engine.SkelControlLookAt
// 0x00A8 (0x00F0 - 0x0198)
class USkelControlLookAt : public USkelControlBase
{
public:
	struct FVector                                     TargetLocation;                                // 0x00F0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	EBoneControlSpace                                  TargetLocationSpace;                           // 0x00FC (0x0001) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              LookAtAxis;                                    // 0x00FD (0x0001) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              UpAxis;                                        // 0x00FE (0x0001) [0x0000000000000001] (CPF_Edit)    
	EBoneControlSpace                                  AllowRotationSpace;                            // 0x00FF (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       TargetSpaceBoneName;                           // 0x0100 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bInvertLookAtAxis : 1;                         // 0x0108 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDefineUpAxis : 1;                             // 0x0108 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bInvertUpAxis : 1;                             // 0x0108 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bEnableLimit : 1;                              // 0x0108 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bLimitBasedOnRefPose : 1;                      // 0x0108 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bDisableBeyondLimit : 1;                       // 0x0108 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bNotifyBeyondLimit : 1;                        // 0x0108 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bShowLimit : 1;                                // 0x0108 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bAllowRotationX : 1;                           // 0x0108 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bAllowRotationY : 1;                           // 0x0108 (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bAllowRotationZ : 1;                           // 0x0108 (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	float                                              TargetLocationInterpSpeed;                     // 0x010C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRotator                                    TargetDirectionOffset;                         // 0x0110 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     DesiredTargetLocation;                         // 0x011C (0x000C) [0x0000000000000000]               
	struct FVector                                     ActorSpaceLookAtTarget;                        // 0x0128 (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              MaxAngle;                                      // 0x0134 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OuterMaxAngle;                                 // 0x0138 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DeadZoneAngle;                                 // 0x013C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   RotationAngleRangeX;                           // 0x0140 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   RotationAngleRangeY;                           // 0x0148 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   RotationAngleRangeZ;                           // 0x0150 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       AllowRotationOtherBoneName;                    // 0x0158 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              LookAtAlpha;                                   // 0x0160 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              LookAtAlphaTarget;                             // 0x0164 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              LookAtAlphaBlendTimeToGo;                      // 0x0168 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FVector                                     LimitLookDir;                                  // 0x016C (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FVector                                     BaseLookDir;                                   // 0x0178 (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FVector                                     BaseBonePos;                                   // 0x0184 (0x000C) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              LastCalcTime;                                  // 0x0190 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            ControlBoneIndex;                              // 0x0194 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControlLookAt");
		}

		return uClassPointer;
	};

	bool CanLookAtPoint(const struct FVector& PointLoc, bool optionalBDrawDebugInfo, bool optionalBDebugUsePersistentLines, bool optionalBDebugFlushLinesFirst);
	void SetLookAtAlpha(float DesiredAlpha, float DesiredBlendTime);
	void InterpolateTargetLocation(float DeltaTime);
	void SetTargetLocation(const struct FVector& NewTargetLocation);
};

// Class Engine.SkelControlSingleBone
// 0x0030 (0x00F0 - 0x0120)
class USkelControlSingleBone : public USkelControlBase
{
public:
	uint32_t                                           bApplyTranslation : 1;                         // 0x00F0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bApplyRotation : 1;                            // 0x00F0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bAddTranslation : 1;                           // 0x00F0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bAddRotation : 1;                              // 0x00F0 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bRemoveMeshRotation : 1;                       // 0x00F0 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	struct FVector                                     BoneTranslation;                               // 0x00F4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	EBoneControlSpace                                  BoneTranslationSpace;                          // 0x0100 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EBoneControlSpace                                  BoneRotationSpace;                             // 0x0101 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       TranslationSpaceBoneName;                      // 0x0104 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FRotator                                    BoneRotation;                                  // 0x010C (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       RotationSpaceBoneName;                         // 0x0118 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControlSingleBone");
		}

		return uClassPointer;
	};

};

// Class Engine.SkelControlHandlebars
// 0x0018 (0x0120 - 0x0138)
class USkelControlHandlebars : public USkelControlSingleBone
{
public:
	EAxis                                              WheelRollAxis;                                 // 0x0120 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              HandlebarRotateAxis;                           // 0x0121 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       WheelBoneName;                                 // 0x0124 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bInvertRotation : 1;                           // 0x012C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	int32_t                                            SteerWheelBoneIndex;                           // 0x0130 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControlHandlebars");
		}

		return uClassPointer;
	};

};

// Class Engine.SkelControlWheel
// 0x0018 (0x0120 - 0x0138)
class USkelControlWheel : public USkelControlSingleBone
{
public:
	float                                              WheelDisplacement;                             // 0x0120 (0x0004) [0x0000000000002001] (CPF_Edit | CPF_Transient)
	float                                              WheelMaxRenderDisplacement;                    // 0x0124 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelRoll;                                     // 0x0128 (0x0004) [0x0000000000002001] (CPF_Edit | CPF_Transient)
	EAxis                                              WheelRollAxis;                                 // 0x012C (0x0001) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              WheelSteeringAxis;                             // 0x012D (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelSteering;                                 // 0x0130 (0x0004) [0x0000000000002001] (CPF_Edit | CPF_Transient)
	uint32_t                                           bInvertWheelRoll : 1;                          // 0x0134 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bInvertWheelSteering : 1;                      // 0x0134 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControlWheel");
		}

		return uClassPointer;
	};

};

// Class Engine.SkelControlSpline
// 0x0018 (0x00F0 - 0x0108)
class USkelControlSpline : public USkelControlBase
{
public:
	int32_t                                            SplineLength;                                  // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              SplineBoneAxis;                                // 0x00F4 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ESplineControlRotMode                              BoneRotMode;                                   // 0x00F5 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bInvertSplineBoneAxis : 1;                     // 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              EndSplineTension;                              // 0x00FC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StartSplineTension;                            // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControlSpline");
		}

		return uClassPointer;
	};

};

// Class Engine.SkelControlTrail
// 0x0080 (0x00F0 - 0x0170)
class USkelControlTrail : public USkelControlBase
{
public:
	int32_t                                            ChainLength;                                   // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              ChainBoneAxis;                                 // 0x00F4 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bInvertChainBoneAxis : 1;                      // 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bLimitStretch : 1;                             // 0x00F8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bActorSpaceFakeVel : 1;                        // 0x00F8 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bHadValidStrength : 1;                         // 0x00F8 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              TrailRelaxation;                               // 0x00FC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StretchLimit;                                  // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     FakeVelocity;                                  // 0x0104 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              ThisTimstep;                                   // 0x0110 (0x0004) [0x0000000000000000]               
	class TArray<struct FVector>                       TrailBoneLocations;                            // 0x0118 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	uint8_t                                           UnknownData00[0x8];                            // 0x0128 (0x0008) MISSED OFFSET
	struct FMatrix                                     OldLocalToWorld;                               // 0x0130 (0x0040) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkelControlTrail");
		}

		return uClassPointer;
	};

};

// Class Engine.AnimSequence
// 0x0110 (0x0058 - 0x0168)
class UAnimSequence : public UObject
{
public:
	struct FName                                       SequenceName;                                  // 0x0058 (0x0008) [0x0000000000000000]               
	class TArray<struct FAnimNotifyEvent>              Notifies;                                      // 0x0060 (0x0010) [0x0000000004400001] (CPF_Edit | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UAnimMetaData*>                 MetaData;                                      // 0x0070 (0x0010) [0x0000000004400009] (CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<struct FSkelControlModifier>          BoneControlModifiers;                          // 0x0080 (0x0010) [0x0000000024400000] (CPF_NeedCtorLink | CPF_EditInline | CPF_Deprecated)
	float                                              SequenceLength;                                // 0x0090 (0x0004) [0x0000000000000000]               
	int32_t                                            NumFrames;                                     // 0x0094 (0x0004) [0x0000000000000000]               
	float                                              RateScale;                                     // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bNoLoopingInterpolation : 1;                   // 0x009C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bIsAdditive : 1;                               // 0x009C (0x0004) [0x0000000000000002] [0x00000002] (CPF_Const)
	uint32_t                                           bAdditiveBuiltLooping : 1;                     // 0x009C (0x0004) [0x0000000800000000] [0x00000004] 
	uint32_t                                           bDoNotOverrideCompression : 1;                 // 0x009C (0x0004) [0x0000000800000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           bHasBeenUsed : 1;                              // 0x009C (0x0004) [0x0000000000002002] [0x00000010] (CPF_Const | CPF_Transient)
	class TArray<struct FRawAnimSequenceTrack>         RawAnimData;                                   // 0x00A0 (0x0010) [0x0000000020400002] (CPF_Const | CPF_NeedCtorLink | CPF_Deprecated)
	class TArray<struct FRawAnimSequenceTrack>         RawAnimationData;                              // 0x00B0 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<struct FTranslationTrack>             TranslationData;                               // 0x00C0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FRotationTrack>                RotationData;                                  // 0x00D0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FCurveTrack>                   CurveData;                                     // 0x00E0 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	EAnimationCompressionFormat                        TranslationCompressionFormat;                  // 0x00F0 (0x0001) [0x0000000000000002] (CPF_Const)   
	EAnimationCompressionFormat                        RotationCompressionFormat;                     // 0x00F1 (0x0001) [0x0000000000000002] (CPF_Const)   
	EAnimationKeyFormat                                KeyEncodingFormat;                             // 0x00F2 (0x0001) [0x0000000000000002] (CPF_Const)   
	class TArray<int32_t>                              CompressedTrackOffsets;                        // 0x00F8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<uint8_t>                              CompressedByteStream;                          // 0x0108 (0x0010) [0x0000000000001000] (CPF_Native)  
	struct FPointer                                    TranslationCodec;                              // 0x0118 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)
	struct FPointer                                    RotationCodec;                                 // 0x0120 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)
	class TArray<struct FBoneAtom>                     AdditiveRefPose;                               // 0x0128 (0x0010) [0x0000000020400002] (CPF_Const | CPF_NeedCtorLink | CPF_Deprecated)
	class TArray<struct FRawAnimSequenceTrack>         AdditiveBasePose;                              // 0x0138 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	int32_t                                            EncodingPkgVersion;                            // 0x0148 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              UseScore;                                      // 0x014C (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              RootMotionOffsetStartPercent;                  // 0x0150 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              RootMotionOffsetStopPercent;                   // 0x0154 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<struct FDeltaTrackInfo>               DeltaTrackCache;                               // 0x0158 (0x0010) [0x0000000000003000] (CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimSequence");
		}

		return uClassPointer;
	};

	float GetNotifyTimeByClass(class UClass* NotifyClass, float optionalPlayRate, float optionalStartPosition, class UAnimNotify*& out_Notify, float& out_Duration);
};

// Class Engine.AnimSet
// 0x0128 (0x0058 - 0x0180)
class UAnimSet : public UObject
{
public:
	uint32_t                                           bAnimRotationOnly : 1;                         // 0x0058 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class TArray<struct FName>                         TrackBoneNames;                                // 0x0060 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<class UAnimSequence*>                 Sequences;                                     // 0x0070 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint8_t                                           UnknownData00[0x50];                           // 0x0080 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.AnimSet.SequenceCache
	class TArray<struct FAnimSetMeshLinkup>            LinkupCache;                                   // 0x00D0 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	uint8_t                                           UnknownData01[0x50];                           // 0x00E0 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.AnimSet.SkelMesh2LinkupCache
	class TArray<uint8_t>                              BoneUseAnimTranslation;                        // 0x0130 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<uint8_t>                              ForceUseMeshTranslation;                       // 0x0140 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FName>                         UseTranslationBoneNames;                       // 0x0150 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FName>                         ForceMeshTranslationBoneNames;                 // 0x0160 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FName                                       PreviewSkelMeshName;                           // 0x0170 (0x0008) [0x0000000000000000]               
	struct FName                                       BestRatioSkelMeshName;                         // 0x0178 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AnimSet");
		}

		return uClassPointer;
	};

};

// Class Engine.ApexAsset
// 0x0020 (0x0058 - 0x0078)
class UApexAsset : public UObject
{
public:
	class FString                                      OriginalApexName;                              // 0x0058 (0x0010) [0x0000000004400002] (CPF_Const | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UApexComponentBase*>            ApexComponents;                                // 0x0068 (0x0010) [0x000000000408300A] (CPF_Const | CPF_ExportObject | CPF_Native | CPF_Transient | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ApexAsset");
		}

		return uClassPointer;
	};

};

// Class Engine.ApexClothingAsset
// 0x0078 (0x0078 - 0x00F0)
class UApexClothingAsset : public UApexAsset
{
public:
	class TArray<struct FClothingLodInfo>              LodMaterialInfo;                               // 0x0078 (0x0010) [0x0000000000400043] (CPF_Edit | CPF_Const | CPF_EditConstArray | CPF_NeedCtorLink)
	struct FPointer                                    MApexAsset;                                    // 0x0088 (0x0008) [0x0000000000001000] (CPF_Native)  
	struct FPointer                                    MApexAssetFence;                               // 0x0090 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<class UMaterialInterface*>            Materials;                                     // 0x0098 (0x0010) [0x0000000000400043] (CPF_Edit | CPF_Const | CPF_EditConstArray | CPF_NeedCtorLink)
	class UApexGenericAsset*                           ApexClothingLibrary;                           // 0x00A8 (0x0008) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	uint32_t                                           bUseHardwareCloth : 1;                         // 0x00B0 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bFallbackSkinning : 1;                         // 0x00B0 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           bSlowStart : 1;                                // 0x00B0 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           bRecomputeNormals : 1;                         // 0x00B0 (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           bAllowAdaptiveTargetFrequency : 1;             // 0x00B0 (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	uint32_t                                           bResetAfterTeleport : 1;                       // 0x00B0 (0x0004) [0x0000000000000003] [0x00000020] (CPF_Edit | CPF_Const)
	uint32_t                                           bUseLocalSpaceSimulation : 1;                  // 0x00B0 (0x0004) [0x0000000000000003] [0x00000040] (CPF_Edit | CPF_Const)
	uint32_t                                           bHasUniqueAssetMaterialNames : 1;              // 0x00B0 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           IgnoreInitialTrigger : 1;                      // 0x00B0 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	int32_t                                            UVChannelForTangentUpdate;                     // 0x00B4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              MaxDistanceBlendTime;                          // 0x00B8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ContinuousRotationThreshold;                   // 0x00BC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ContinuousDistanceThreshold;                   // 0x00C0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LodWeightsMaxDistance;                         // 0x00C4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LodWeightsDistanceWeight;                      // 0x00C8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LodWeightsBias;                                // 0x00CC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LodWeightsBenefitsBias;                        // 0x00D0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LODDecayTime;                                  // 0x00D4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UAkEvent*                                    AudioOnStartMoving;                            // 0x00D8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UAkEvent*                                    AudioOnStopMoving;                             // 0x00E0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              SpeedThresholdOnMove;                          // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SpeedThresholdOnRest;                          // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ApexClothingAsset");
		}

		return uClassPointer;
	};

};

// Class Engine.ApexDestructibleAsset
// 0x0150 (0x0078 - 0x01C8)
class UApexDestructibleAsset : public UApexAsset
{
public:
	struct FPointer                                    MApexAsset;                                    // 0x0078 (0x0008) [0x0000000000001000] (CPF_Native)  
	class TArray<class UMaterialInterface*>            Materials;                                     // 0x0080 (0x0010) [0x0000000000400043] (CPF_Edit | CPF_Const | CPF_EditConstArray | CPF_NeedCtorLink)
	class TArray<class UFractureMaterial*>             FractureMaterials;                             // 0x0090 (0x0010) [0x0000000000400043] (CPF_Edit | CPF_Const | CPF_EditConstArray | CPF_NeedCtorLink)
	class UPhysicalMaterial*                           DefaultPhysMaterial;                           // 0x00A0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    MDestructibleThumbnailComponent;               // 0x00A8 (0x0008) [0x0000000000001000] (CPF_Native)  
	uint32_t                                           bHasUniqueAssetMaterialNames : 1;              // 0x00B0 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bDynamic : 1;                                  // 0x00B0 (0x0004) [0x0000000020000000] [0x00000002]  CPF_Deprecated)
	class FString                                      CrumbleEmitterName;                            // 0x00B8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class FString                                      DustEmitterName;                               // 0x00C8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FNxDestructibleParameters                   DestructibleParameters;                        // 0x00D8 (0x00F0) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ApexDestructibleAsset");
		}

		return uClassPointer;
	};

};

// Class Engine.ApexGenericAsset
// 0x0008 (0x0078 - 0x0080)
class UApexGenericAsset : public UApexAsset
{
public:
	struct FPointer                                    MApexAsset;                                    // 0x0078 (0x0008) [0x0000000000001000] (CPF_Native)  

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ApexGenericAsset");
		}

		return uClassPointer;
	};

};

// Class Engine.ApexDestructibleDamageParameters
// 0x0010 (0x0058 - 0x0068)
class UApexDestructibleDamageParameters : public UObject
{
public:
	class TArray<struct FDamagePair>                   DamageMap;                                     // 0x0058 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ApexDestructibleDamageParameters");
		}

		return uClassPointer;
	};

};

// Class Engine.AttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UAttributeContextResolver : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AttributeContextResolver");
		}

		return uClassPointer;
	};

	class UObject* eventGetAttributeContext(class UAttributeDefinitionBase* Attribute, class UObject* AttributeContextSource);
};

// Class Engine.BalancedActorAttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UBalancedActorAttributeContextResolver : public UAttributeContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BalancedActorAttributeContextResolver");
		}

		return uClassPointer;
	};

	class UObject* GetAttributeContext(class UAttributeDefinitionBase* Attribute, class UObject* AttributeContextSource);
};

// Class Engine.CharacterClassAttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UCharacterClassAttributeContextResolver : public UAttributeContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CharacterClassAttributeContextResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.ControllerAttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UControllerAttributeContextResolver : public UAttributeContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ControllerAttributeContextResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.GameInfoAttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UGameInfoAttributeContextResolver : public UAttributeContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GameInfoAttributeContextResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.GameReplicationInfoAttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UGameReplicationInfoAttributeContextResolver : public UAttributeContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GameReplicationInfoAttributeContextResolver");
		}

		return uClassPointer;
	};

	class UObject* GetAttributeContext(class UAttributeDefinitionBase* Attribute, class UObject* AttributeContextSource);
};

// Class Engine.OffHandWeaponAttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UOffHandWeaponAttributeContextResolver : public UAttributeContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OffHandWeaponAttributeContextResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.OwnerAttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UOwnerAttributeContextResolver : public UAttributeContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OwnerAttributeContextResolver");
		}

		return uClassPointer;
	};

	class UObject* GetAttributeContext(class UAttributeDefinitionBase* Attribute, class UObject* AttributeContextSource);
};

// Class Engine.PawnAttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UPawnAttributeContextResolver : public UAttributeContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PawnAttributeContextResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.ProjectileAttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UProjectileAttributeContextResolver : public UAttributeContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ProjectileAttributeContextResolver");
		}

		return uClassPointer;
	};

	class UObject* GetAttributeContext(class UAttributeDefinitionBase* Attribute, class UObject* AttributeContextSource);
};

// Class Engine.ResourcePoolAttributeContextResolver
// 0x0008 (0x0058 - 0x0060)
class UResourcePoolAttributeContextResolver : public UAttributeContextResolver
{
public:
	class UResourceDefinition*                         Resource;                                      // 0x0058 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ResourcePoolAttributeContextResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.VehicleAttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UVehicleAttributeContextResolver : public UAttributeContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.VehicleAttributeContextResolver");
		}

		return uClassPointer;
	};

	class UObject* GetAttributeContext(class UAttributeDefinitionBase* Attribute, class UObject* AttributeContextSource);
};

// Class Engine.WeaponAttributeContextResolver
// 0x0000 (0x0058 - 0x0058)
class UWeaponAttributeContextResolver : public UAttributeContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WeaponAttributeContextResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.WeaponResourcePoolAttributeContextResolver
// 0x0010 (0x0058 - 0x0068)
class UWeaponResourcePoolAttributeContextResolver : public UAttributeContextResolver
{
public:
	class UResourceDefinition*                         PrimaryHandResource;                           // 0x0058 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UResourceDefinition*                         OffHandResource;                               // 0x0060 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WeaponResourcePoolAttributeContextResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.AttributeEffect
// 0x0000 (0x0058 - 0x0058)
class UAttributeEffect : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AttributeEffect");
		}

		return uClassPointer;
	};

	static void RemoveAttributeEffects(class AActor* Owner, class TArray<struct FAppliedAttributeEffect>& EffectModifiers);
	static void ApplyAttributeEffects(class AActor* ContextSource, class UObject* optionalOptionalOverrideContextSource, class TArray<struct FAttributeEffectData>& InAttributeEffects, class TArray<struct FAppliedAttributeEffect>& OutModifiers);
};

// Class Engine.AttributeExpression
// 0x0000 (0x0058 - 0x0058)
class UAttributeExpression : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AttributeExpression");
		}

		return uClassPointer;
	};

	static class UAkEvent* SelectAkEvent(class UObject* ContextSource, class TArray<struct FConditionalSoundData>& SoundList);
	static bool EvaluateExpression(class UObject* ContextSource, class UObject* optionalOptionalOverrideContextSource, struct FAttributeExpressionData& Expression);
	static bool EvaluateExpressions(EExpressionEvaluationMode Mode, class UObject* ContextSource, class UObject* optionalOptionalOverrideContextSource, class TArray<struct FAttributeExpressionData>& Expressions);
};

// Class Engine.AttributeMultiContextResolver
// 0x0000 (0x0058 - 0x0058)
class UAttributeMultiContextResolver : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AttributeMultiContextResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.WeaponAttributeMultiContextResolver
// 0x0000 (0x0058 - 0x0058)
class UWeaponAttributeMultiContextResolver : public UAttributeMultiContextResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WeaponAttributeMultiContextResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.AttributeValueResolver
// 0x0000 (0x0058 - 0x0058)
class UAttributeValueResolver : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AttributeValueResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.ObjectPropertyAttributeValueResolver
// 0x0010 (0x0058 - 0x0068)
class UObjectPropertyAttributeValueResolver : public UAttributeValueResolver
{
public:
	struct FName                                       PropertyName;                                  // 0x0058 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UProperty*                                   CachedProperty;                                // 0x0060 (0x0008) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ObjectPropertyAttributeValueResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.ReadOnlyObjectPropertyAttributeValueResolver
// 0x0000 (0x0068 - 0x0068)
class UReadOnlyObjectPropertyAttributeValueResolver : public UObjectPropertyAttributeValueResolver
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ReadOnlyObjectPropertyAttributeValueResolver");
		}

		return uClassPointer;
	};

};

// Class Engine.BehaviorBase
// 0x0018 (0x0058 - 0x0070)
class UBehaviorBase : public UObject
{
public:
	struct FBehaviorContextData                        Context;                                       // 0x0058 (0x0018) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BehaviorBase");
		}

		return uClassPointer;
	};

	static bool IsBehaviorDebugEnabled();
	static void ToggleBehaviorDebug();
	int32_t GetParameterIndex(const struct FBehaviorParameters& EventData, const struct FName& ValueName);
	static bool StaticGetAllBehaviorContexts(class UObject* DebugCaller, class UObject* SelfObject, class UObject* optionalMyInstigatorObject, class UObject* optionalOtherEventParticipantObject, class TArray<class UObject*>& Contexts, struct FBehaviorContextData& ContextData, struct FBehaviorParameters& EventData);
	static class UObject* StaticGetBehaviorContext(class UObject* DebugCaller, class UObject* SelfObject, class UObject* optionalMyInstigatorObject, class UObject* optionalOtherEventParticipantObject, struct FBehaviorContextData& ContextData, struct FBehaviorParameters& EventData);
	class UObject* GetBehaviorContext(class UObject* SelfObject, class UObject* optionalMyInstigatorObject, class UObject* optionalOtherEventParticipantObject, struct FBehaviorContextData& ContextData, struct FBehaviorParameters& EventData);
	class UInterface* GetBehaviorContextInterface(class UClass* InterfaceClass, const struct FBehaviorContextData& ContextData, class UObject* SelfObject, class UObject* optionalMyInstigatorObject, class UObject* optionalOtherEventParticipantObject, const struct FBehaviorParameters& optionalEventData, class UObject*& ContextObject);
	void eventApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
	void eventApplyBehavior(class UObject* SelfObject, class UObject* optionalMyInstigatorObject, class UObject* optionalOtherEventParticipantObject, const struct FBehaviorParameters& optionalEventData, struct FBehaviorKernelInfo& KernelInfo);
	struct FImpactInfo GetImpactInfoParameter(const struct FBehaviorParameters& EventData, const struct FName& ValueName);
	class AActor* GetActorParameter(const struct FBehaviorParameters& EventData, const struct FName& ValueName);
	struct FVector GetVectorParameter(const struct FBehaviorParameters& EventData, const struct FName& ValueName);
	static void SetImpactInfoParameter(const struct FName& ValueName, const struct FImpactInfo& Value, struct FBehaviorParameters& EventData);
	static void SetActorParameter(const struct FName& ValueName, class AActor* Value, struct FBehaviorParameters& EventData);
	static void SetVectorParameter(const struct FName& ValueName, const struct FVector& Value, struct FBehaviorParameters& EventData);
	class AWorldInfo* GetWorldInfo();
	static void RunBehaviors(class UObject* SelfObject, class UObject* optionalMyInstigatorObject, class UObject* optionalOtherEventParticipantObject, const struct FBehaviorParameters& optionalEventData, class TArray<class UBehaviorBase*>& Behaviors);
};

// Class Engine.Behavior_AdvancedGate
// 0x0010 (0x0070 - 0x0080)
class UBehavior_AdvancedGate : public UBehaviorBase
{
public:
	int32_t                                            TimesFired;                                    // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            CloseCount;                                    // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           Closed : 1;                                    // 0x0078 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_AdvancedGate");
		}

		return uClassPointer;
	};

	void PublishBehaviorOutput(int32_t NewTimesFired, bool NewClosed, struct FBehaviorKernelInfo& Kernel);
};

// Class Engine.Behavior_ChangeAllegiance
// 0x0010 (0x0070 - 0x0080)
class UBehavior_ChangeAllegiance : public UBehaviorBase
{
public:
	uint32_t                                           bResetAllegiance : 1;                          // 0x0070 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	class UPawnAllegiance*                             Allegiance;                                    // 0x0078 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ChangeAllegiance");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ChangeBoneVisibility
// 0x0010 (0x0070 - 0x0080)
class UBehavior_ChangeBoneVisibility : public UBehaviorBase
{
public:
	EChangeStatus                                      Status;                                        // 0x0070 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FName                                       BoneName;                                      // 0x0074 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ChangeBoneVisibility");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ChangeCollision
// 0x0008 (0x0070 - 0x0078)
class UBehavior_ChangeCollision : public UBehaviorBase
{
public:
	ECollisionType                                     NewCollisionType;                              // 0x0070 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ChangeCollision");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ChangeCollisionSize
// 0x0008 (0x0070 - 0x0078)
class UBehavior_ChangeCollisionSize : public UBehaviorBase
{
public:
	float                                              Radius;                                        // 0x0070 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              Height;                                        // 0x0074 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ChangeCollisionSize");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ChangeCounter
// 0x0018 (0x0070 - 0x0088)
class UBehavior_ChangeCounter : public UBehaviorBase
{
public:
	EBehaviorCounterID                                 CounterId;                                     // 0x0070 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            CounterAdjustment;                             // 0x0074 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bSetNewCounterValue : 1;                       // 0x0078 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bSetNewCounterTarget : 1;                      // 0x0078 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	int32_t                                            NewCounterValue;                               // 0x007C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            NewCounterTarget;                              // 0x0080 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ChangeCounter");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ChangeParticleSystemActiveState
// 0x0008 (0x0070 - 0x0078)
class UBehavior_ChangeParticleSystemActiveState : public UBehaviorBase
{
public:
	EChangeStatus                                      Status;                                        // 0x0070 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ChangeParticleSystemActiveState");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ChangeScale
// 0x0008 (0x0070 - 0x0078)
class UBehavior_ChangeScale : public UBehaviorBase
{
public:
	float                                              Scale;                                         // 0x0070 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ChangeScale");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ChangeScale3D
// 0x0010 (0x0070 - 0x0080)
class UBehavior_ChangeScale3D : public UBehaviorBase
{
public:
	struct FVector                                     Scale;                                         // 0x0070 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ChangeScale3D");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ChangeSpin
// 0x0010 (0x0070 - 0x0080)
class UBehavior_ChangeSpin : public UBehaviorBase
{
public:
	uint32_t                                           bApplyRandomScaleToSpin : 1;                   // 0x0070 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bInheritInstigatorRotation : 1;                // 0x0070 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	int32_t                                            YawRate;                                       // 0x0074 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            PitchRate;                                     // 0x0078 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            RollRate;                                      // 0x007C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ChangeSpin");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ChangeVisibility
// 0x0008 (0x0070 - 0x0078)
class UBehavior_ChangeVisibility : public UBehaviorBase
{
public:
	EChangeStatus                                      Status;                                        // 0x0070 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ChangeVisibility");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ClientConsoleCommand
// 0x0010 (0x0070 - 0x0080)
class UBehavior_ClientConsoleCommand : public UBehaviorBase
{
public:
	class FString                                      Command;                                       // 0x0070 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ClientConsoleCommand");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ConsoleCommand
// 0x0010 (0x0070 - 0x0080)
class UBehavior_ConsoleCommand : public UBehaviorBase
{
public:
	class FString                                      Command;                                       // 0x0070 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ConsoleCommand");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_CustomAnimation
// 0x0028 (0x0070 - 0x0098)
class UBehavior_CustomAnimation : public UBehaviorBase
{
public:
	EBehaviorCustomAnimationReaction                   Reaction;                                      // 0x0070 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FName                                       CustomAnimNodeName;                            // 0x0074 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FName                                       AnimName;                                      // 0x007C (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              AnimDuration;                                  // 0x0084 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BlendInTime;                                   // 0x0088 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BlendOutTime;                                  // 0x008C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              AnimRate;                                      // 0x0090 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bLooping : 1;                                  // 0x0094 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_CustomAnimation");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_Destroy
// 0x0000 (0x0070 - 0x0070)
class UBehavior_Destroy : public UBehaviorBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_Destroy");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_FollowAllegiance
// 0x0020 (0x0070 - 0x0090)
class UBehavior_FollowAllegiance : public UBehaviorBase
{
public:
	EFollowAllegiance                                  Action;                                        // 0x0070 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FBehaviorContextData                        AllegianceParent;                              // 0x0078 (0x0018) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_FollowAllegiance");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_IsInObjectList
// 0x0020 (0x0070 - 0x0090)
class UBehavior_IsInObjectList : public UBehaviorBase
{
public:
	class TArray<class UObject*>                       List;                                          // 0x0070 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UObject*>                       Search;                                        // 0x0080 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_IsInObjectList");
		}

		return uClassPointer;
	};

	void PublishBehaviorOutput(bool Result, struct FBehaviorKernelInfo& Kernel);
};

// Class Engine.Behavior_Kill
// 0x0028 (0x0070 - 0x0098)
class UBehavior_Kill : public UBehaviorBase
{
public:
	EScriptedKillType                                  DeathType;                                     // 0x0070 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UDamageTypeDefinition*                       DamageType;                                    // 0x0078 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FBehaviorContextData                        TargetContext;                                 // 0x0080 (0x0018) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_Kill");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ParticleSystemEvent
// 0x0008 (0x0070 - 0x0078)
class UBehavior_ParticleSystemEvent : public UBehaviorBase
{
public:
	struct FName                                       EventName;                                     // 0x0070 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ParticleSystemEvent");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_PlaySound
// 0x0010 (0x0070 - 0x0080)
class UBehavior_PlaySound : public UBehaviorBase
{
public:
	class UAkEvent*                                    Sound;                                         // 0x0070 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bReplicateSound : 1;                           // 0x0078 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_PlaySound");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_RandomlyRunBehaviors
// 0x0030 (0x0070 - 0x00A0)
class UBehavior_RandomlyRunBehaviors : public UBehaviorBase
{
public:
	struct FBehaviorContextData                        ProbabilityContext;                            // 0x0070 (0x0018) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ProbabilityLowerBound;                         // 0x0088 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ProbabilityUpperBound;                         // 0x008C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<struct FIndependentSelectionData>     Possibilities;                                 // 0x0090 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_RandomlyRunBehaviors");
		}

		return uClassPointer;
	};

	void ApplyBehavior(class UObject* SelfObject, class UObject* optionalMyInstigatorObject, class UObject* optionalOtherEventParticipantObject, const struct FBehaviorParameters& optionalEventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_RemoteEvent
// 0x0010 (0x0070 - 0x0080)
class UBehavior_RemoteEvent : public UBehaviorBase
{
public:
	struct FName                                       EventName;                                     // 0x0070 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDebug : 1;                                    // 0x0078 (0x0004) [0x0000000800000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_RemoteEvent");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_RemoveFromObjectList
// 0x0020 (0x0070 - 0x0090)
class UBehavior_RemoveFromObjectList : public UBehaviorBase
{
public:
	class TArray<class UObject*>                       List;                                          // 0x0070 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UObject*>                       Exclude;                                       // 0x0080 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_RemoveFromObjectList");
		}

		return uClassPointer;
	};

	void PublishBehaviorOutput(const class TArray<class UObject*>& Result, struct FBehaviorKernelInfo& Kernel);
};

// Class Engine.Behavior_RunBehaviorCollection
// 0x0028 (0x0070 - 0x0098)
class UBehavior_RunBehaviorCollection : public UBehaviorBase
{
public:
	class UBehaviorCollectionDefinition*               CollectionDefinition;                          // 0x0070 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FName                                       OverrideName;                                  // 0x0078 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FBehaviorContextData                        OverrideContext;                               // 0x0080 (0x0018) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_RunBehaviorCollection");
		}

		return uClassPointer;
	};

	void RunBehaviorCollection(class UObject* SelfObject, class UObject* optionalMyInstigatorObject, class UObject* optionalOtherEventParticipantObject, const struct FBehaviorParameters& optionalEventData, struct FBehaviorKernelInfo& KernelInfo);
	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
	void ApplyBehavior(class UObject* SelfObject, class UObject* optionalMyInstigatorObject, class UObject* optionalOtherEventParticipantObject, const struct FBehaviorParameters& optionalEventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_SetMaterialParameters
// 0x0050 (0x0070 - 0x00C0)
class UBehavior_SetMaterialParameters : public UBehaviorBase
{
public:
	struct FBehaviorContextData                        AttributeContext;                              // 0x0070 (0x0018) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MeshSection;                                   // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FScalarMaterialParameter>      ScalarParameterValues;                         // 0x0090 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FVectorMaterialParameter>      VectorParameterValues;                         // 0x00A0 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FTextureMaterialParameter>     TextureParameterValues;                        // 0x00B0 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_SetMaterialParameters");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_SetParticleSystemParameters
// 0x0068 (0x0070 - 0x00D8)
class UBehavior_SetParticleSystemParameters : public UBehaviorBase
{
public:
	struct FBehaviorContextData                        AttributeContext;                              // 0x0070 (0x0018) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FScalarParticleSystemParameter> ScalarParameterValues;                         // 0x0088 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FVectorParticleSystemParameter> VectorParameterValues;                         // 0x0098 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FColorParticleSystemParameter> ColorParameterValues;                          // 0x00A8 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FMaterialParticleSystemParameter> MaterialParameterValues;                       // 0x00B8 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FActorParticleSystemParameter> ActorParameterValues;                          // 0x00C8 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_SetParticleSystemParameters");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_SetPhysics
// 0x0008 (0x0070 - 0x0078)
class UBehavior_SetPhysics : public UBehaviorBase
{
public:
	EPhysics                                           Physics;                                       // 0x0070 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EBodyAction                                        BodyAction;                                    // 0x0071 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ESimulationAction                                  SimulationAction;                              // 0x0072 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EPartialRagdollAction                              PartialRagdollAction;                          // 0x0073 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_SetPhysics");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_SetSkelControlActive
// 0x0010 (0x0070 - 0x0080)
class UBehavior_SetSkelControlActive : public UBehaviorBase
{
public:
	struct FName                                       SkelControlName;                               // 0x0070 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bActive : 1;                                   // 0x0078 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_SetSkelControlActive");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_SkipSwitch
// 0x0010 (0x0070 - 0x0080)
class UBehavior_SkipSwitch : public UBehaviorBase
{
public:
	int32_t                                            Num;                                           // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Condition;                                     // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Advance;                                       // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           Cycle : 1;                                     // 0x007C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_SkipSwitch");
		}

		return uClassPointer;
	};

	void PublishBehaviorOutput(int32_t Update, struct FBehaviorKernelInfo& Info);
	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.Behavior_ToggleVisibility
// 0x0000 (0x0070 - 0x0070)
class UBehavior_ToggleVisibility : public UBehaviorBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Behavior_ToggleVisibility");
		}

		return uClassPointer;
	};

	void ApplyBehaviorToContext(class UObject* ContextObject, class UObject* SelfObject, class UObject* MyInstigatorObject, class UObject* OtherEventParticipantObject, const struct FBehaviorParameters& EventData, struct FBehaviorKernelInfo& KernelInfo);
};

// Class Engine.ParameterBehaviorBase
// 0x0010 (0x0070 - 0x0080)
class UParameterBehaviorBase : public UBehaviorBase
{
public:
	struct FName                                       ParameterName;                                 // 0x0070 (0x0008) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            SectionIndex;                                  // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParameterBehaviorBase");
		}

		return uClassPointer;
	};

};

// Class Engine.BookMark
// 0x0028 (0x0058 - 0x0080)
class UBookMark : public UObject
{
public:
	struct FVector                                     Location;                                      // 0x0058 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FRotator                                    Rotation;                                      // 0x0064 (0x000C) [0x0000000000000001] (CPF_Edit)    
	class TArray<class FString>                        HiddenLevels;                                  // 0x0070 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BookMark");
		}

		return uClassPointer;
	};

};

struct FIntPoint {
	char UnknownData[0x8];
};

// Class Engine.BookMark2D
// 0x0010 (0x0058 - 0x0068)
class UBookMark2D : public UObject
{
public:
	float                                              Zoom2D;                                        // 0x0058 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FIntPoint                                   Location;                                      // 0x005C (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BookMark2D");
		}

		return uClassPointer;
	};

};

// Class Engine.KismetBookMark
// 0x0010 (0x0068 - 0x0078)
class UKismetBookMark : public UBookMark2D
{
public:
	class FString                                      BookMarkSequencePathName;                      // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.KismetBookMark");
		}

		return uClassPointer;
	};

};

// Class Engine.CameraAnim
// 0x0148 (0x0058 - 0x01A0)
class UCameraAnim : public UObject
{
public:
	class UInterpGroup*                                CameraInterpGroup;                             // 0x0058 (0x0008) [0x0000000000000000]               
	float                                              AnimLength;                                    // 0x0060 (0x0004) [0x0000000000000002] (CPF_Const)   
	struct FBox                                        BoundingBox;                                   // 0x0064 (0x001C) [0x0000000000000002] (CPF_Const)   
	struct FPostProcessSettings                        BasePPSettings;                                // 0x0080 (0x0118) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	float                                              BasePPSettingsAlpha;                           // 0x0198 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              BaseFOV;                                       // 0x019C (0x0004) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CameraAnim");
		}

		return uClassPointer;
	};

};

// Class Engine.CameraAnimInst
// 0x01D8 (0x0058 - 0x0230)
class UCameraAnimInst : public UObject
{
public:
	class UCameraAnim*                                 CamAnim;                                       // 0x0058 (0x0008) [0x0000000000000000]               
	class UInterpGroupInst*                            InterpGroupInst;                               // 0x0060 (0x0008) [0x0000000004400008] (CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	float                                              CurTime;                                       // 0x0068 (0x0004) [0x0000000000002000] (CPF_Transient)
	uint32_t                                           bLooping : 1;                                  // 0x006C (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)
	uint32_t                                           bFinished : 1;                                 // 0x006C (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	uint32_t                                           bAutoReleaseWhenFinished : 1;                  // 0x006C (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)
	uint32_t                                           bBlendingIn : 1;                               // 0x006C (0x0004) [0x0000000000002000] [0x00000008] (CPF_Transient)
	uint32_t                                           bBlendingOut : 1;                              // 0x006C (0x0004) [0x0000000000002000] [0x00000010] (CPF_Transient)
	float                                              BlendInTime;                                   // 0x0070 (0x0004) [0x0000000000000000]               
	float                                              BlendOutTime;                                  // 0x0074 (0x0004) [0x0000000000000000]               
	float                                              CurBlendInTime;                                // 0x0078 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              CurBlendOutTime;                               // 0x007C (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              PlayRate;                                      // 0x0080 (0x0004) [0x0000000000000000]               
	float                                              BasePlayScale;                                 // 0x0084 (0x0004) [0x0000000000000000]               
	float                                              TransientScaleModifier;                        // 0x0088 (0x0004) [0x0000000000000000]               
	float                                              CurrentBlendWeight;                            // 0x008C (0x0004) [0x0000000000000000]               
	float                                              RemainingTime;                                 // 0x0090 (0x0004) [0x0000000000002000] (CPF_Transient)
	class UInterpTrackMove*                            MoveTrack;                                     // 0x0098 (0x0008) [0x0000000000002000] (CPF_Transient)
	class UInterpTrackInstMove*                        MoveInst;                                      // 0x00A0 (0x0008) [0x0000000000002000] (CPF_Transient)
	class UAnimNodeSequence*                           SourceAnimNode;                                // 0x00A8 (0x0008) [0x0000000000002000] (CPF_Transient)
	ECameraAnimPlaySpace                               PlaySpace;                                     // 0x00B0 (0x0001) [0x0000000000000000]               
	EAxis                                              MirrorAxes;                                    // 0x00B1 (0x0001) [0x0000000000000000]               
	uint8_t                                           UnknownData00[0xE];                            // 0x00B2 (0x000E) MISSED OFFSET
	struct FMatrix                                     UserPlaySpaceMatrix;                           // 0x00C0 (0x0040) [0x0000000000002000] (CPF_Transient)
	struct FPostProcessSettings                        LastPPSettings;                                // 0x0100 (0x0118) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	float                                              LastPPSettingsAlpha;                           // 0x0218 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     LastCameraLoc;                                 // 0x021C (0x000C) [0x0000000000002000] (CPF_Transient)
	uint8_t                                           UnknownData01[0x8];                            // 0x0228 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CameraAnimInst");
		}

		return uClassPointer;
	};

	void ApplyMirroring(struct FVector& Loc, struct FRotator& Rot);
	void SetPlaySpace(ECameraAnimPlaySpace NewSpace, const struct FRotator& optionalUserPlaySpace);
	void ApplyTransientScaling(float Scalar);
	void Stop(bool optionalBImmediate);
	void AdvanceAnim(float DeltaTime, bool bJump);
	void Update(float NewRate, float NewScale, float NewBlendInTime, float NewBlendOutTime, float optionalNewDuration);
	void Play(class UCameraAnim* Anim, class AActor* CamActor, float InRate, float InScale, float InBlendInTime, float InBlendOutTime, bool bInLoop, bool bRandomStartTime, float optionalDuration, EAxis optionalInMirrorAxes);
};

// Class Engine.CameraShake
// 0x0090 (0x0058 - 0x00E8)
class UCameraShake : public UObject
{
public:
	uint32_t                                           bSingleInstance : 1;                           // 0x0058 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bRandomAnimSegment : 1;                        // 0x0058 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              OscillationDuration;                           // 0x005C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OscillationBlendInTime;                        // 0x0060 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OscillationBlendOutTime;                       // 0x0064 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FROscillator                                RotOscillation;                                // 0x0068 (0x0024) [0x0000000000000001] (CPF_Edit)    
	struct FVOscillator                                LocOscillation;                                // 0x008C (0x0024) [0x0000000000000001] (CPF_Edit)    
	struct FFOscillator                                FOVOscillation;                                // 0x00B0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	class UCameraAnim*                                 Anim;                                          // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              AnimPlayRate;                                  // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AnimScale;                                     // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AnimBlendInTime;                               // 0x00D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AnimBlendOutTime;                              // 0x00D4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RandomAnimSegmentDuration;                     // 0x00D8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UForceFeedbackWaveform*                      FFWaveform;                                    // 0x00E0 (0x0008) [0x0000000004000001] (CPF_Edit | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CameraShake");
		}

		return uClassPointer;
	};

	float GetLocOscillationMagnitude();
	float GetRotOscillationMagnitude();
};

// Class Engine.Canvas
// 0x0068 (0x0058 - 0x00C0)
class UCanvas : public UObject
{
public:
	class UFont*                                       Font;                                          // 0x0058 (0x0008) [0x0000000000000000]               
	float                                              OrgX;                                          // 0x0060 (0x0004) [0x0000000000000000]               
	float                                              OrgY;                                          // 0x0064 (0x0004) [0x0000000000000000]               
	float                                              ClipX;                                         // 0x0068 (0x0004) [0x0000000000000000]               
	float                                              ClipY;                                         // 0x006C (0x0004) [0x0000000000000000]               
	float                                              CurX;                                          // 0x0070 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              CurY;                                          // 0x0074 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              CurZ;                                          // 0x0078 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              CurYL;                                         // 0x007C (0x0004) [0x0000000000000000]               
	struct FColor                                      DrawColor;                                     // 0x0080 (0x0004) [0x0000000000000000]               
	uint32_t                                           bCenter : 1;                                   // 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bNoSmooth : 1;                                 // 0x0084 (0x0004) [0x0000000000000000] [0x00000002] 
	int32_t                                            SizeX;                                         // 0x0088 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            SizeY;                                         // 0x008C (0x0004) [0x0000000000000002] (CPF_Const)   
	struct FPointer                                    Canvas;                                        // 0x0090 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FPointer                                    SceneView;                                     // 0x0098 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FPlane                                      ColorModulate;                                 // 0x00A0 (0x0010) [0x0000000000000000]               
	class UTexture2D*                                  DefaultTexture;                                // 0x00B0 (0x0008) [0x0000000000000000]               
	struct FColor                                      BGColor;                                       // 0x00B8 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Canvas");
		}

		return uClassPointer;
	};

	void DrawTextureDoubleLineW(const struct FVector& StartPoint, const struct FVector& EndPoint, float Perc, float Spacing, float Width, const struct FColor& LineColor, const struct FColor& AltLineColor, class UTexture* Tex, float U, float V, float UL, float VL);
	void DrawTextureLineW(const struct FVector& StartPoint, const struct FVector& EndPoint, float Perc, float Width, const struct FColor& LineColor, class UTexture* LineTexture, float U, float V, float UL, float VL);
	void Draw2DLine(float X1, float Y1, float X2, float Y2, const struct FColor& LineColor);
	void SetBGColor(uint8_t R, uint8_t G, uint8_t B, uint8_t optionalA);
	void SetDrawColorStruct(const struct FColor& C);
	void SetDrawColor(uint8_t R, uint8_t G, uint8_t B, uint8_t optionalA);
	void DrawBox(float Width, float Height);
	void DrawRect(float RectX, float RectY, class UTexture* optionalTex);
	void DrawIcon(const struct FCanvasIcon& Icon, float X, float Y, float optionalScale);
	void DrawScaledIcon(const struct FCanvasIcon& Icon, float X, float Y, const struct FVector& Scale);
	struct FCanvasIcon MakeIcon(class UTexture* Texture, float optionalU, float optionalV, float optionalUL, float optionalVL);
	void DrawTextureBlendedW(class UTexture* Tex, float Scale, EBlendMode Blend);
	void DrawTextureW(class UTexture* Tex, float Scale);
	void SetClip(float X, float Y);
	void SetOrigin(float X, float Y);
	void SetPos(float PosX, float PosY, float optionalPosZ);
	class UFont* GetDefaultCanvasFont();
	void eventReset(bool optionalBKeepOrigin);
	void PopTransform();
	void PushTranslationMatrix(const struct FVector& TranslationVector);
	void DeProject(const struct FVector2D& ScreenPos, struct FVector& WorldOrigin, struct FVector& WorldDirection);
	struct FVector Project(const struct FVector& Location);
	static struct FFontRenderInfo CreateFontRenderInfo(bool optionalBClipText, bool optionalBEnableShadow, const struct FLinearColor& optionalGlowColor, const struct FVector2D& optionalGlowOuterRadius, const struct FVector2D& optionalGlowInnerRadius);
	void DrawTris(class UTexture* Tex, const class TArray<struct FCanvasUVTri>& Triangles);
	void DrawTileStretched(class UTexture* Tex, float XL, float YL, float U, float V, float UL, float VL, const struct FLinearColor& optionalLColor, bool optionalBStretchHorizontally, bool optionalBStretchVertically, float optionalScalingFactor);
	void DrawRotatedMaterialTile(class UMaterialInterface* Mat, const struct FRotator& Rotation, float XL, float YL, float optionalU, float optionalV, float optionalUL, float optionalVL, float optionalAnchorX, float optionalAnchorY);
	void DrawRotatedTile(class UTexture* Tex, const struct FRotator& Rotation, float XL, float YL, float U, float V, float UL, float VL, float optionalAnchorX, float optionalAnchorY);
	void DrawMaterialTile(class UMaterialInterface* Mat, float XL, float YL, float optionalU, float optionalV, float optionalUL, float optionalVL, bool optionalBClipTile);
	void DrawTile(class UTexture* Tex, float XL, float YL, float U, float V, float UL, float VL, const struct FLinearColor& optionalLColor, bool optionalClipTile, EBlendMode optionalBlend);
};

// Class Engine.Channel
// 0x0038 (0x0058 - 0x0090)
class UChannel : public UObject
{
public:
	UNetConnection*									  Connection; //0x58
	uint16_t OpenAckd; //0x60
	uint16_t Closing;
	//uint8_t UnknownData00[0x4]; //0x60
	int ChIndex; //0x64
	uint8_t UnknownData01[0x8]; //0x68
	//uint8_t ChType; //0x70
	int NumInRec;
	int NumOutRec;
	uint8_t                                           UnknownData02[0x18];                           // 0x0058 (0x0038) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Channel");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorChannel
// 0x0088 (0x0090 - 0x0118)
class UActorChannel : public UChannel
{
public:
	uint8_t                                           UnknownData00[0x8]; //0x90
	AActor*											  Actor; //0x98
	UClass*											  ActorClass;
	double RelevantTime;
	double LastUpdateTime;
	double LastFullUpdateTime;
	uint32_t SpawnAcked;
	uint32_t ActorDirty;
	unsigned char idrc[0x10];
	__int64 tarrayPlaceholder1;
	__int64 tarrayPlaceholder2;
	uint8_t                                           UnknownData01[0x30];                           // 0x0090 (0x0088) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorChannel");
		}

		return uClassPointer;
	};

};

// Class Engine.ControlChannel
// 0x0018 (0x0090 - 0x00A8)
class UControlChannel : public UChannel
{
public:
	uint8_t                                           UnknownData00[0x18];                           // 0x0090 (0x0018) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ControlChannel");
		}

		return uClassPointer;
	};

};

// Class Engine.FileChannel
// 0x0218 (0x0090 - 0x02A8)
class UFileChannel : public UChannel
{
public:
	uint8_t                                           UnknownData00[0x218];                          // 0x0090 (0x0218) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FileChannel");
		}

		return uClassPointer;
	};

};

// Class Engine.VoiceChannel
// 0x0010 (0x0090 - 0x00A0)
class UVoiceChannel : public UChannel
{
public:
	uint8_t                                           UnknownData00[0x10];                           // 0x0090 (0x0010) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.VoiceChannel");
		}

		return uClassPointer;
	};

};

// Class Engine.CheatManager
// 0x0030 (0x0058 - 0x0088)
class UCheatManager : public UObject
{
public:
	class ADebugCameraController*                      DebugCameraControllerRef;                      // 0x0058 (0x0008) [0x0000000000000000]               
	class UClass*                                      DebugCameraControllerClass;                    // 0x0060 (0x0008) [0x0000000000000000]               
	class FString                                      ViewingFrom;                                   // 0x0068 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      OwnCamera;                                     // 0x0078 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CheatManager");
		}

		return uClassPointer;
	};

	void SetDifficulty(float NewDifficulty);
	void EnableInfluence(bool bEnable, const struct FName& optionalInfoName);
	void DebugInfluenceValues();
	void DebugInfluence(const struct FName& optionalInfoName);
	void ToggleAssertOnGBXCheck();
	void SetGBXCheckDisplayDuration(int32_t NewDuration);
	void SetNumberOfDebugMessages(int32_t NumberOfMessages);
	void EnableDebugMessages();
	void DisableDebugMessages();
	void BehaviorDebug();
	void DumpCoverStats();
	void ToggleAILogging();
	void LogParticleActivateSystemCalls(bool bShouldLog);
	void LogPlaySoundCalls(bool bShouldLog);
	void InitCheatManager();
	void DebugDrawUserInfo();
	void DumpUserInfo();
	void SetOnlineDebugLevel(int32_t DebugLevel);
	void TestLevel();
	void EnableDebugCamera();
	void ToggleDebugCamera();
	void StreamLevelOut(const struct FName& PackageName);
	void OnlyLoadLevel(const struct FName& PackageName);
	void StreamLevelIn(const struct FName& PackageName);
	void SetLevelStreamingStatus(const struct FName& PackageName, bool bShouldBeLoaded, bool bShouldBeVisible);
	void AllWeapons();
	void Loaded();
	void ViewClass(class UClass* aClass);
	void ViewBot();
	void ViewActor(const struct FName& actorName);
	void ViewPlayer(const class FString& S);
	void ViewSelf(bool optionalBQuiet);
	void SuspendAI();
	void PlayersOnly();
	class AWeapon* GiveWeapon(const class FString& WeaponClassStr);
	void Summon(const class FString& ClassName);
	void Avatar(const struct FName& ClassName);
	void KillPawns();
	void KillAllPawns(class UClass* aClass);
	void KillAll(class UClass* aClass);
	void SetSpeed(float F);
	void SetGravity(float F);
	void SetJumpZ(float F);
	void Slomo(float T);
	void AllAmmo();
	void Fly();
	void Amphibious();
	void EndPath();
	void ChangeSize(float F);
	void Teleport();
	void KillViewedActor();
	void WriteToLog(const class FString& Param);
	void FreezeFrame(float Delay);
	void ListDynamicActors();
	void DebugPause();
	void EditAIByTrace();
	void DebugAI(const struct FName& optionalCategory);
	void FXStop(class UClass* aClass);
	void FXPlay(class UClass* aClass, const class FString& FXAnimPath);
};

// Class Engine.Client
// 0x0018 (0x0058 - 0x0070)
class UClient : public UObject
{
public:
	uint8_t                                           UnknownData00[0x8];                            // 0x0058 (0x0008) MISSED OFFSET
	float                                              MinDesiredFrameRate60FpsTarget;                // 0x0060 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              DesiredFrameRate60FpsTarget;                   // 0x0064 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              InitialButtonRepeatDelay;                      // 0x0068 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              ButtonRepeatDelay;                             // 0x006C (0x0004) [0x0000000000004000] (CPF_Config)  

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Client");
		}

		return uClassPointer;
	};

};

// Class Engine.ClientHeadless
// 0x0008 (0x0070 - 0x0078)
class UClientHeadless : public UClient
{
public:
	uint8_t                                           UnknownData00[0x8];                            // 0x0070 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ClientHeadless");
		}

		return uClassPointer;
	};

};

// Class Engine.ClipPadEntry
// 0x0020 (0x0058 - 0x0078)
class UClipPadEntry : public UObject
{
public:
	class FString                                      Title;                                         // 0x0058 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class FString                                      Text;                                          // 0x0068 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ClipPadEntry");
		}

		return uClassPointer;
	};

};

// Class Engine.CodecMovie
// 0x0008 (0x0058 - 0x0060)
class UCodecMovie : public UObject
{
public:
	float                                              PlaybackDuration;                              // 0x0058 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CodecMovie");
		}

		return uClassPointer;
	};

};

// Class Engine.CodecMovieBink
// 0x0038 (0x0060 - 0x0098)
class UCodecMovieBink : public UCodecMovie
{
public:
	uint8_t                                           UnknownData00[0x38];                           // 0x0060 (0x0038) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CodecMovieBink");
		}

		return uClassPointer;
	};

};

// Class Engine.CodecMovieFallback
// 0x0008 (0x0060 - 0x0068)
class UCodecMovieFallback : public UCodecMovie
{
public:
	float                                              CurrentTime;                                   // 0x0060 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CodecMovieFallback");
		}

		return uClassPointer;
	};

};

// Class Engine.CommManager
// 0x00B0 (0x0058 - 0x0108)
class UCommManager : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                       // 0x0058 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class TArray<struct FPointer>                      ProviderList;                                  // 0x0060 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FMap_Mirror                                 MuteListMap;                                   // 0x0070 (0x0050) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<struct FSharedPtr_Mirror>             LocalPackets;                                  // 0x00C0 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<struct FSharedPtr_Mirror>             RemotePackets;                                 // 0x00D0 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<struct FScriptDelegate>               PlayerChatTextReceivedDelegates;               // 0x00E0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bCommEnabled : 1;                              // 0x00F0 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FScriptDelegate                             __OnPlayerChatTextReceived__Delegate;          // 0x00F8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CommManager");
		}

		return uClassPointer;
	};

	void OnPlayerChatTextReceived(const struct FUniqueNetId& UniqueId, uint8_t Channel, const class FString& ChatText);
};

// Class Engine.ConstantBuffer
// 0x0028 (0x0058 - 0x0080)
class UConstantBuffer : public UObject
{
public:
	struct FRenderCommandFence_Mirror                  ConstantBufferFence;                           // 0x0058 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    ConstantBufferResource;                        // 0x0060 (0x0008) [0x0000000000203002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FName                                       ConstantBufferName;                            // 0x0068 (0x0008) [0x0000000000020002] (CPF_Const | CPF_EditConst)
	class TArray<struct FConstantBufferVariableDefinition> VariableDescriptions;                          // 0x0070 (0x0010) [0x0000000000420003] (CPF_Edit | CPF_Const | CPF_EditConst | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ConstantBuffer");
		}

		return uClassPointer;
	};

};

// Class Engine.EngineConstantBuffer
// 0x0030 (0x0080 - 0x00B0)
class UEngineConstantBuffer : public UConstantBuffer
{
public:
	struct FEngineConstantBufferStruct                 ConstantBufferData;                            // 0x0080 (0x0030) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EngineConstantBuffer");
		}

		return uClassPointer;
	};

};

// Class Engine.CurveEdPresetCurve
// 0x0020 (0x0058 - 0x0078)
class UCurveEdPresetCurve : public UObject
{
public:
	class FString                                      CurveName;                                     // 0x0058 (0x0010) [0x0000000000408003] (CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class TArray<struct FPresetGeneratedPoint>         Points;                                        // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CurveEdPresetCurve");
		}

		return uClassPointer;
	};

};

// Class Engine.CustomPropertyItemHandler
// 0x0000 (0x0058 - 0x0058)
class UCustomPropertyItemHandler : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CustomPropertyItemHandler");
		}

		return uClassPointer;
	};

};

// Class Engine.DamageAdjuster
// 0x0000 (0x0058 - 0x0058)
class UDamageAdjuster : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DamageAdjuster");
		}

		return uClassPointer;
	};

	bool AdjustDamage(float& Damage, struct FVector& Momentum, struct FTraceHitInfo& HitInfo, struct FDamageInfo& DmgInfo);
};

// Class Engine.DamageType
// 0x0038 (0x0058 - 0x0090)
class UDamageType : public UObject
{
public:
	uint32_t                                           bArmorStops : 1;                               // 0x0058 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bCausedByWorld : 1;                            // 0x0058 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bExtraMomentumZ : 1;                           // 0x0058 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bRadialDamageVelChange : 1;                    // 0x0058 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	float                                              KDamageImpulse;                                // 0x005C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              KDeathVel;                                     // 0x0060 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              KDeathUpKick;                                  // 0x0064 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RadialDamageImpulse;                           // 0x0068 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              VehicleDamageScaling;                          // 0x006C (0x0004) [0x0000000000000000]               
	float                                              VehicleMomentumScaling;                        // 0x0070 (0x0004) [0x0000000000000000]               
	class UForceFeedbackWaveform*                      DamagedFFWaveform;                             // 0x0078 (0x0008) [0x0000000000000000]               
	class UForceFeedbackWaveform*                      KilledFFWaveform;                              // 0x0080 (0x0008) [0x0000000000000000]               
	float                                              FracturedMeshDamage;                           // 0x0088 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DamageType");
		}

		return uClassPointer;
	};

	static float VehicleDamageScalingFor(class AVehicle* V);
};

// Class Engine.DmgType_Crushed
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Crushed : public UDamageType
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DmgType_Crushed");
		}

		return uClassPointer;
	};

};

// Class Engine.DmgType_Fell
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Fell : public UDamageType
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DmgType_Fell");
		}

		return uClassPointer;
	};

};

// Class Engine.DmgType_Telefragged
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Telefragged : public UDamageType
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DmgType_Telefragged");
		}

		return uClassPointer;
	};

};

// Class Engine.KillZDamageType
// 0x0000 (0x0090 - 0x0090)
class UKillZDamageType : public UDamageType
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.KillZDamageType");
		}

		return uClassPointer;
	};

};

// Class Engine.DmgType_Suicided
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Suicided : public UKillZDamageType
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DmgType_Suicided");
		}

		return uClassPointer;
	};

};

// Class Engine.DataPlatform
// 0x0008 (0x0058 - 0x0060)
class UDataPlatform : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                       // 0x0058 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DataPlatform");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionFloatConstant
// 0x0008 (0x0078 - 0x0080)
class UDistributionFloatConstant : public UDistributionFloat
{
public:
	float                                              Constant;                                      // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionFloatConstant");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionFloatParameterBase
// 0x0020 (0x0080 - 0x00A0)
class UDistributionFloatParameterBase : public UDistributionFloatConstant
{
public:
	struct FName                                       ParameterName;                                 // 0x0080 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              MinInput;                                      // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxInput;                                      // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MinOutput;                                     // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxOutput;                                     // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    
	EDistributionParamMode                             ParamMode;                                     // 0x0098 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionFloatParameterBase");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionFloatParticleParameter
// 0x0000 (0x00A0 - 0x00A0)
class UDistributionFloatParticleParameter : public UDistributionFloatParameterBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionFloatParticleParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionFloatSoundParameter
// 0x0000 (0x00A0 - 0x00A0)
class UDistributionFloatSoundParameter : public UDistributionFloatParameterBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionFloatSoundParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionFloatConstantCurve
// 0x0018 (0x0078 - 0x0090)
class UDistributionFloatConstantCurve : public UDistributionFloat
{
public:
	struct FInterpCurveFloat                           ConstantCurve;                                 // 0x0078 (0x0018) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionFloatConstantCurve");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionFloatUniform
// 0x0008 (0x0078 - 0x0080)
class UDistributionFloatUniform : public UDistributionFloat
{
public:
	float                                              Min;                                           // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Max;                                           // 0x007C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionFloatUniform");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionFloatUniformCurve
// 0x0018 (0x0078 - 0x0090)
class UDistributionFloatUniformCurve : public UDistributionFloat
{
public:
	struct FInterpCurveVector2D                        ConstantCurve;                                 // 0x0078 (0x0018) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionFloatUniformCurve");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionVectorConstant
// 0x0018 (0x0078 - 0x0090)
class UDistributionVectorConstant : public UDistributionVector
{
public:
	struct FVector                                     Constant;                                      // 0x0078 (0x000C) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bLockAxes : 1;                                 // 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 
	EDistributionVectorLockFlags                       LockedAxes;                                    // 0x0088 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionVectorConstant");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionVectorParameterBase
// 0x0040 (0x0090 - 0x00D0)
class UDistributionVectorParameterBase : public UDistributionVectorConstant
{
public:
	struct FName                                       ParameterName;                                 // 0x0090 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MinInput;                                      // 0x0098 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MaxInput;                                      // 0x00A4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MinOutput;                                     // 0x00B0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MaxOutput;                                     // 0x00BC (0x000C) [0x0000000000000001] (CPF_Edit)    
	EDistributionParamMode                             ParamModes[0x3];                               // 0x00C8 (0x0003) [0x0000000000080009] (CPF_Edit | CPF_ExportObject | CPF_Component)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionVectorParameterBase");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionVectorParticleParameter
// 0x0000 (0x00D0 - 0x00D0)
class UDistributionVectorParticleParameter : public UDistributionVectorParameterBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionVectorParticleParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionVectorConstantCurve
// 0x0020 (0x0078 - 0x0098)
class UDistributionVectorConstantCurve : public UDistributionVector
{
public:
	struct FInterpCurveVector                          ConstantCurve;                                 // 0x0078 (0x0018) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bLockAxes : 1;                                 // 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	EDistributionVectorLockFlags                       LockedAxes;                                    // 0x0094 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionVectorConstantCurve");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionVectorUniform
// 0x0020 (0x0078 - 0x0098)
class UDistributionVectorUniform : public UDistributionVector
{
public:
	struct FVector                                     Max;                                           // 0x0078 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Min;                                           // 0x0084 (0x000C) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bLockAxes : 1;                                 // 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bUseExtremes : 1;                              // 0x0090 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	EDistributionVectorLockFlags                       LockedAxes;                                    // 0x0094 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EDistributionVectorMirrorFlags                     MirrorFlags[0x3];                              // 0x0095 (0x0003) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionVectorUniform");
		}

		return uClassPointer;
	};

};

// Class Engine.DistributionVectorUniformCurve
// 0x0028 (0x0078 - 0x00A0)
class UDistributionVectorUniformCurve : public UDistributionVector
{
public:
	struct FInterpCurveTwoVectors                      ConstantCurve;                                 // 0x0078 (0x0018) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bLockAxes1 : 1;                                // 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bLockAxes2 : 1;                                // 0x0090 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bUseExtremes : 1;                              // 0x0090 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	EDistributionVectorLockFlags                       LockedAxes[0x2];                               // 0x0094 (0x0002) [0x0000000000000001] (CPF_Edit)    
	EDistributionVectorMirrorFlags                     MirrorFlags[0x3];                              // 0x0096 (0x0003) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DistributionVectorUniformCurve");
		}

		return uClassPointer;
	};

};

// Class Engine.Download
// 0x0A48 (0x0058 - 0x0AA0)
class UDownload : public UObject
{
public:
	uint8_t                                           UnknownData00[0xA48];                          // 0x0058 (0x0A48) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Download");
		}

		return uClassPointer;
	};

};

// Class Engine.ChannelDownload
// 0x0008 (0x0AA0 - 0x0AA8)
class UChannelDownload : public UDownload
{
public:
	uint8_t                                           UnknownData00[0x8];                            // 0x0AA0 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ChannelDownload");
		}

		return uClassPointer;
	};

};

// Class Engine.DownloadableContentEnumerator
// 0x0068 (0x0058 - 0x00C0)
class UDownloadableContentEnumerator : public UObject
{
public:
	class TArray<struct FOnlineContent>                DLCBundles;                                    // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FNamedOnlineContent>           NamedDLCBundles;                               // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FNamedOnlineContent>           NamedDLCCompatibilityBundles;                  // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bNeedsRefresh : 1;                             // 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	EDlcEnumerationState                               CurrentEnumerationState;                       // 0x008C (0x0001) [0x0000000000000000]               
	class FString                                      DLCRootDir;                                    // 0x0090 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FScriptDelegate>               FindDLCDelegates;                              // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnFindDLCComplete__Delegate;                 // 0x00B0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DownloadableContentEnumerator");
		}

		return uClassPointer;
	};

	void SetNeedsRefresh(bool InNeedsRefresh);
	bool IsBusy();
	void TriggerFindDLCDelegates();
	void InstallAllDLC();
	void DeleteDLC(const class FString& DLCName);
	void ClearFindDLCDelegate(const struct FScriptDelegate& InDelegate);
	void AddFindDLCDelegate(const struct FScriptDelegate& InDelegate);
	void OnFindDLCComplete();
	void FindDLC();
};

// Class Engine.DownloadableContentManager
// 0x0178 (0x0058 - 0x01D0)
class UDownloadableContentManager : public UObject
{
public:
	class TArray<struct FPointer>                      DLCConfigCacheChanges;                         // 0x0058 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FMarketplaceOffer>             DlcOffers;                                     // 0x0068 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FInstalledContentInfo>         InstalledContent;                              // 0x0078 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FRejectedContentInfo>          RejectedContent;                               // 0x0088 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	struct FGuid                                       CookInstanceGuid;                              // 0x0098 (0x0010) [0x0000000000002000] (CPF_Transient)
	class TArray<class FString>                        NonPackageFilePathMapExtensions;               // 0x00A8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	struct FMap_Mirror                                 NonPackageFilePathMap;                         // 0x00B8 (0x0050) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FMap_Mirror                                 AudioPackageFilePathmap;                       // 0x0108 (0x0050) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<class UClass*>                        ClassesToReload;                               // 0x0158 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<class UObject*>                       ObjectsToReload;                               // 0x0168 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint32_t                                           bCanInstallCompatibilityContent : 1;           // 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bCanEnumerateMarketplaceContent : 1;           // 0x0178 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bCouldInstallCompatibilityContent : 1;         // 0x0178 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bCouldEnumerateMarketplaceContent : 1;         // 0x0178 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bRefreshRequestWhileBusy : 1;                  // 0x0178 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bDlcEnumOutstanding : 1;                       // 0x0178 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bDlcOfferEnumOutstanding : 1;                  // 0x0178 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bDlcOfferEnumInstallPending : 1;               // 0x0178 (0x0004) [0x0000000000000000] [0x00000080] 
	class TArray<int32_t>                              LicensedSeasonPassIds;                         // 0x0180 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FDouble                                     LastRefreshStartTime;                          // 0x0190 (0x0008) [0x0000000000000000]               
	struct FDouble                                     LastRefreshFinishTime;                         // 0x0198 (0x0008) [0x0000000000000000]               
	int32_t                                            RefreshCount;                                  // 0x01A0 (0x0004) [0x0000000000000000]               
	class UGameEngine*                                 GameEngine;                                    // 0x01A8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class TArray<struct FScriptDelegate>               RefreshCompleteDelegates;                      // 0x01B0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnRefreshComplete__Delegate;                 // 0x01C0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DownloadableContentManager");
		}

		return uClassPointer;
	};

	bool IsSeasonPassLicensed(int32_t SeasonPassId);
	struct FMarketplaceOfferDownloadState GetMarketplaceOfferInstalledState(struct FMarketplaceOffer& InOffer);
	struct FMarketplaceOfferDownloadState GetMarketplaceContentInstalledState(struct FMarketplaceContent& InContent);
	static void StaticSetUsesAsynchronousInstallation(bool bUsesAsyncInstallation);
	static bool StaticUsesAsynchronousInstallation();
	bool NeedsRefresh(bool optionalInCanInstallCompatibilityContent, bool optionalInCanEnumerateMarketplaceContent);
	bool IsInStartMenu();
	bool IsBusy();
	bool CouldEnumerateMarketplaceContent();
	bool CanEnumerateMarketplaceContent();
	bool CouldInstallCompatibilityContent();
	bool CanInstallCompatibilityContent();
	void TriggerRefreshCompleteDelegates();
	void ClearRefreshCompleteDelegate(const struct FScriptDelegate& InDelegate);
	void AddRefreshCompleteDelegate(const struct FScriptDelegate& InDelegate);
	void OnRefreshComplete();
	void AddPackagesToFullyLoad(const class FString& Filename);
	void TriggerRefreshComplete();
	struct FDouble GetAppSeconds();
	void RefreshOffersComplete();
	void RefreshDLCComplete();
	bool RefreshDLC(bool optionalInCanInstallCompatibilityContent, bool optionalInCanEnumerateMarketplaceContent);
	bool HasBeenRefreshed();
	void TryContentChangeEventRefresh(const class FString& Reason);
	void OnContentChange();
	void OnLoginStatusChange(const struct FPlatformUserId& UserId, ELoginStatus PreviousStatus, ELoginStatus NewStatus, const struct FUniqueNetId& PreviousId, const struct FUniqueNetId& NewId);
	void NativeInit();
	void Init();
	bool HasEnumeratedMarketplaceContent();
	bool HasUnseenUninstallableEngineVersionContent(bool optionalBMarkSeen);
	bool HasUnseenInstalledContent(bool optionalBMarkSeen);
	bool HasUnseenUninstallableLicensedContent(bool optionalBMarkSeen);
	bool HasUninstallableCompatibilityContent();
	bool HasUnseenUninstallableCompatibilityContent(bool optionalBMarkSeen);
	void GetCorruptContentNames(class TArray<class FString>& ContentNames);
	bool HasUnseenCorruptContent(bool optionalBMarkSeen);
	void InstallNonPackageFiles(struct FOnlineContent& DLCBundle);
	void InstallPackages(struct FOnlineContent& DLCBundle);
	void UpdateObjectLists();
	void MarkPerObjectConfigPendingKill(const class FString& Section);
	void AddSectionToObjectList(const class FString& Section);
	bool GetDLCAudioPackageBasePath(const struct FName& AudioPackageFile, class FString& Path);
	bool GetDLCNonPackageFilePath(const struct FName& NonPackageFileName, class FString& Path);
	void ClearDLC();
	void InstallDLCs(class TArray<struct FOnlineContent>& DLCBundles, class TArray<struct FNamedOnlineContent>& NamedDLCCompatibilityBundles, class TArray<struct FNamedOnlineContent>& NamedDLCBundles);
	EInstallDLCResult InstallCompatibilityDLC(struct FNamedOnlineContent& NamedDLCBundle);
	EInstallDLCResult InstallNamedDLC(struct FNamedOnlineContent& NamedDLCBundle);
	EInstallDLCResult InstallDLC(struct FOnlineContent& DLCBundle);
};

// Class Engine.DownloadableContentOfferEnumerator
// 0x0038 (0x0058 - 0x0090)
class UDownloadableContentOfferEnumerator : public UObject
{
public:
	uint32_t                                           bHasBeenEnumerated : 1;                        // 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 
	EDlcOfferEnumerationState                          CurrentEnumerationState;                       // 0x005C (0x0001) [0x0000000000000000]               
	class TArray<struct FMarketplaceOffer>             MarketplaceOffers;                             // 0x0060 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FScriptDelegate>               FindDlcOfferDelegates;                         // 0x0070 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnFindDlcOfferComplete__Delegate;            // 0x0080 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DownloadableContentOfferEnumerator");
		}

		return uClassPointer;
	};

	bool IsBusy();
	void TriggerFindDlcOfferDelegates();
	void ClearFindDlcOfferDelegate(const struct FScriptDelegate& InDelegate);
	void AddFindDlcOfferDelegate(const struct FScriptDelegate& InDelegate);
	void OnFindDlcOfferComplete();
	void FindContentOffers();
};

// Class Engine.EdCoordSystem
// 0x0058 (0x0058 - 0x00B0)
class UEdCoordSystem : public UObject
{
public:
	uint8_t                                           UnknownData00[0x8];                            // 0x0058 (0x0008) MISSED OFFSET
	struct FMatrix                                     M;                                             // 0x0060 (0x0040) [0x0000000000000001] (CPF_Edit)    
	class FString                                      Desc;                                          // 0x00A0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EdCoordSystem");
		}

		return uClassPointer;
	};

};

// Class Engine.EditorLinkSelectionInterface
// 0x0000 (0x0058 - 0x0058)
class UEditorLinkSelectionInterface : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EditorLinkSelectionInterface");
		}

		return uClassPointer;
	};

};

// Class Engine.Engine
// 0x0938 (0x0060 - 0x0998)
class UEngine : public USubsystem
{
public:
	class UConstantBuffer*                             DefaultEngineConstantBuffer;                   // 0x0060 (0x0008) [0x0000000000000000]               
	class FString                                      EngineConstantBufferClassName;                 // 0x0068 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UConstantBuffer*                             DefaultGameConstantBuffer;                     // 0x0078 (0x0008) [0x0000000000000000]               
	class FString                                      GameConstantBufferClassName;                   // 0x0080 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UFont*                                       TinyFont;                                      // 0x0090 (0x0008) [0x0000000000000000]               
	class FString                                      TinyFontName;                                  // 0x0098 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UFont*                                       SmallFont;                                     // 0x00A8 (0x0008) [0x0000000000000000]               
	class FString                                      SmallFontName;                                 // 0x00B0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UFont*                                       MediumFont;                                    // 0x00C0 (0x0008) [0x0000000000000000]               
	class FString                                      MediumFontName;                                // 0x00C8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UFont*                                       LargeFont;                                     // 0x00D8 (0x0008) [0x0000000000000000]               
	class FString                                      LargeFontName;                                 // 0x00E0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UFont*                                       NonShipMediumFont;                             // 0x00F0 (0x0008) [0x0000000000000000]               
	class UFont*                                       NonShipLargeFont;                              // 0x00F8 (0x0008) [0x0000000000000000]               
	class UFont*                                       SubtitleFont;                                  // 0x0100 (0x0008) [0x0000000000000000]               
	class FString                                      SubtitleFontName;                              // 0x0108 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UFont*                                       GlyphFont;                                     // 0x0118 (0x0008) [0x0000000000000000]               
	class FString                                      GlyphFontName;                                 // 0x0120 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class TArray<class UFont*>                         AdditionalFonts;                               // 0x0130 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<class FString>                        AdditionalFontNames;                           // 0x0140 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UClass*                                      ConsoleClass;                                  // 0x0150 (0x0008) [0x0000000000000000]               
	class FString                                      ConsoleClassName;                              // 0x0158 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UClass*                                      GameViewportClientClass;                       // 0x0168 (0x0008) [0x0000000000000000]               
	class FString                                      GameViewportClientClassName;                   // 0x0170 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UClass*                                      DataStoreClientClass;                          // 0x0180 (0x0008) [0x0000000000000000]               
	class FString                                      DataStoreClientClassName;                      // 0x0188 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UClass*                                      LocalPlayerClass;                              // 0x0198 (0x0008) [0x0000000000000000]               
	class FString                                      LocalPlayerClassName;                          // 0x01A0 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UMaterial*                                   DefaultMaterial;                               // 0x01B0 (0x0008) [0x0000000000000000]               
	class FString                                      DefaultMaterialName;                           // 0x01B8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   DefaultDecalMaterial;                          // 0x01C8 (0x0008) [0x0000000000000000]               
	class FString                                      DefaultDecalMaterialName;                      // 0x01D0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UTexture*                                    DefaultTexture;                                // 0x01E0 (0x0008) [0x0000000000000000]               
	class FString                                      DefaultTextureName;                            // 0x01E8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   EmissiveTexturedMaterial;                      // 0x01F8 (0x0008) [0x0000000000000000]               
	class FString                                      EmissiveTexturedMaterialName;                  // 0x0200 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   GeomMaterial;                                  // 0x0210 (0x0008) [0x0000000000000000]               
	class FString                                      GeomMaterialName;                              // 0x0218 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   OutlineEffectMaterial;                         // 0x0228 (0x0008) [0x0000000000000000]               
	class FString                                      OutlineEffectMaterialName;                     // 0x0230 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   DefaultFogVolumeMaterial;                      // 0x0240 (0x0008) [0x0000000000000000]               
	class FString                                      DefaultFogVolumeMaterialName;                  // 0x0248 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   TickMaterial;                                  // 0x0258 (0x0008) [0x0000000000000000]               
	class FString                                      TickMaterialName;                              // 0x0260 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   CrossMaterial;                                 // 0x0270 (0x0008) [0x0000000000000000]               
	class FString                                      CrossMaterialName;                             // 0x0278 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   LevelColorationLitMaterial;                    // 0x0288 (0x0008) [0x0000000000000000]               
	class FString                                      LevelColorationLitMaterialName;                // 0x0290 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   LevelColorationUnlitMaterial;                  // 0x02A0 (0x0008) [0x0000000000000000]               
	class FString                                      LevelColorationUnlitMaterialName;              // 0x02A8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   ShadedLevelColorationLitMaterial;              // 0x02B8 (0x0008) [0x0000000000000000]               
	class FString                                      ShadedLevelColorationLitMaterialName;          // 0x02C0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   ShadedLevelColorationUnlitMaterial;            // 0x02D0 (0x0008) [0x0000000000000000]               
	class FString                                      ShadedLevelColorationUnlitMaterialName;        // 0x02D8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   RemoveSurfaceMaterial;                         // 0x02E8 (0x0008) [0x0000000000000000]               
	class FString                                      RemoveSurfaceMaterialName;                     // 0x02F0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   VertexColorMaterial;                           // 0x0300 (0x0008) [0x0000000000000000]               
	class FString                                      VertexColorMaterialName;                       // 0x0308 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   VertexColorViewModeMaterial_ColorOnly;         // 0x0318 (0x0008) [0x0000000000000000]               
	class FString                                      VertexColorViewModeMaterialName_ColorOnly;     // 0x0320 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   VertexColorViewModeMaterial_AlphaAsColor;      // 0x0330 (0x0008) [0x0000000000000000]               
	class FString                                      VertexColorViewModeMaterialName_AlphaAsColor;  // 0x0338 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   VertexColorViewModeMaterial_RedOnly;           // 0x0348 (0x0008) [0x0000000000000000]               
	class FString                                      VertexColorViewModeMaterialName_RedOnly;       // 0x0350 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   VertexColorViewModeMaterial_GreenOnly;         // 0x0360 (0x0008) [0x0000000000000000]               
	class FString                                      VertexColorViewModeMaterialName_GreenOnly;     // 0x0368 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   VertexColorViewModeMaterial_BlueOnly;          // 0x0378 (0x0008) [0x0000000000000000]               
	class FString                                      VertexColorViewModeMaterialName_BlueOnly;      // 0x0380 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   HeatmapMaterial;                               // 0x0390 (0x0008) [0x0000000000000000]               
	class FString                                      HeatmapMaterialName;                           // 0x0398 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   TranslucentDebugMaterial;                      // 0x03A8 (0x0008) [0x0000000000000000]               
	class FString                                      TranslucentDebugMaterialName;                  // 0x03B0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   BoneWeightMaterial;                            // 0x03C0 (0x0008) [0x0000000000000000]               
	class FString                                      BoneWeightMaterialName;                        // 0x03C8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   TangentColorMaterial;                          // 0x03D8 (0x0008) [0x0000000000000000]               
	class FString                                      TangentColorMaterialName;                      // 0x03E0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UFacebookIntegration*                        FacebookIntegration;                           // 0x03F0 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class FString                                      FacebookIntegrationClassName;                  // 0x03F8 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	struct FLinearColor                                LightingOnlyBrightness;                        // 0x0408 (0x0010) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	class TArray<struct FColor>                        LightComplexityColors;                         // 0x0418 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class TArray<struct FLinearColor>                  ShaderComplexityColors;                        // 0x0428 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	float                                              MaxPixelShaderAdditiveComplexityCount;         // 0x0438 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MinTextureDensity;                             // 0x043C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              IdealTextureDensity;                           // 0x0440 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MaxTextureDensity;                             // 0x0444 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MinLightMapDensity;                            // 0x0448 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              IdealLightMapDensity;                          // 0x044C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MaxLightMapDensity;                            // 0x0450 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bRenderLightMapDensityGrayscale : 1;           // 0x0454 (0x0004) [0x0000000000044000] [0x00000001] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bUseSound : 1;                                 // 0x0454 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	uint32_t                                           bUseAudioStreaming : 1;                        // 0x0454 (0x0004) [0x0000000000004001] [0x00000004] (CPF_Edit | CPF_Config)
	uint32_t                                           bUseBackgroundLevelStreaming : 1;              // 0x0454 (0x0004) [0x0000000000004001] [0x00000008] (CPF_Edit | CPF_Config)
	uint32_t                                           bSubtitlesEnabled : 1;                         // 0x0454 (0x0004) [0x0000000000004001] [0x00000010] (CPF_Edit | CPF_Config)
	uint32_t                                           bSubtitlesForcedOff : 1;                       // 0x0454 (0x0004) [0x0000000000004001] [0x00000020] (CPF_Edit | CPF_Config)
	uint32_t                                           bSmoothFrameRate : 1;                          // 0x0454 (0x0004) [0x0000000000004000] [0x00000040] (CPF_Config)
	uint32_t                                           bSmoothFrameRateRuntimeToggle : 1;             // 0x0454 (0x0004) [0x0000000000002000] [0x00000080] (CPF_Transient)
	uint32_t                                           bCheckForMultiplePawnsSpawnedInAFrame : 1;     // 0x0454 (0x0004) [0x0000000000004000] [0x00000100] (CPF_Config)
	uint32_t                                           bForceStaticTerrain : 1;                       // 0x0454 (0x0004) [0x0000000000004001] [0x00000200] (CPF_Edit | CPF_Config)
	uint32_t                                           bForceCPUSkinning : 1;                         // 0x0454 (0x0004) [0x0000000000004000] [0x00000400] (CPF_Config)
	uint32_t                                           bUsePostProcessEffects : 1;                    // 0x0454 (0x0004) [0x0000000000004000] [0x00000800] (CPF_Config)
	uint32_t                                           bOnScreenKismetWarnings : 1;                   // 0x0454 (0x0004) [0x0000000000004000] [0x00001000] (CPF_Config)
	uint32_t                                           bEnableKismetLogging : 1;                      // 0x0454 (0x0004) [0x0000000000004000] [0x00002000] (CPF_Config)
	uint32_t                                           bAllowMatureLanguage : 1;                      // 0x0454 (0x0004) [0x0000000000004000] [0x00004000] (CPF_Config)
	uint32_t                                           bRenderTerrainCollisionAsOverlay : 1;          // 0x0454 (0x0004) [0x0000000000004000] [0x00008000] (CPF_Config)
	uint32_t                                           bPauseOnLossOfFocus : 1;                       // 0x0454 (0x0004) [0x0000000000004000] [0x00010000] (CPF_Config)
	uint32_t                                           bCheckParticleRenderSize : 1;                  // 0x0454 (0x0004) [0x0000000000044000] [0x00020000] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bEnableColorClear : 1;                         // 0x0454 (0x0004) [0x0000000000044002] [0x00040000] (CPF_Const | CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bAreConstraintsDirty : 1;                      // 0x0454 (0x0004) [0x0000000000002000] [0x00080000] (CPF_Transient)
	uint32_t                                           bHasPendingGlobalReattach : 1;                 // 0x0454 (0x0004) [0x0000000000002000] [0x00100000] (CPF_Transient)
	uint32_t                                           bEnableOnScreenDebugMessages : 1;              // 0x0454 (0x0004) [0x0000000000044000] [0x00200000] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bEnableOnScreenDebugMessagesDisplay : 1;       // 0x0454 (0x0004) [0x0000000000002000] [0x00400000] (CPF_Transient)
	uint32_t                                           bSuppressMapWarnings : 1;                      // 0x0454 (0x0004) [0x0000000000044000] [0x00800000] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bCookSeparateSharedMPGameContent : 1;          // 0x0454 (0x0004) [0x0000000000044000] [0x01000000] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bDisableAILogging : 1;                         // 0x0454 (0x0004) [0x0000000000044000] [0x02000000] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bMuteAudioWhenNotInFocus : 1;                  // 0x0454 (0x0004) [0x0000000000004000] [0x04000000] (CPF_Config)
	uint32_t                                           bIsPauseGFxMovieOpen : 1;                      // 0x0454 (0x0004) [0x0000000000002000] [0x08000000] (CPF_Transient)
	uint32_t                                           bNoBuildLightingMessage : 1;                   // 0x0454 (0x0004) [0x0000000000004000] [0x10000000] (CPF_Config)
	uint32_t                                           bCinematicAutoSkip : 1;                        // 0x0454 (0x0004) [0x0000000000044000] [0x20000000] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           FFSComplete : 1;                               // 0x0454 (0x0004) [0x0000000000002000] [0x40000000] (CPF_Transient)
	float                                              RenderLightMapDensityGrayscaleScale;           // 0x0458 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              RenderLightMapDensityColorScale;               // 0x045C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FLinearColor                                LightMapDensityVertexMappedColor;              // 0x0460 (0x0010) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FLinearColor                                LightMapDensitySelectedColor;                  // 0x0470 (0x0010) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MinVertexDensity;                              // 0x0480 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              IdealVertexDensity;                            // 0x0484 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MaxVertexDensity;                              // 0x0488 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	class TArray<struct FStatColorMapping>             StatColorMappings;                             // 0x0490 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   EditorBrushMaterial;                           // 0x04A0 (0x0008) [0x0000000000000000]               
	class FString                                      EditorBrushMaterialName;                       // 0x04A8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UPhysicalMaterial*                           DefaultPhysMaterial;                           // 0x04B8 (0x0008) [0x0000000000000000]               
	class FString                                      DefaultPhysMaterialName;                       // 0x04C0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UApexDestructibleDamageParameters*           ApexDamageParams;                              // 0x04D0 (0x0008) [0x0000000000000000]               
	class FString                                      ApexDamageParamsName;                          // 0x04D8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   TerrainErrorMaterial;                          // 0x04E8 (0x0008) [0x0000000000000000]               
	class FString                                      TerrainErrorMaterialName;                      // 0x04F0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	int32_t                                            TerrainMaterialMaxTextureCount;                // 0x0500 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	class UClass*                                      OnlineSubsystemClass;                          // 0x0508 (0x0008) [0x0000000000000000]               
	class FString                                      DefaultOnlineSubsystemName;                    // 0x0510 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UPostProcessChain*                           DefaultPostProcess;                            // 0x0520 (0x0008) [0x0000000000000000]               
	class FString                                      DefaultPostProcessName;                        // 0x0528 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UPostProcessChain*                           ThumbnailSkeletalMeshPostProcess;              // 0x0538 (0x0008) [0x0000000000000000]               
	class FString                                      ThumbnailSkeletalMeshPostProcessName;          // 0x0540 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UPostProcessChain*                           ThumbnailParticleSystemPostProcess;            // 0x0550 (0x0008) [0x0000000000000000]               
	class FString                                      ThumbnailParticleSystemPostProcessName;        // 0x0558 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UPostProcessChain*                           ThumbnailMaterialPostProcess;                  // 0x0568 (0x0008) [0x0000000000000000]               
	class FString                                      ThumbnailMaterialPostProcessName;              // 0x0570 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UPostProcessChain*                           DefaultUIScenePostProcess;                     // 0x0580 (0x0008) [0x0000000000000000]               
	class FString                                      DefaultUIScenePostProcessName;                 // 0x0588 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UMaterial*                                   DefaultUICaretMaterial;                        // 0x0598 (0x0008) [0x0000000000000000]               
	class FString                                      DefaultUICaretMaterialName;                    // 0x05A0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   SceneCaptureReflectActorMaterial;              // 0x05B0 (0x0008) [0x0000000000000000]               
	class FString                                      SceneCaptureReflectActorMaterialName;          // 0x05B8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UMaterial*                                   SceneCaptureCubeActorMaterial;                 // 0x05C8 (0x0008) [0x0000000000000000]               
	class FString                                      SceneCaptureCubeActorMaterialName;             // 0x05D0 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UTexture2D*                                  ImageGrainNoiseTexture;                        // 0x05E0 (0x0008) [0x0000000000000000]               
	class FString                                      ImageGrainNoiseTextureName;                    // 0x05E8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UTexture2D*                                  RandomAngleTexture;                            // 0x05F8 (0x0008) [0x0000000000000000]               
	class FString                                      RandomAngleTextureName;                        // 0x0600 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UTexture2D*                                  RandomNormalTexture;                           // 0x0610 (0x0008) [0x0000000000000000]               
	class FString                                      RandomNormalTextureName;                       // 0x0618 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UTexture2D*                                  RandomMirrorDiscTexture;                       // 0x0628 (0x0008) [0x0000000000000000]               
	class FString                                      RandomMirrorDiscTextureName;                   // 0x0630 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UTexture*                                    WeightMapPlaceholderTexture;                   // 0x0640 (0x0008) [0x0000000000000000]               
	class FString                                      WeightMapPlaceholderTextureName;               // 0x0648 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UTexture2D*                                  LightMapDensityTexture;                        // 0x0658 (0x0008) [0x0000000000000000]               
	class FString                                      LightMapDensityTextureName;                    // 0x0660 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UTexture2D*                                  LightMapDensityNormal;                         // 0x0670 (0x0008) [0x0000000000000000]               
	class FString                                      LightMapDensityNormalName;                     // 0x0678 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UClient*                                     Client;                                        // 0x0688 (0x0008) [0x0000000000000002] (CPF_Const)   
	class TArray<class ULocalPlayer*>                  GamePlayers;                                   // 0x0690 (0x0010) [0x0000000000500000] (CPF_NeedCtorLink)
	class UGameViewportClient*                         GameViewport;                                  // 0x06A0 (0x0008) [0x0000000000000002] (CPF_Const)   
	class TArray<class FString>                        DeferredCommands;                              // 0x06A8 (0x0010) [0x0000000000500000] (CPF_NeedCtorLink)
	struct FQWord                                      TickCycles;                                    // 0x06B8 (0x0008) [0x0000000000000000]               
	struct FQWord                                      GameCycles;                                    // 0x06C0 (0x0008) [0x0000000000000000]               
	struct FQWord                                      ClientCycles;                                  // 0x06C8 (0x0008) [0x0000000000000000]               
	float                                              MaxSmoothedFrameRate;                          // 0x06D0 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              MinSmoothedFrameRate;                          // 0x06D4 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            NumPawnsAllowedToBeSpawnedInAFrame;            // 0x06D8 (0x0004) [0x0000000000004000] (CPF_Config)  
	struct FPointer                                    RemoteControlExec;                             // 0x06E0 (0x0008) [0x0000000000001000] (CPF_Native)  
	struct FColor                                      C_WorldBox;                                    // 0x06E8 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_BrushWire;                                   // 0x06EC (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_AddWire;                                     // 0x06F0 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_SubtractWire;                                // 0x06F4 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_SemiSolidWire;                               // 0x06F8 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_NonSolidWire;                                // 0x06FC (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_WireBackground;                              // 0x0700 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_ScaleBoxHi;                                  // 0x0704 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_VolumeCollision;                             // 0x0708 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_BSPCollision;                                // 0x070C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_OrthoBackground;                             // 0x0710 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_Volume;                                      // 0x0714 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_BrushShape;                                  // 0x0718 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_BSPMeshWire;                                 // 0x071C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_StaticMeshWire;                              // 0x0720 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_SkeletalMeshWire;                            // 0x0724 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_TerrainMeshWire;                             // 0x0728 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_ParticleMeshWire;                            // 0x072C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_FoliageMeshWire;                             // 0x0730 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_LensFlareMeshWire;                           // 0x0734 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_DecalMeshWire;                               // 0x0738 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_BrushWireSelected;                           // 0x073C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_StaticMeshWireSelected;                      // 0x0740 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_FoliageMeshWireSelected;                     // 0x0744 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_ParticleMeshWireSelected;                    // 0x0748 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_TerrainMeshWireSelected;                     // 0x074C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_SkeletalMeshWireSelected;                    // 0x0750 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_BSPMeshWireSelected;                         // 0x0754 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_DecalMeshWireSelected;                       // 0x0758 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_AddWireSelected;                             // 0x075C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_SubtractWireSelected;                        // 0x0760 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_SemiSolidWireSelected;                       // 0x0764 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_NonSolidWireSelected;                        // 0x0768 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_ScaleBoxHiSelected;                          // 0x076C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_VolumeSelected;                              // 0x0770 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FColor                                      C_BrushShapeSelected;                          // 0x0774 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FLinearColor                                OverdrawOpaqueColor;                           // 0x0778 (0x0010) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FLinearColor                                OverdrawHighColor;                             // 0x0788 (0x0010) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FLinearColor                                OverdrawMediumColor;                           // 0x0798 (0x0010) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FLinearColor                                OverdrawLowColor;                              // 0x07A8 (0x0010) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FLinearColor                                OverdrawStartColor;                            // 0x07B8 (0x0010) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FLinearColor                                OverdrawBoundaries;                            // 0x07C8 (0x0010) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              OverdrawSlice;                                 // 0x07D8 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              StreamingDistanceFactor;                       // 0x07DC (0x0004) [0x0000000000000001] (CPF_Edit)    
	class FString                                      ScoutClassName;                                // 0x07E0 (0x0010) [0x0000000000404002] (CPF_Const | CPF_Config | CPF_NeedCtorLink)
	ETransitionType                                    TransitionType;                                // 0x07F0 (0x0001) [0x0000000000000000]               
	class FString                                      TransitionDescription;                         // 0x07F8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      TransitionGameType;                            // 0x0808 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              MeshLODRange;                                  // 0x0818 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              CameraRotationThreshold;                       // 0x081C (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              CameraTranslationThreshold;                    // 0x0820 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              RenderedVelocityObjectScale;                   // 0x0824 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              RenderedVelocityCameraScale;                   // 0x0828 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              RenderedVelocityTranslucencyScale;             // 0x082C (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              PrimitiveProbablyVisibleTime;                  // 0x0830 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              PercentUnoccludedRequeries;                    // 0x0834 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              MaxOcclusionPixelsFraction;                    // 0x0838 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            PhysXLevel;                                    // 0x083C (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            MaxFluidNumVerts;                              // 0x0840 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              FluidSimulationTimeLimit;                      // 0x0844 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            MaxParticleResize;                             // 0x0848 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            MaxParticleResizeWarn;                         // 0x084C (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            MaxParticleVertexMemory;                       // 0x0850 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            MaxParticleSpriteCount;                        // 0x0854 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            MaxParticleSubUVCount;                         // 0x0858 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            MaxParticlesPerEmitter;                        // 0x085C (0x0004) [0x0000000000000000]               
	int32_t                                            BeginUPTryCount;                               // 0x0860 (0x0004) [0x0000000000004000] (CPF_Config)  
	class TArray<struct FDropNoteInfo>                 PendingDroppedNotes;                           // 0x0868 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class FString                                      DynamicCoverMeshComponentName;                 // 0x0878 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	float                                              NetClientTicksPerSecond;                       // 0x0888 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MaxTrackedOcclusionIncrement;                  // 0x088C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              TrackedOcclusionStepSize;                      // 0x0890 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FLinearColor                                DefaultSelectedMaterialColor;                  // 0x0894 (0x0010) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FLinearColor                                DefaultHoveredMaterialColor;                   // 0x08A4 (0x0010) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FLinearColor                                SelectedMaterialColor;                         // 0x08B4 (0x0010) [0x0000000000002000] (CPF_Transient)
	struct FLinearColor                                UnselectedMaterialColor;                       // 0x08C4 (0x0010) [0x0000000000002000] (CPF_Transient)
	int32_t                                            NumberOfOnScreenDebugMessages;                 // 0x08D4 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	class TArray<struct FName>                         IgnoreSimulatedFuncWarnings;                   // 0x08D8 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	int32_t                                            ScreenSaverInhibitorSemaphore;                 // 0x08E8 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FPointer                                    ScreenSaverInhibitor;                          // 0x08F0 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FDouble                                     LoadingMovieStartTime;                         // 0x08F8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FColor                                      BlockingMeshColor;                             // 0x0900 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              BlockingMeshOpacity;                           // 0x0904 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              CinematicAutoSkipDelay;                        // 0x0908 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	class TArray<class FString>                        CinematicAutoSkipMaps;                         // 0x0910 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	float                                              SFXVolume;                                     // 0x0920 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              VoiceOverVolume;                               // 0x0924 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              BinkMovieVolumeScaleFactor;                    // 0x0928 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FSet_Mirror                                 ObjectReferenceEmitters;                       // 0x0930 (0x0050) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class FString                                      CommManagerClassName;                          // 0x0980 (0x0010) [0x0000000000444000] (CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink)
	class UCommManager*                                CommManager;                                   // 0x0990 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Engine");
		}

		return uClassPointer;
	};

	static int32_t GetPhysXLevel();
	static class UCommManager* GetCommManager();
	static class UFacebookIntegration* GetFacebookIntegration();
	static bool BasicLoadObject(class UObject* Obj, const class FString& PathName, bool bIsSaveGame, int32_t Version);
	static bool BasicSaveObject(class UObject* Obj, const class FString& PathName, bool bIsSaveGame, int32_t Version);
	void AddTextureStreamingSlaveLoc(const struct FVector& InLoc, float BoostFactor, bool bOverrideLocation, float OverrideDuration);
	bool BrowseToURL(const class FString& BrowseURL, class FString& Error);
	static class UPostProcessChain* GetWorldPostProcessChain();
	static class UEngine* GetEngine();
	static void AddOverlayWrapped(class UFont* Font, const class FString& Text, float X, float Y, float ScaleX, float ScaleY, float WrapWidth);
	static void AddOverlay(class UFont* Font, const class FString& Text, float X, float Y, float ScaleX, float ScaleY, bool bIsCentered);
	static void RemoveAllOverlays();
	void StopMovie(bool bDelayStopUntilGameHasRendered);
	bool PlayLoadMapMovie();
	static class FString GetLastMovieName();
	static class UAkAudioDevice* GetAkAudioDevice();
	static bool IsSplitScreen();
	static class UFont* GetAdditionalFont(int32_t AdditionalFontIndex);
	static class UFont* GetSubtitleFont();
	static class UFont* GetLargeFont();
	static class UFont* GetMediumFont();
	static class UFont* GetSmallFont();
	static class UFont* GetTinyFont();
	static class FString GetBuildDate();
	static class AWorldInfo* GetCurrentWorldInfo();
	static bool IsGame();
	static bool IsEditor();
};

// Class Engine.GameEngine
// 0x0220 (0x0998 - 0x0BB8)
class UGameEngine : public UEngine
{
public:
	class UPendingLevel*                               GPendingLevel;                                 // 0x0998 (0x0008) [0x0000000000000000]               
	uint32_t                                           bCleanupForPendingLevel : 1;                   // 0x09A0 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bWorldWasLoadedThisTick : 1;                   // 0x09A0 (0x0004) [0x0000000000002002] [0x00000002] (CPF_Const | CPF_Transient)
	uint32_t                                           bShouldCommitPendingMapChange : 1;             // 0x09A0 (0x0004) [0x0000000000000002] [0x00000004] (CPF_Const)
	uint32_t                                           bClearAnimSetLinkupCachesOnLoadMap : 1;        // 0x09A0 (0x0004) [0x0000000000004000] [0x00000008] (CPF_Config)
	class FString                                      PendingLevelPlayerControllerClassName;         // 0x09A8 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	struct FURL                                        LastURL;                                       // 0x09B8 (0x0060) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FURL                                        LastRemoteURL;                                 // 0x0A18 (0x0060) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<class FString>                        ServerActors;                                  // 0x0A78 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class FString                                      TravelURL;                                     // 0x0A88 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint8_t                                            TravelType;                                    // 0x0A98 (0x0001) [0x0000000000000000]               
	ELoadingMovieState                                 LoadingMovieState;                             // 0x0A99 (0x0001) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class UOnlineSubsystem*                            OnlineSubsystem;                               // 0x0AA0 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class UDownloadableContentEnumerator*              DLCEnumerator;                                 // 0x0AA8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class FString                                      DownloadableContentEnumeratorClassName;        // 0x0AB0 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class FString                                      DevDownloadableContentEnumeratorClassName;     // 0x0AC0 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UDownloadableContentManager*                 DLCManager;                                    // 0x0AD0 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class FString                                      DownloadableContentOfferEnumeratorClassName;   // 0x0AD8 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UDownloadableContentOfferEnumerator*         DLCOfferEnumerator;                            // 0x0AE8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class FString                                      DownloadableContentManagerClassName;           // 0x0AF0 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UInGameAdManager*                            AdManager;                                     // 0x0B00 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class FString                                      InGameAdManagerClassName;                      // 0x0B08 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class TArray<struct FName>                         LevelsToLoadForPendingMapChange;               // 0x0B18 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<class ULevel*>                        LoadedLevelsForPendingMapChange;               // 0x0B28 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class FString                                      PendingMapChangeFailureDescription;            // 0x0B38 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	float                                              MaxDeltaTime;                                  // 0x0B48 (0x0004) [0x0000000000004000] (CPF_Config)  
	class TArray<struct FLevelStreamingStatus>         PendingLevelStreamingStatusUpdates;            // 0x0B50 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<class UObjectReferencer*>             ObjectReferencers;                             // 0x0B60 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FFullyLoadedPackagesInfo>      PackagesToFullyLoad;                           // 0x0B70 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FNamedNetDriver>               NamedNetDrivers;                               // 0x0B80 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FAnimTag>                      AnimTags;                                      // 0x0B90 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UDataPlatform*                               DataPlatform;                                  // 0x0BA0 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class FString                                      DataPlatformClassName;                         // 0x0BA8 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GameEngine");
		}

		return uClassPointer;
	};

	static class UInGameAdManager* GetAdManager();
	static class UDownloadableContentOfferEnumerator* GetDLCOfferEnumerator();
	static class UDownloadableContentManager* GetDLCManager();
	static class UDownloadableContentEnumerator* GetDLCEnumerator();
	static class UOnlineSubsystem* GetOnlineSubsystem();
	void DestroyNamedNetDriver(const struct FName& NetDriverName);
	bool CreateNamedNetDriver(const struct FName& NetDriverName);
};

// Class Engine.EngineBaseTypes
// 0x0000 (0x0058 - 0x0058)
class UEngineBaseTypes : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EngineBaseTypes");
		}

		return uClassPointer;
	};

};

// Class Engine.EngineTypes
// 0x0000 (0x0058 - 0x0058)
class UEngineTypes : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EngineTypes");
		}

		return uClassPointer;
	};

};

// Class Engine.ExpressionEvaluator
// 0x0000 (0x0058 - 0x0058)
class UExpressionEvaluator : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ExpressionEvaluator");
		}

		return uClassPointer;
	};

	bool Evaluate(class UObject* ContextSource);
};

// Class Engine.ExpressionTree
// 0x0008 (0x0058 - 0x0060)
class UExpressionTree : public UExpressionEvaluator
{
public:
	class UExpressionEvaluator*                        RootChild;                                     // 0x0058 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ExpressionTree");
		}

		return uClassPointer;
	};

	bool Evaluate(class UObject* ContextSource);
};

// Class Engine.ResolvedContextExpressionEvaluator
// 0x0010 (0x0058 - 0x0068)
class UResolvedContextExpressionEvaluator : public UExpressionEvaluator
{
public:
	class UAttributeContextResolver*                   ContextResolver;                               // 0x0058 (0x0008) [0x0000000004000003] (CPF_Edit | CPF_Const | CPF_EditInline)
	class UExpressionEvaluator*                        Condition;                                     // 0x0060 (0x0008) [0x0000000004000003] (CPF_Edit | CPF_Const | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ResolvedContextExpressionEvaluator");
		}

		return uClassPointer;
	};

	bool Evaluate(class UObject* ContextSource);
};

// Class Engine.FacebookIntegration
// 0x00A0 (0x0058 - 0x00F8)
class UFacebookIntegration : public UObject
{
public:
	class FString                                      AppID;                                         // 0x0058 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class FString                                      UserName;                                      // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      UserId;                                        // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      AccessToken;                                   // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FScriptDelegate>               AuthorizationDelegates;                        // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FScriptDelegate>               FacebookRequestCompleteDelegates;              // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FScriptDelegate>               WebRequestCompleteDelegates;                   // 0x00B8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnAuthorizationComplete__Delegate;           // 0x00C8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnFacebookRequestComplete__Delegate;         // 0x00D8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnWebRequestComplete__Delegate;              // 0x00E8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FacebookIntegration");
		}

		return uClassPointer;
	};

	void ClearWebRequestCompleteDelegate(const struct FScriptDelegate& InDelegate);
	void AddWebRequestCompleteDelegate(const struct FScriptDelegate& InDelegate);
	void OnWebRequestComplete(const class FString& Response);
	void ClearFacebookRequestCompleteDelegate(const struct FScriptDelegate& InDelegate);
	void AddFacebookRequestCompleteDelegate(const struct FScriptDelegate& InDelegate);
	void OnFacebookRequestComplete(const class FString& JsonString);
	void ClearAuthorizationCompleteDelegate(const struct FScriptDelegate& InDelegate);
	void AddAuthorizationCompleteDelegate(const struct FScriptDelegate& InDelegate);
	void OnAuthorizationComplete(bool bSucceeded);
	void eventDisconnect();
	void eventFacebookRequest(const class FString& GraphRequest);
	void eventWebRequest(const class FString& URL, const class FString& POSTPayload);
	bool eventIsAuthorized();
	bool eventAuthorize();
	bool eventInit();
};

// Class Engine.FaceFXAnimSet
// 0x0038 (0x0058 - 0x0090)
class UFaceFXAnimSet : public UObject
{
public:
	uint32_t                                           bStreamWithAudio : 1;                          // 0x0058 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FPointer                                    InternalFaceFXAnimSet;                         // 0x0060 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<uint8_t>                              RawFaceFXAnimSetBytes;                         // 0x0068 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<uint8_t>                              RawFaceFXMiniSessionBytes;                     // 0x0078 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	int32_t                                            NumLoadErrors;                                 // 0x0088 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FaceFXAnimSet");
		}

		return uClassPointer;
	};

};

// Class Engine.FaceFXAsset
// 0x0050 (0x0058 - 0x00A8)
class UFaceFXAsset : public UObject
{
public:
	struct FPointer                                    FaceFXActor;                                   // 0x0058 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<uint8_t>                              RawFaceFXActorBytes;                           // 0x0060 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<uint8_t>                              RawFaceFXSessionBytes;                         // 0x0070 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<class UFaceFXAnimSet*>                MountedFaceFXAnimSets;                         // 0x0080 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	int32_t                                            NumLoadErrors;                                 // 0x0090 (0x0004) [0x0000000000000000]               
	class TArray<struct FGroupAnimationAndSoundIdentifier> SoundNodeWaveToGroupAndAnimNameArray;          // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FaceFXAsset");
		}

		return uClassPointer;
	};

	void UnmountFaceFXAnimSet(class UFaceFXAnimSet* AnimSet);
	void MountFaceFXAnimSet(class UFaceFXAnimSet* AnimSet);
};

// Class Engine.FlexContainer
// 0x0088 (0x0058 - 0x00E0)
class UFlexContainer : public UObject
{
public:
	float                                              Radius;                                        // 0x0058 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MaxParticles;                                  // 0x005C (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDebugDraw : 1;                                // 0x0060 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bComplexCollision : 1;                         // 0x0060 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bFluid : 1;                                    // 0x0060 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	int32_t                                            NumIterations;                                 // 0x0064 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            NumSubsteps;                                   // 0x0068 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Gravity;                                       // 0x006C (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              SleepThreshold;                                // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxVelocity;                                   // 0x007C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SuccessiveOverRelaxation;                      // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CellSizeFactor;                                // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CollisionMargin;                               // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CollisionDistance;                             // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Friction;                                      // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Restitution;                                   // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ShockPropagation;                              // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Dissipation;                                   // 0x009C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Wind;                                          // 0x00A0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              Drag;                                          // 0x00AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Lift;                                          // 0x00B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RestDistance;                                  // 0x00B4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Adhesion;                                      // 0x00B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Cohesion;                                      // 0x00BC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SurfaceTension;                                // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Viscosity;                                     // 0x00C4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              VorticityConfinement;                          // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SolidPressure;                                 // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FreeSurfaceDrag;                               // 0x00D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              PlasticThreshold;                              // 0x00D4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              PlasticCreep;                                  // 0x00D8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FlexContainer");
		}

		return uClassPointer;
	};

};

// Class Engine.Font
// 0x0158 (0x0058 - 0x01B0)
class UFont : public UObject
{
public:
	class TArray<struct FFontCharacter>                Characters;                                    // 0x0058 (0x0010) [0x0000000004400001] (CPF_Edit | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UTexture2D*>                    Textures;                                      // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint8_t                                           UnknownData00[0x50];                           // 0x0078 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.Font.CharRemap
	int32_t                                            IsRemapped;                                    // 0x00C8 (0x0004) [0x0000000000000000]               
	float                                              EmScale;                                       // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Ascent;                                        // 0x00D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Descent;                                       // 0x00D4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Leading;                                       // 0x00D8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Kerning;                                       // 0x00DC (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FFontImportOptionsData                      ImportOptions;                                 // 0x00E0 (0x00B0) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	int32_t                                            NumCharacters;                                 // 0x0190 (0x0004) [0x0000000000002000] (CPF_Transient)
	class TArray<int32_t>                              MaxCharHeight;                                 // 0x0198 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	float                                              ScalingFactor;                                 // 0x01A8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Font");
		}

		return uClassPointer;
	};

	void GetStringHeightAndWidth(class FString& InString, int32_t& Height, int32_t& Width);
	float GetMaxCharHeight();
	float GetAuthoredViewportHeight(float ViewportHeight);
	float GetScalingFactor(float HeightTest);
	int32_t GetResolutionPageIndex(float HeightTest);
};

// Class Engine.MultiFont
// 0x0010 (0x01B0 - 0x01C0)
class UMultiFont : public UFont
{
public:
	class TArray<float>                                ResolutionTestTable;                           // 0x01B0 (0x0010) [0x0000000004400001] (CPF_Edit | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MultiFont");
		}

		return uClassPointer;
	};

	int32_t GetResolutionTestTableIndex(float HeightTest);
};

// Class Engine.FontImportOptions
// 0x00B0 (0x0058 - 0x0108)
class UFontImportOptions : public UObject
{
public:
	struct FFontImportOptionsData                      Data;                                          // 0x0058 (0x00B0) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FontImportOptions");
		}

		return uClassPointer;
	};

};

// Class Engine.ForceFeedbackManager
// 0x0090 (0x0058 - 0x00E8)
class UForceFeedbackManager : public UObject
{
public:
	uint32_t                                           bAllowsForceFeedback : 1;                      // 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bIsPaused : 1;                                 // 0x0058 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bIsSuppressed : 1;                             // 0x0058 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FPlayingWaveformData                        FFWaveform_Standard;                           // 0x0060 (0x0040) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FPlayingWaveformData                        FFWaveform_Triggers;                           // 0x00A0 (0x0040) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            CurrentWaveformRef;                            // 0x00E0 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ForceFeedbackManager");
		}

		return uClassPointer;
	};

};

// Class Engine.ForceFeedbackWaveform
// 0x0030 (0x0058 - 0x0088)
class UForceFeedbackWaveform : public UObject
{
public:
	EWaveformTarget                                    TargetForWaveform;                             // 0x0058 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bIsLooping : 1;                                // 0x005C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class TArray<struct FWaveformSample>               Samples;                                       // 0x0060 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              Scale;                                         // 0x0070 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              WaveformFalloffStartDistance;                  // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxWaveformDistance;                           // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ImpulseTriggerFallbackScalar;                  // 0x007C (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            WaveformRef;                                   // 0x0080 (0x0004) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ForceFeedbackWaveform");
		}

		return uClassPointer;
	};

};

// Class Engine.FractureMaterial
// 0x0008 (0x0058 - 0x0060)
class UFractureMaterial : public UObject
{
public:
	class UParticleSystem*                             FractureEffect;                                // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FractureMaterial");
		}

		return uClassPointer;
	};

};

// Class Engine.GBXCameraInputs
// 0x0040 (0x0058 - 0x0098)
class UGBXCameraInputs : public UObject
{
public:
	float                                              aTurn;                                         // 0x0058 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              aLookUp;                                       // 0x005C (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     EyeLocation;                                   // 0x0060 (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     CollisionSafeLocation;                         // 0x006C (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     PawnVelocity;                                  // 0x0078 (0x000C) [0x0000000000002000] (CPF_Transient)
	float                                              PawnGroundSpeed;                               // 0x0084 (0x0004) [0x0000000000002000] (CPF_Transient)
	class APlayerController*                           Controller;                                    // 0x0088 (0x0008) [0x0000000000002000] (CPF_Transient)
	class AActor*                                      ViewTarget;                                    // 0x0090 (0x0008) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXCameraInputs");
		}

		return uClassPointer;
	};

	void UpdateViewTargetInputs(class AActor* CurrentViewTarget);
	void UpdateControllerInputs(class APlayerController* PC);
};

// Class Engine.GBXCrossLevelReferenceContainer
// 0x0008 (0x0058 - 0x0060)
class UGBXCrossLevelReferenceContainer : public UObject
{
public:
	class UObject*                                     CrossLevelObjectRef;                           // 0x0058 (0x0008) [0x0000200000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXCrossLevelReferenceContainer");
		}

		return uClassPointer;
	};

};

// Class Engine.GBXDefinition
// 0x0000 (0x0058 - 0x0058)
class UGBXDefinition : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXDefinition");
		}

		return uClassPointer;
	};

	void InitializeDefinitionActor(class AActor* DefinitionActor);
	class UClass* GetDefinitionActorClass();
	static class FString StaticGetFullNameForDefinition(class UGBXDefinition* Definition);
	class FString GetFullDefinitionName();
	static class UGBXDefinition* GetDefinition(class UClass* DefinitionClass, const class FString& DefinitionName);
};

// Class Engine.AttributeDefinitionBase
// 0x0028 (0x0058 - 0x0080)
class UAttributeDefinitionBase : public UGBXDefinition
{
public:
	uint32_t                                           bIsSimpleAttribute : 1;                        // 0x0058 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	EAttributeDataType                                 AttributeDataType;                             // 0x005C (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<class UAttributeContextResolver*>     ContextResolverChain;                          // 0x0060 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UAttributeValueResolver*>       ValueResolverChain;                            // 0x0070 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AttributeDefinitionBase");
		}

		return uClassPointer;
	};

	bool SetAttributeBaseValue(class UObject* ContextSource, float BaseValue, bool optionalBSuppressNotify);
	bool RemoveAttributeModifier(class UObject* Context, class UAttributeModifier* Modifier, bool optionalBSuppressNotify);
	bool AddAttributeModifier(class UObject* Context, class UAttributeModifier* Modifier, bool optionalBSuppressNotify);
	class FString GetDescriptorFromContext(class UObject* Context);
	float GetBaseValueFromContext(class UObject* Context);
	float GetValueFromContext(class UObject* Context);
	void ResolveContexts(class UObject* ContextSource, class TArray<class UObject*>& ResolvedContexts);
	class UObject* ResolveContext(class UObject* ContextSource);
};

// Class Engine.AttributeDefinition
// 0x0000 (0x0080 - 0x0080)
class UAttributeDefinition : public UAttributeDefinitionBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AttributeDefinition");
		}

		return uClassPointer;
	};

	class FString GetDescriptor(class UObject* ContextSource, class UObject* optionalOptionalOverrideContextSource, class UObject*& ResolvedContext);
	float GetBaseValue(class UObject* ContextSource, class UObject* optionalOptionalOverrideContextSource, class UObject*& ResolvedContext);
	float GetValue(class UObject* ContextSource, class UObject* optionalOptionalOverrideContextSource, class UObject*& ResolvedContext);
	static float StaticGetAttributeValueOrDefault(class UAttributeDefinition* Definition, class UObject* ContextSource, float DefaultValue, class UObject* optionalOptionalOverrideContextSource);
};

// Class Engine.NestedAttributeDefinition
// 0x0010 (0x0080 - 0x0090)
class UNestedAttributeDefinition : public UAttributeDefinition
{
public:
	class UAttributeDefinition*                        OuterContextAttributeDefinition;               // 0x0080 (0x0008) [0x0000000004000001] (CPF_Edit | CPF_EditInline)
	class UAttributeDefinition*                        InnerContextAttributeDefinition;               // 0x0088 (0x0008) [0x0000000004000001] (CPF_Edit | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NestedAttributeDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.AttributeDefinitionMultiContext
// 0x0008 (0x0080 - 0x0088)
class UAttributeDefinitionMultiContext : public UAttributeDefinitionBase
{
public:
	class UAttributeMultiContextResolver*              MultiContextResolver;                          // 0x0080 (0x0008) [0x0000000004000003] (CPF_Edit | CPF_Const | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AttributeDefinitionMultiContext");
		}

		return uClassPointer;
	};

	void GetDescriptors(class UObject* ContextSource, class UObject* optionalOptionalOverrideContextSource, class TArray<class FString>& Descriptors, class TArray<class UObject*>& ResolvedContexts);
	void GetBaseValues(class UObject* ContextSource, class UObject* optionalOptionalOverrideContextSource, class TArray<float>& BaseValues, class TArray<class UObject*>& ResolvedContexts);
	void GetValues(class UObject* ContextSource, class UObject* optionalOptionalOverrideContextSource, class TArray<float>& Values, class TArray<class UObject*>& ResolvedContexts);
	static void StaticGetAttributeValues(class UAttributeDefinitionMultiContext* Definition, class UObject* ContextSource, class TArray<float>& Values);
	void ResolveContexts(class UObject* ContextSource, class TArray<class UObject*>& ResolvedContexts);
};

// Class Engine.AttributeInitializationDefinition
// 0x01E8 (0x0058 - 0x0240)
class UAttributeInitializationDefinition : public UGBXDefinition
{
public:
	EBaseValueMode                                     BaseValueMode;                                 // 0x0058 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EAttributeInitializationRounding                   RoundingMode;                                  // 0x0059 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FBalanceFormula                             ValueFormula;                                  // 0x0060 (0x0088) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	struct FConditionalInitializationExpressions       ConditionalInitialization;                     // 0x00E8 (0x0038) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	struct FCoefficientFormula                         AddedCoefficientFormula;                       // 0x0120 (0x0088) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	struct FVariance                                   RandomVariance;                                // 0x01A8 (0x0048) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FRange                                      RangeRestriction;                              // 0x01F0 (0x0050) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AttributeInitializationDefinition");
		}

		return uClassPointer;
	};

	static bool SetBaseValue(class UAttributeDefinition* DestAttribute, class UObject* ValueContextSource, class UObject* AttributeContextSource, struct FAttributeInitializationData& BaseValue);
	static float EvaluateInitializationData(const struct FAttributeInitializationData& InitializationData, class UObject* ContextSource, class UObject* optionalOptionalOverrideContextSource);
};

// Class Engine.BaseBalanceDefinition
// 0x0000 (0x0058 - 0x0058)
class UBaseBalanceDefinition : public UGBXDefinition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BaseBalanceDefinition");
		}

		return uClassPointer;
	};

	bool ApplyGradeCustomizations(class AActor* BalanceDefSpawnedActor, int32_t GradeIndex);
	bool DoesSpawnChampion();
	float GetSpawnProbabilityModifier(int32_t GameStage, int32_t AwesomeLevel);
	bool IsGameStageSupported(int32_t GameStage, int32_t AwesomeLevel);
	int32_t SelectGradeIndex(int32_t GameStage, int32_t AwesomeLevel);
};

// Class Engine.BaseHitRegionDefinition
// 0x0000 (0x0058 - 0x0058)
class UBaseHitRegionDefinition : public UGBXDefinition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BaseHitRegionDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.BehaviorCollectionDefinition
// 0x0010 (0x0058 - 0x0068)
class UBehaviorCollectionDefinition : public UGBXDefinition
{
public:
	class TArray<class UBehaviorBase*>                 Behaviors;                                     // 0x0058 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BehaviorCollectionDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.CharacterClassDefinition
// 0x0098 (0x0058 - 0x00F0)
class UCharacterClassDefinition : public UGBXDefinition
{
public:
	float                                              GroundSpeed;                                   // 0x0058 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              AirSpeed;                                      // 0x005C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              WalkingPct;                                    // 0x0060 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SprintingPct;                                  // 0x0064 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              JumpZ;                                         // 0x0068 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              CrouchedPct;                                   // 0x006C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BackpedalPct;                                  // 0x0070 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FAttributeInitializationData                BaseEncumbranceResistance;                     // 0x0078 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bUseLagCompensation : 1;                       // 0x0098 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bDealsLocationalDamage : 1;                    // 0x0098 (0x0004) [0x0000000020000002] [0x00000002] (CPF_Const | CPF_Deprecated)
	uint32_t                                           CanHarmSelf : 1;                               // 0x0098 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           bAutoDisableAttractorOnDeath : 1;              // 0x0098 (0x0004) [0x0000000000000002] [0x00000008] (CPF_Const)
	float                                              MaxFallSpeed;                                  // 0x009C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UResourcePoolDefinition*                     HealthPoolDefinition;                          // 0x00A0 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UResourcePoolDefinition*                     ShieldPoolDefinition;                          // 0x00A8 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UResourcePoolDefinition*                     AccuracyPoolDefinition;                        // 0x00B0 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UResourcePoolDefinition*                     OffHandAccuracyPoolDefinition;                 // 0x00B8 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<class UResourcePoolDefinition*>       ResourcePools;                                 // 0x00C0 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	struct FAttributeInitializationData                BaseArmor;                                     // 0x00D0 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CharacterClassDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.CinematicModeDefinition
// 0x0008 (0x0058 - 0x0060)
class UCinematicModeDefinition : public UGBXDefinition
{
public:
	uint32_t                                           bDisableMovement : 1;                          // 0x0058 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDisableTurning : 1;                           // 0x0058 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bHidePlayer : 1;                               // 0x0058 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bDisableInput : 1;                             // 0x0058 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bHideHUD : 1;                                  // 0x0058 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bEnableGodMode : 1;                            // 0x0058 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bEnableNoTarget : 1;                           // 0x0058 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bAffectsAudio : 1;                             // 0x0058 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bCinematicSplitScreen : 1;                     // 0x0058 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bHideOutlines : 1;                             // 0x0058 (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bDisableSkills : 1;                            // 0x0058 (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	uint32_t                                           bDisableScreenParticles : 1;                   // 0x0058 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CinematicModeDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.CoverTag
// 0x0018 (0x0058 - 0x0070)
class UCoverTag : public UGBXDefinition
{
public:
	ECoverAction                                       Action;                                        // 0x0058 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ViewHeight;                                    // 0x005C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ForwardCheckDistance;                          // 0x0060 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     LeanOffset;                                    // 0x0064 (0x000C) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CoverTag");
		}

		return uClassPointer;
	};

};

// Class Engine.DamageTypeDefinition
// 0x0000 (0x0058 - 0x0058)
class UDamageTypeDefinition : public UGBXDefinition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DamageTypeDefinition");
		}

		return uClassPointer;
	};

	float CalcRadiusDamageScale(float Dist, float DamageRadius, const struct FVector& optionalHurtOrigin);
	float GetMinDamagePercent();
	float GetMinDamageRadius();
	float GetMaxDamageRadius();
	static void RecordRecentDamage(float Damage, class AController* DamageInstigator, class UDamageTypeDefinition* DamageTypeDefinition, bool optionalBWasShieldDamage, struct FRecentDamageTracker& RecentDamage);
	EDamageType GetDamageType();
	bool IsHealingDamageType();
	float GetPawnDamageTypeModifier(class APawn* PawnTakingDamage);
	float GetSurfaceDamageTypeModifier(uint8_t DamageSurfaceType, class AController* DamageInstigator);
};

// Class Engine.EngineInteractionIconDefinition
// 0x0000 (0x0058 - 0x0058)
class UEngineInteractionIconDefinition : public UGBXDefinition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EngineInteractionIconDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.ExpressionEvaluatorDefinition
// 0x0008 (0x0058 - 0x0060)
class UExpressionEvaluatorDefinition : public UGBXDefinition
{
public:
	class UExpressionEvaluator*                        Expression;                                    // 0x0058 (0x0008) [0x0000000004000001] (CPF_Edit | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ExpressionEvaluatorDefinition");
		}

		return uClassPointer;
	};

	bool Evaluate(class UObject* ContextSource);
};

// Class Engine.ForceFieldShape
// 0x0008 (0x0058 - 0x0060)
class UForceFieldShape : public UGBXDefinition
{
public:
	struct FPointer                                    Geometry;                                      // 0x0058 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ForceFieldShape");
		}

		return uClassPointer;
	};

	class UPrimitiveComponent* eventGetDrawComponent();
	void eventFillByCylinder(float BottomRadius, float TopRadius, float Height, float HeightOffset);
	void eventFillByCapsule(float Height, float Radius);
	void eventFillByBox(const struct FVector& Dimension);
	void eventFillBySphere(float Radius);
};

// Class Engine.ForceFieldShapeBox
// 0x0008 (0x0060 - 0x0068)
class UForceFieldShapeBox : public UForceFieldShape
{
public:
	class UDrawBoxComponent*                           Shape;                                         // 0x0060 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ForceFieldShapeBox");
		}

		return uClassPointer;
	};

	class UPrimitiveComponent* eventGetDrawComponent();
	void eventFillByCylinder(float BottomRadius, float TopRadius, float Height, float HeightOffset);
	void eventFillByCapsule(float Height, float Radius);
	void eventFillByBox(const struct FVector& Extent);
	void eventFillBySphere(float Radius);
	struct FVector eventGetRadii();
};

// Class Engine.ForceFieldShapeCapsule
// 0x0008 (0x0060 - 0x0068)
class UForceFieldShapeCapsule : public UForceFieldShape
{
public:
	class UDrawCapsuleComponent*                       Shape;                                         // 0x0060 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ForceFieldShapeCapsule");
		}

		return uClassPointer;
	};

	class UPrimitiveComponent* eventGetDrawComponent();
	void eventFillByCylinder(float BottomRadius, float TopRadius, float Height, float HeightOffset);
	void eventFillByCapsule(float Height, float Radius);
	void eventFillByBox(const struct FVector& Extent);
	void eventFillBySphere(float Radius);
	float eventGetRadius();
	float eventGetHeight();
};

// Class Engine.ForceFieldShapeSphere
// 0x0010 (0x0060 - 0x0070)
class UForceFieldShapeSphere : public UForceFieldShape
{
public:
	class UDrawSphereComponent*                        Shape;                                         // 0x0060 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	float                                              SphereRadius;                                  // 0x0068 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ForceFieldShapeSphere");
		}

		return uClassPointer;
	};

	class UPrimitiveComponent* eventGetDrawComponent();
	void eventFillByCylinder(float BottomRadius, float TopRadius, float Height, float HeightOffset);
	void eventFillByCapsule(float Height, float Radius);
	void eventFillByBox(const struct FVector& Extent);
	void eventFillBySphere(float Radius);
	float eventGetRadius();
};

// Class Engine.GearboxCalloutDefinition
// 0x0010 (0x0058 - 0x0068)
class UGearboxCalloutDefinition : public UGBXDefinition
{
public:
	float                                              MaxCallOutDistance;                            // 0x0058 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              MinCallOutDistance;                            // 0x005C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bCheckRarity : 1;                              // 0x0060 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	int32_t                                            MinRarityCallOutLevel;                         // 0x0064 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GearboxCalloutDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.GestaltPartMatricesCollectionDefinition
// 0x0010 (0x0058 - 0x0068)
class UGestaltPartMatricesCollectionDefinition : public UGBXDefinition
{
public:
	class TArray<struct FGPMCollection>                Collection;                                    // 0x0058 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GestaltPartMatricesCollectionDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.ImpactDefinition
// 0x0000 (0x0058 - 0x0058)
class UImpactDefinition : public UGBXDefinition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ImpactDefinition");
		}

		return uClassPointer;
	};

	void HandleRigidBodyImpact(class AActor* Instigator, class UPrimitiveComponent* HitComponent, class UPrimitiveComponent* OtherComponent, int32_t ContactIndex, bool optionalBReplicateEffect, struct FCollisionImpactData& RigidCollisionData);
};

// Class Engine.InventoryCardPresentationDefinition
// 0x0030 (0x0058 - 0x0088)
class UInventoryCardPresentationDefinition : public UGBXDefinition
{
public:
	class FString                                      ZippyFrame;                                    // 0x0058 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class FString                                      ItemFrame;                                     // 0x0068 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class FString                                      DescriptionLocReference;                       // 0x0078 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InventoryCardPresentationDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.ManufacturerDefinition
// 0x0030 (0x0058 - 0x0088)
class UManufacturerDefinition : public UGBXDefinition
{
public:
	class TArray<struct FManufacturerGradeData>        Grades;                                        // 0x0058 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class FString                                      FlashLabelName;                                // 0x0068 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	int32_t                                            IconX;                                         // 0x0078 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            IconY;                                         // 0x007C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FName                                       StatId;                                        // 0x0080 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ManufacturerDefinition");
		}

		return uClassPointer;
	};

	class FString GetManufacturerGradeDisplayName(int32_t GradeIndex);
};

// Class Engine.PawnAllegiance
// 0x0038 (0x0058 - 0x0090)
class UPawnAllegiance : public UGBXDefinition
{
public:
	EOpinion                                           DefaultOpinion;                                // 0x0058 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EOpinion                                           SelfOpinion;                                   // 0x0059 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EOpinion                                           ForcedOtherOpinion;                            // 0x005A (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<struct FOpinionData>                  MyOpinions;                                    // 0x0060 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FOpinionData>                  OtherOpinions;                                 // 0x0070 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	uint32_t                                           bForceAllOtherOpinions : 1;                    // 0x0080 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	struct FName                                       AllegianceKilledStat;                          // 0x0084 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PawnAllegiance");
		}

		return uClassPointer;
	};

	static bool IsAllegianceChild(class UITargetable* Parent, class UITargetable* TestChild);
	static void SetParent(class UITargetable* Parent, class UITargetable* Child);
	static void RemoveChildren(class UITargetable* Parent);
	static void RemoveParent(class UITargetable* Child);
	bool ConsidersObjectNeutral(class UObject* TestActor);
	bool ConsidersObjectFriendly(class UObject* TestActor);
	bool ConsidersObjectEnemy(class UObject* TestActor);
	bool ConsidersNeutral(class UPawnAllegiance* TestAllegiance);
	bool ConsidersFriendly(class UPawnAllegiance* TestAllegiance);
	bool ConsidersEnemy(class UPawnAllegiance* TestAllegiance);
	EOpinion GetObjectOpinionW(class UObject* Other);
	EOpinion GetOpinion(class UPawnAllegiance* Other);
};

// Class Engine.PawnInteractionDefinition
// 0x0040 (0x0058 - 0x0098)
class UPawnInteractionDefinition : public UGBXDefinition
{
public:
	uint32_t                                           bSupportsUseEvents : 1;                        // 0x0058 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bSupportsUseEventsWhenDead : 1;                // 0x0058 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           bAimToInteract : 1;                            // 0x0058 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           bUseInteractDistance : 1;                      // 0x0058 (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           bSupportsTouchEvents : 1;                      // 0x0058 (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	uint32_t                                           bSupportsTouchEventsWhenDead : 1;              // 0x0058 (0x0004) [0x0000000000000003] [0x00000020] (CPF_Edit | CPF_Const)
	uint32_t                                           bTouchAIPawns : 1;                             // 0x0058 (0x0004) [0x0000000000000003] [0x00000040] (CPF_Edit | CPF_Const)
	uint32_t                                           bTouchPlayerPawns : 1;                         // 0x0058 (0x0004) [0x0000000000000003] [0x00000080] (CPF_Edit | CPF_Const)
	uint32_t                                           bTouchVehicles : 1;                            // 0x0058 (0x0004) [0x0000000000000003] [0x00000100] (CPF_Edit | CPF_Const)
	uint32_t                                           bTouchProjectiles : 1;                         // 0x0058 (0x0004) [0x0000000000000003] [0x00000200] (CPF_Edit | CPF_Const)
	float                                              InteractDistance;                              // 0x005C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              TouchRadius;                                   // 0x0060 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              TouchHeight;                                   // 0x0064 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<class UBehaviorBase*>                 OnTouch;                                       // 0x0068 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UBehaviorBase*>                 OnUnTouch;                                     // 0x0078 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UBehaviorBase*>                 OnUse;                                         // 0x0088 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PawnInteractionDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.PhysicsResponseDefinition
// 0x00A0 (0x0058 - 0x00F8)
class UPhysicsResponseDefinition : public UGBXDefinition
{
public:
	struct FAttributeInitializationData                ForceData;                                     // 0x0058 (0x0020) [0x0000000000000001] (CPF_Edit)    
	float                                              Force;                                         // 0x0078 (0x0004) [0x0000000020000001] (CPF_Edit | CPF_Deprecated)
	uint32_t                                           bForceIsImpulse : 1;                           // 0x007C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAlwaysAffectsPawns : 1;                       // 0x007C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bVehicleForceIsImpulse : 1;                    // 0x007C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bKillForceIsImpulse : 1;                       // 0x007C (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bPropagateForceToLimbs : 1;                    // 0x007C (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bApplyUpwardForce : 1;                         // 0x007C (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	float                                              VehicleForceScale;                             // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ForceOnKillScale;                              // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FAttributeInitializationData                FleshForceModifier;                            // 0x0088 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FAttributeInitializationData                ArmorForceModifier;                            // 0x00A8 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FAttributeInitializationData                ShieldForceModifier;                           // 0x00C8 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              UpwardForceScale;                              // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              InstigatorSelfForceScale;                      // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	EHitDirectionType                                  DirectionType;                                 // 0x00F0 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PhysicsResponseDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.ResourceDefinition
// 0x0030 (0x0058 - 0x0088)
class UResourceDefinition : public UGBXDefinition
{
public:
	class FString                                      ResourceName;                                  // 0x0058 (0x0010) [0x0000000000408003] (CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	uint32_t                                           bIntegerOnlyUpdates : 1;                       // 0x0068 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bSerializeInSaveGame : 1;                      // 0x0068 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	class UClass*                                      DefaultResourcePoolClass;                      // 0x0070 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UResourcePoolDefinition*                     DefaultResourcePoolDefinition;                 // 0x0078 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UAttributeContextResolver*                   ResourceContextResolver;                       // 0x0080 (0x0008) [0x0000000004000003] (CPF_Edit | CPF_Const | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ResourceDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.ResourcePoolDefinition
// 0x00F8 (0x0058 - 0x0150)
class UResourcePoolDefinition : public UGBXDefinition
{
public:
	class UResourceDefinition*                         Resource;                                      // 0x0058 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ENetRelevantFor                                    NetRelevancy;                                  // 0x0060 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UResourceDefinition*                         RegenerationResource;                          // 0x0068 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BaseMinValue;                                  // 0x0070 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FAttributeInitializationData                BaseMaxValue;                                  // 0x0078 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              StartingValue;                                 // 0x0098 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           StartWithMinValue : 1;                         // 0x009C (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           StartWithMaxValue : 1;                         // 0x009C (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           bUpdateCurrentValueOnExtremaChange : 1;        // 0x009C (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           bPulseBasedOnRegenRate : 1;                    // 0x009C (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           bPulseWhenLow : 1;                             // 0x009C (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	float                                              BaseConsumptionRate;                           // 0x00A0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BaseActiveRegenerationRate;                    // 0x00A4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BasePassiveRegenerationRate;                   // 0x00A8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BaseOnIdleRegenerationRate;                    // 0x00AC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BaseOnIdleRegenerationDelay;                   // 0x00B0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              RecentImpulseTimer;                            // 0x00B4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              PercBarPulseSpeed;                             // 0x00B8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              PercPulseResourceLow;                          // 0x00BC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<class UBehaviorBase*>                 OnResourceDepleted;                            // 0x00C0 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UBehaviorBase*>                 OnResourceNotDepleted;                         // 0x00D0 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UBehaviorBase*>                 OnResourceRegenerated;                         // 0x00E0 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UBehaviorBase*>                 OnResourceNotRegenerated;                      // 0x00F0 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UBehaviorBase*>                 OnResourceNowRegenerating;                     // 0x0100 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UBehaviorBase*>                 OnResourceNowNotRegenerating;                  // 0x0110 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)
	class UAttributeDefinition*                        UpgradeLevelAttribute;                         // 0x0120 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            TotalUpgradeCount;                             // 0x0128 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FAttributeInitializationData                MaxValueUpgrade;                               // 0x0130 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ResourcePoolDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.WillowInventoryDefinition
// 0x01E8 (0x0058 - 0x0240)
class UWillowInventoryDefinition : public UGBXDefinition
{
public:
	class UClass*                                      InventoryClass;                                // 0x0058 (0x0008) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bAutomaticallyPickup : 1;                      // 0x0060 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bPickupInBulk : 1;                             // 0x0060 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           bDisallowAIFromGrabbingPickup : 1;             // 0x0060 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           bDuplicatePickupJustAddsQuantity : 1;          // 0x0060 (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           bSuppressPickupCard : 1;                       // 0x0060 (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	uint32_t                                           bTorque : 1;                                   // 0x0060 (0x0004) [0x0000000000000002] [0x00000020] (CPF_Const)
	uint32_t                                           bNeverDisplayPickupMessage : 1;                // 0x0060 (0x0004) [0x0000000000000003] [0x00000040] (CPF_Edit | CPF_Const)
	uint32_t                                           bShopsHaveInfiniteQuantity : 1;                // 0x0060 (0x0004) [0x0000000000000003] [0x00000080] (CPF_Edit | CPF_Const)
	uint32_t                                           bCanCompare : 1;                               // 0x0060 (0x0004) [0x0000000000000003] [0x00000100] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsesPlayerLevelRequirement : 1;               // 0x0060 (0x0004) [0x0000000000000003] [0x00000200] (CPF_Edit | CPF_Const)
	uint32_t                                           bUIMeshRotationNeedsTransformFixup : 1;        // 0x0060 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bIsConsumable : 1;                             // 0x0060 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bAllowInventoryDefToModifyPartWeight : 1;      // 0x0060 (0x0004) [0x0000000000000002] [0x00001000] (CPF_Const)
	uint32_t                                           bCustomCreation : 1;                           // 0x0060 (0x0004) [0x0000000000000000] [0x00002000] 
	EPlayerDroppability                                PlayerDroppability;                            // 0x0064 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ECurrencyType                                      FormOfCurrency;                                // 0x0065 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EExpressionEvaluationMode                          OnUseConstraintsMode;                          // 0x0066 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EAttributeSlotEffectMode                           AttributeSlotEffectMode;                       // 0x0067 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              PickupLifeSpan;                                // 0x0068 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              PickupFlagScale;                               // 0x006C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UTexture2D*                                  PickupFlagIcon;                                // 0x0070 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     PickupFlagOffset;                              // 0x0078 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     Torque;                                        // 0x0084 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ThirdPersonMeshScale;                          // 0x0090 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<struct FConditionalSoundData>         PickupSounds;                                  // 0x0098 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FConditionalSoundData>         PickupAndEquipSounds;                          // 0x00A8 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class UClass*                                      MaterialClass;                                 // 0x00B8 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class UPhysicsAsset*                               PhysicsAsset;                                  // 0x00C0 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class FString                                      PickupMessage;                                 // 0x00C8 (0x0010) [0x0000000000408003] (CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      UseFailureLevelMessage;                        // 0x00D8 (0x0010) [0x0000000000408003] (CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      UseFailureConstraintsMessage;                  // 0x00E8 (0x0010) [0x0000000000408003] (CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      NoManufacturerName;                            // 0x00F8 (0x0010) [0x0000000000408003] (CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	struct FAttributeInitializationData                BaseRarity;                                    // 0x0108 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FAttributeInitializationData                MonetaryValue;                                 // 0x0128 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BaseMonetaryValueModifier;                     // 0x0148 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FAttributeInitializationData                PlayerUseLevelBonus;                           // 0x0150 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<struct FAttributeExpressionData>      OnUseConstraints;                              // 0x0170 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FUIStatData>                   UIStatList;                                    // 0x0180 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	struct FRotator                                    UIMeshRotation;                                // 0x0190 (0x000C) [0x0000000000000001] (CPF_Edit)    
	class UInventoryCardPresentationDefinition*        Presentation;                                  // 0x01A0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UGearboxCalloutDefinition*                   CalloutDefinition;                             // 0x01A8 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FName                                       PickedUpStatID;                                // 0x01B0 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FName                                       PurchasedStatID;                               // 0x01B8 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              FocusRadius;                                   // 0x01C0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     FocusOffset;                                   // 0x01C4 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FAttributeInitializationData                AttributeSlotEffectSkillDuration;              // 0x01D0 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FAttributeInitializationData                AttributeSlotBaseGrade;                        // 0x01F0 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            AttributeSlotMaxActivated;                     // 0x0210 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<struct FAttributeSlotEffectData>      AttributeSlotEffects;                          // 0x0218 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FAttributeSlotUpgradeData>     AttributeSlotUpgrades;                         // 0x0228 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	struct FColor                                      LootBeamColorOverride;                         // 0x0238 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WillowInventoryDefinition");
		}

		return uClassPointer;
	};

	bool CanPickupInBulk();
	bool ShouldPlayerAutomaticallyPickup(class APlayerController* PC);
	int32_t GetAttributeSlotMaxActivated();
	class FString GetLocalizedInventoryName();
	int32_t GetInventorySpaceRequirement();
	int32_t GetBaseRarityLevel();
};

// Class Engine.WillowInventoryPartDefinition
// 0x0088 (0x0058 - 0x00E0)
class UWillowInventoryPartDefinition : public UGBXDefinition
{
public:
	class UMaterialInstance*                           Material;                                      // 0x0058 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bIsGestaltMode : 1;                            // 0x0060 (0x0004) [0x0000000000020003] [0x00000001] (CPF_Edit | CPF_Const | CPF_EditConst)
	struct FName                                       GestaltModeSkeletalMeshName;                   // 0x0064 (0x0008) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	class USkeletalMesh*                               NongestaltSkeletalMesh;                        // 0x0070 (0x0008) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	struct FName                                       AdditionalGestaltModeSkeletalMeshNames[0x2];   // 0x0078 (0x0010) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	class TArray<struct FAttributeSlotEffectData>      AttributeSlotEffects;                          // 0x0088 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FAttributeSlotUpgradeData>     AttributeSlotUpgrades;                         // 0x0098 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class UAttributeDefinition*                        MonetaryValueMod;                              // 0x00A8 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FAttributeInitializationData                Rarity;                                        // 0x00B0 (0x0020) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<struct FFloat4ParameterValue>         MaterialVectorParameterValues;                 // 0x00D0 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WillowInventoryPartDefinition");
		}

		return uClassPointer;
	};

	void ApplyMaterialModifiers(class UMaterialInstance* MatInst);
	class USkeletalMesh* GetSkeletalMesh();
	void AddAdditionalGestaltMeshNames(class TArray<struct FName>& PartMeshNames);
	struct FName GetSkeletalMeshName();
	int32_t GetRarityLevel();
};

// Class Engine.GBXInfluenceInfo
// 0x0050 (0x0058 - 0x00A8)
class UGBXInfluenceInfo : public UObject
{
public:
	float                                              Decay;                                         // 0x0058 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              Momentum;                                      // 0x005C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FName                                       InfoName;                                      // 0x0060 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              UpdateRate;                                    // 0x0068 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              MinValue;                                      // 0x006C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              MaxValue;                                      // 0x0070 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LastUpdateTime;                                // 0x0074 (0x0004) [0x0000000000002000] (CPF_Transient)
	class TArray<float>                                PointInfo;                                     // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FColor                                      HotColor;                                      // 0x0088 (0x0004) [0x0000000000000000]               
	struct FColor                                      ColdColor;                                     // 0x008C (0x0004) [0x0000000000000000]               
	uint32_t                                           bGrabHotSpots : 1;                             // 0x0090 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	float                                              HotSpotThreshold;                              // 0x0094 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<struct FInfluenceHotSpotData>         HotSpots;                                      // 0x0098 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXInfluenceInfo");
		}

		return uClassPointer;
	};

	struct FInfluenceHotSpotData GetHotSpot(int32_t SpotIdx);
	int32_t NumHotSpots();
	void UpdateHotSpots();
	void PropagateRadius(float Radius, struct FVector& BaseLoc, struct FVector& BiasedDirection);
	class AGBXInfluenceMap* GetMap();
	void AddValue(int32_t PointIdx, float AddValue);
	struct FName GetInfoName();
	int32_t GetNumPoints();
	void TryUpdate();
	void Propagate();
	float GetNormalizedValue(int32_t PointIdx);
	float GetValue(int32_t PointIdx);
	void InitPoints(int32_t NumPoints);
	void Prepare();
	void Update();
	void Clear();
};

// Class Engine.GBXPipeline
// 0x0040 (0x0058 - 0x0098)
class UGBXPipeline : public UObject
{
public:
	uint32_t                                           bHasRunLogFilterChecks : 1;                    // 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bPassesAllLogFilterChecks : 1;                 // 0x0058 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bInUse : 1;                                    // 0x0058 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bExecuting : 1;                                // 0x0058 (0x0004) [0x0000000000000000] [0x00000008] 
	class AActor*                                      TargetActor;                                   // 0x0060 (0x0008) [0x0000000000000000]               
	class APawn*                                       TargetPawn;                                    // 0x0068 (0x0008) [0x0000000000000000]               
	class AController*                                 TargetController;                              // 0x0070 (0x0008) [0x0000000000000000]               
	class APawn*                                       InstigatorPawn;                                // 0x0078 (0x0008) [0x0000000000000000]               
	class AController*                                 InstigatorController;                          // 0x0080 (0x0008) [0x0000000000000000]               
	class UClass*                                      DamageSource;                                  // 0x0088 (0x0008) [0x0000000000000000]               
	class UDamageTypeDefinition*                       DamageTypeDef;                                 // 0x0090 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXPipeline");
		}

		return uClassPointer;
	};

};

// Class Engine.CurrencyPipeline
// 0x00E8 (0x0098 - 0x0180)
class UCurrencyPipeline : public UGBXPipeline
{
public:
	struct FCurrencyEventSummary                       CurrencySummary;                               // 0x0098 (0x00E8) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CurrencyPipeline");
		}

		return uClassPointer;
	};

};

// Class Engine.DamagePipeline
// 0x0280 (0x0098 - 0x0318)
class UDamagePipeline : public UGBXPipeline
{
public:
	class UImpactDefinition*                           ImpactDefinition;                              // 0x0098 (0x0008) [0x0000000000000000]               
	class UPhysicsResponseDefinition*                  PhysicsResponse;                               // 0x00A0 (0x0008) [0x0000000000000000]               
	struct FVector                                     HitLocation;                                   // 0x00A8 (0x000C) [0x0000000000000000]               
	struct FVector                                     HitDirection;                                  // 0x00B4 (0x000C) [0x0000000000000000]               
	uint32_t                                           bCanHitFriendly : 1;                           // 0x00C0 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bCanHitInstigator : 1;                         // 0x00C0 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bOvercharged : 1;                              // 0x00C0 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bCanReflect : 1;                               // 0x00C0 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bTakingRadialDamage : 1;                       // 0x00C0 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bTakingRadialImpactDamage : 1;                 // 0x00C0 (0x0004) [0x0000000000000000] [0x00000020] 
	class UObject*                                     DirectHitObject;                               // 0x00C8 (0x0008) [0x0000000000000000]               
	int32_t                                            PenetrationCount;                              // 0x00D0 (0x0004) [0x0000000000000000]               
	EBulletFromClip                                    BulletFromClipType;                            // 0x00D4 (0x0001) [0x0000000000000000]               
	int32_t                                            DamageTags;                                    // 0x00D8 (0x0004) [0x0000000000000000]               
	struct FDamageEventSummary                         DamageSummary;                                 // 0x00E0 (0x0220) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              BarrelSourceTime;                              // 0x0300 (0x0004) [0x0000000000000000]               
	float                                              PlantSourceTime;                               // 0x0304 (0x0004) [0x0000000000000000]               
	struct FVector                                     EffectsMomentum;                               // 0x0308 (0x000C) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DamagePipeline");
		}

		return uClassPointer;
	};

};

// Class Engine.ExperiencePipeline
// 0x00F0 (0x0098 - 0x0188)
class UExperiencePipeline : public UGBXPipeline
{
public:
	struct FExperienceEventSummary                     ExperienceSummary;                             // 0x0098 (0x00F0) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ExperiencePipeline");
		}

		return uClassPointer;
	};

};

// Class Engine.GearboxCollisionGrid
// 0x0070 (0x0058 - 0x00C8)
class UGearboxCollisionGrid : public UObject
{
public:
	struct FVector2D                                   DesiredNodeSize;                               // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   Origin;                                        // 0x0060 (0x0008) [0x0000000000000000]               
	struct FVector2D                                   NodeSize;                                      // 0x0068 (0x0008) [0x0000000000000000]               
	struct FIntPoint                                   NumNodes;                                      // 0x0070 (0x0008) [0x0000000000000000]               
	class TArray<struct FPointer>                      Nodes;                                         // 0x0078 (0x0010) [0x0000000000003000] (CPF_Native | CPF_Transient)
	class TArray<struct FCollisionGridVolume>          CollisionGridVolumes;                          // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FCollisionVolumeList>          CollisionVolumeLists;                          // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<int32_t>                              CollisionVolumeListLookup;                     // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FGuid                                       VolumeBuildGuid;                               // 0x00B8 (0x0010) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GearboxCollisionGrid");
		}

		return uClassPointer;
	};

	void Initialize();
};

// Class Engine.GearboxEngineGlobals
// 0x0090 (0x0058 - 0x00E8)
class UGearboxEngineGlobals : public UObject
{
public:
	class UTargetableList*                             TheTargetableList;                             // 0x0058 (0x0008) [0x0000000000002000] (CPF_Transient)
	class UTexture2D*                                  AnimDebugTrack;                                // 0x0060 (0x0008) [0x0000000000000000]               
	class UTexture2D*                                  AnimDebugCarat;                                // 0x0068 (0x0008) [0x0000000000000000]               
	class UGearboxEngineGlobals*                       SingletonInstance;                             // 0x0070 (0x0008) [0x0000000000002000] (CPF_Transient)
	class UPersistentGameDataManager*                  ThePersistentDataManager;                      // 0x0078 (0x0008) [0x0000000000002000] (CPF_Transient)
	class TArray<struct FPlayerOwnedComponent>         PlayerOwnedComponents;                         // 0x0080 (0x0010) [0x0000000000482000] (CPF_Transient | CPF_Component | CPF_NeedCtorLink)
	struct FVector                                     DynamicShadowDirection;                        // 0x0090 (0x000C) [0x0000000000002000] (CPF_Transient)
	float                                              WholeSceneDynamicShadowRadius;                 // 0x009C (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            InfluenceInfoVersion;                          // 0x00A0 (0x0004) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	class TArray<class UGBXInfluenceInfo*>             InfluenceInfoTemplate;                         // 0x00A8 (0x0010) [0x0000000004420003] (CPF_Edit | CPF_Const | CPF_EditConst | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<struct FDamageEventSummary>           DamagePipelineHistory;                         // 0x00B8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FCurrencyEventSummary>         CurrencyPipelineHistory;                       // 0x00C8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FExperienceEventSummary>       ExperiencePipelineHistory;                     // 0x00D8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GearboxEngineGlobals");
		}

		return uClassPointer;
	};

	class UDominantDirectionalLightComponent* GetTimeOfDayDominantDirectionalLightComponent();
	void ReleasePipelineObject(class UGBXPipeline* Pipeline);
	class UExperiencePipeline* GetExperiencePipelineObject();
	class UCurrencyPipeline* GetCurrencyPipelineObject();
	class UDamagePipeline* GetDamagePipelineObject();
	bool IsPlayerOwnedComponentOwnedBy(class UActorComponent* Component, class AActor* PotentialPlayerOwner);
	class AActor* GetComponentPlayerOwner(class UActorComponent* Component);
	void RemovePlayerOwnedComponentsByOwner(class AActor* PlayerOwner);
	void RemovePlayerOwnedComponentsByComponent(class UActorComponent* Component);
	void RemovePlayerOwnedComponent(class UActorComponent* Component, class AActor* PlayerOwner);
	void AddPlayerOwnedComponent(class UActorComponent* Component, class AActor* PlayerOwner);
	void SetLoadingMovieMustPlayToEnd();
	bool ShouldPlayLoadingMovieToEnd();
	bool FreeTexture2D(class UTexture2D* Texture);
	class UTexture2D* GetTexture2D();
	void RegDynamicTextureStreaming(class AActor* A, bool optionalBRegister);
	class UTargetableList* GetTargetableList();
	static class UGearboxEngineGlobals* GetGearboxEngineGlobals();
	void NotifyActorDied(class AActor* TheActor, bool bKeepBody);
};

// Class Engine.GearboxGlobalData
// 0x0000 (0x0058 - 0x0058)
class UGearboxGlobalData : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GearboxGlobalData");
		}

		return uClassPointer;
	};

};

// Class Engine.GestaltPartMatrices
// 0x0028 (0x0058 - 0x0080)
class UGestaltPartMatrices : public UObject
{
public:
	class TArray<struct FGestaltAccessoryMeshEntry>    GestaltAccessoryMeshList;                      // 0x0058 (0x0010) [0x0000000000420001] (CPF_Edit | CPF_EditConst | CPF_NeedCtorLink)
	class TArray<struct FMatrix>                       Matrices;                                      // 0x0068 (0x0010) [0x0000000000420001] (CPF_Edit | CPF_EditConst | CPF_NeedCtorLink)
	struct FName                                       ArchetypeName;                                 // 0x0078 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GestaltPartMatrices");
		}

		return uClassPointer;
	};

};

// Class Engine.GuidCache
// 0x0060 (0x0058 - 0x00B8)
class UGuidCache : public UObject
{
public:
	uint8_t                                           UnknownData00[0x60];                           // 0x0058 (0x0060) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GuidCache");
		}

		return uClassPointer;
	};

};

// Class Engine.HeadlessClientCommandlet
// 0x0000 (0x00B0 - 0x00B0)
class UHeadlessClientCommandlet : public UCommandlet
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.HeadlessClientCommandlet");
		}

		return uClassPointer;
	};

};

// Class Engine.IAkComponentPositionProvider
// 0x0000 (0x0058 - 0x0058)
class UIAkComponentPositionProvider : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IAkComponentPositionProvider");
		}

		return uClassPointer;
	};

};

// Class Engine.IAnimBehavior
// 0x0000 (0x0058 - 0x0058)
class UIAnimBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IAnimBehavior");
		}

		return uClassPointer;
	};

	void SetAnimTreeTemplate(class UAnimTree* NewTemplate);
	void Behavior_ChangeBoneVisibility(const struct FName& InBoneName, bool bVisible);
	void Behavior_ToggleBoneVisibility(const struct FName& InBoneName);
	void Behavior_InstanceVertexWeight(const struct FName& InBoneName);
	void SetForceDiscardRootMotion(bool bDiscardRootMotion);
	class UAnimNode* FindAnimNode(const struct FName& InNodeName);
	class USkelControlBase* FindSkelControl(const struct FName& InControlName);
	void PlayAnim(const struct FName& AnimName, float optionalDuration, bool optionalBLoop, bool optionalBRestartIfAlreadyPlaying, float optionalStartTime, bool optionalBPlayBackwards);
	void Behavior_SetMorphNodeWeight(const struct FName& NodeName, float NewWeight, float optionalWeightBlendTime);
	bool GetAnimTreeNodes(const struct FName& NodeName, class UClass* optionalNodeClass, class TArray<class UAnimNode*>& AnimNodeList);
	void Behavior_SetSkelControlStrength(const struct FName& SkelControlName, bool bActive);
};

// Class Engine.IAppearanceBehavior
// 0x0000 (0x0058 - 0x0058)
class UIAppearanceBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IAppearanceBehavior");
		}

		return uClassPointer;
	};

	void Behavior_ChangeVisibility(bool bVisible);
	void Behavior_ToggleVisibility();
};

// Class Engine.IAssociated
// 0x0000 (0x0058 - 0x0058)
class UIAssociated : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IAssociated");
		}

		return uClassPointer;
	};

};

// Class Engine.IAttributeSlotEffectProvider
// 0x0000 (0x0058 - 0x0058)
class UIAttributeSlotEffectProvider : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IAttributeSlotEffectProvider");
		}

		return uClassPointer;
	};

	float GetAttributeSlotModifierValue(const struct FName& SlotName);
	int32_t GetAttributeSlotGrade(const struct FName& SlotName);
};

// Class Engine.IAudioParametersProvider
// 0x0000 (0x0058 - 0x0058)
class UIAudioParametersProvider : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IAudioParametersProvider");
		}

		return uClassPointer;
	};

};

// Class Engine.IBalancedActor
// 0x0000 (0x0058 - 0x0058)
class UIBalancedActor : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IBalancedActor");
		}

		return uClassPointer;
	};

	struct FName GetBalancedActorTypeIdentifier();
	void SetExpLevel(int32_t NewExpLevel);
	void SetAwesomeLevel(int32_t NewAwesomeLevel);
	void SetGameStage(int32_t NewGameStage);
	int32_t GetExpLevel();
	int32_t GetAwesomeLevel();
	int32_t GetGameStage();
};

// Class Engine.IBasicBehavior
// 0x0000 (0x0058 - 0x0058)
class UIBasicBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IBasicBehavior");
		}

		return uClassPointer;
	};

	float EvaluateAttributeInitialization(const struct FAttributeInitializationData& InitData);
	class UAnimNode* FindAnimNode(const struct FName& NodeName);
	void SetRotationRate(const struct FRotator& NewRotationRate);
	float GetCollisionRadius();
};

// Class Engine.IBodyCompositionInstance
// 0x0000 (0x0058 - 0x0058)
class UIBodyCompositionInstance : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IBodyCompositionInstance");
		}

		return uClassPointer;
	};

};

// Class Engine.IChangeBehaviorSetStateBehavior
// 0x0000 (0x0058 - 0x0058)
class UIChangeBehaviorSetStateBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IChangeBehaviorSetStateBehavior");
		}

		return uClassPointer;
	};

	void Behavior_ChangeBehaviorSet(const struct FName& BehaviorSetName, EChangeStatus ChangeStatus);
};

// Class Engine.IChangeCollisionBehavior
// 0x0000 (0x0058 - 0x0058)
class UIChangeCollisionBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IChangeCollisionBehavior");
		}

		return uClassPointer;
	};

	void Behavior_ChangeCollisionSize(float NewCollisionRadius, float NewCollisionHeight);
	void Behavior_ChangeCollision(uint8_t NewCollisionType);
};

// Class Engine.IConsoleCommandBehavior
// 0x0000 (0x0058 - 0x0058)
class UIConsoleCommandBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IConsoleCommandBehavior");
		}

		return uClassPointer;
	};

	void Behavior_ClientConsoleCommand(const class FString& Command);
	void Behavior_ConsoleCommand(const class FString& Command);
};

// Class Engine.ICounterBehavior
// 0x0000 (0x0058 - 0x0058)
class UICounterBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ICounterBehavior");
		}

		return uClassPointer;
	};

	bool SetCounterState(EBehaviorCounterID CounterId, const struct FBehaviorCounterState& CounterState);
	bool GetCounterState(EBehaviorCounterID CounterId, struct FBehaviorCounterState& CounterState);
	void OnCounterEvent(EBehaviorCounterEvent EventType, const struct FBehaviorParameters& optionalEventData);
};

// Class Engine.IDamageBehavior
// 0x0000 (0x0058 - 0x0058)
class UIDamageBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IDamageBehavior");
		}

		return uClassPointer;
	};

	void Behavior_CauseRadiusDamage(float Radius, float DamageAmount, bool bFullDamage, float Momentum, class UClass* DamageType, class UDamagePipeline* Pipeline, const struct FVector& optionalOffset, class UIDamageCauser* optionalDamageCauser, bool optionalBSkipTraceTest, EOpinion optionalAllegianceFilter, class TArray<class AActor*>& ActorsHurt);
	void Behavior_CauseDamage(class AActor* Target, float DamageAmount, float Momentum, class UClass* DamageType, class UDamagePipeline* Pipeline, class UIDamageCauser* optionalDamageCauser);
};

// Class Engine.IDamageCauser
// 0x0000 (0x0058 - 0x0058)
class UIDamageCauser : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IDamageCauser");
		}

		return uClassPointer;
	};

	void DamageResult_KilledNeutral(class UObject* KilledObject, int32_t DamageTags);
	void DamageResult_KilledFriendly(class UObject* KilledObject, int32_t DamageTags);
	void DamageResult_KilledEnemy(class UObject* KilledObject, int32_t DamageTags);
	void DamageResult_DamagedNeutral(class UObject* DamageTaker, bool bWasCrit, float HealthDamage, float ShieldDamage, int32_t DamageTags);
	void DamageResult_DamagedFriendly(class UObject* DamageTaker, float DamageAmount, int32_t DamageTags);
	void DamageResult_DamagedEnemy(class UObject* DamageTaker, bool bWasCrit, float HealthDamage, float ShieldDamage, int32_t DamageTags);
	class AController* GetControllerResponsibleForDamage();
	class AActor* GetInstigator();
	float GetInstigatorSelfDamageScale();
	float GetFireIntervalChanceModifier();
};

// Class Engine.IDestroyBehavior
// 0x0000 (0x0058 - 0x0058)
class UIDestroyBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IDestroyBehavior");
		}

		return uClassPointer;
	};

	void Behavior_Destroy();
};

// Class Engine.IFaceFXActor
// 0x0000 (0x0058 - 0x0058)
class UIFaceFXActor : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IFaceFXActor");
		}

		return uClassPointer;
	};

	class UFaceFXAsset* eventGetFaceFXAsset();
	void eventSetAudioCueOpenedByFaceFX(bool Opened);
};

// Class Engine.IFoleySystemBehavior
// 0x0000 (0x0058 - 0x0058)
class UIFoleySystemBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IFoleySystemBehavior");
		}

		return uClassPointer;
	};

};

// Class Engine.IFootstepPreviewProvider
// 0x0000 (0x0058 - 0x0058)
class UIFootstepPreviewProvider : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IFootstepPreviewProvider");
		}

		return uClassPointer;
	};

};

// Class Engine.IGBXNavMeshBuildEvents
// 0x0000 (0x0058 - 0x0058)
class UIGBXNavMeshBuildEvents : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IGBXNavMeshBuildEvents");
		}

		return uClassPointer;
	};

};

// Class Engine.IGBXNavMeshObstacle
// 0x0000 (0x0058 - 0x0058)
class UIGBXNavMeshObstacle : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IGBXNavMeshObstacle");
		}

		return uClassPointer;
	};

};

// Class Engine.IGBXNavMeshSeed
// 0x0000 (0x0058 - 0x0058)
class UIGBXNavMeshSeed : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IGBXNavMeshSeed");
		}

		return uClassPointer;
	};

};

// Class Engine.IGBXNavMeshSpecialMove
// 0x0000 (0x0058 - 0x0058)
class UIGBXNavMeshSpecialMove : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IGBXNavMeshSpecialMove");
		}

		return uClassPointer;
	};

};

// Class Engine.IGBXStaticReplicatedActor
// 0x0000 (0x0058 - 0x0058)
class UIGBXStaticReplicatedActor : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IGBXStaticReplicatedActor");
		}

		return uClassPointer;
	};

};

// Class Engine.IGearboxCollisionGridVolume
// 0x0000 (0x0058 - 0x0058)
class UIGearboxCollisionGridVolume : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IGearboxCollisionGridVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.IInstanceData
// 0x0000 (0x0058 - 0x0058)
class UIInstanceData : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IInstanceData");
		}

		return uClassPointer;
	};

	bool GetInstanceDataState(struct FInstanceData2& OutInstanceDataState);
	bool eventRemoveInstanceData(const struct FName& DataName);
	bool eventGetInstanceData(const struct FName& DataName, class TArray<struct FInstanceDataItem2>& InstanceData);
	bool eventSetInstanceData(const struct FInstanceDataItem2& InstanceData, bool optionalBAllowDuplicateNames);
};

// Class Engine.IKilledBehavior
// 0x0000 (0x0058 - 0x0058)
class UIKilledBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IKilledBehavior");
		}

		return uClassPointer;
	};

	void Behavior_Killed(class AActor* Killer, class UDamageTypeDefinition* optionalTechFilter, EScriptedKillType optionalDeathType);
};

// Class Engine.IMaterialBehavior
// 0x0000 (0x0058 - 0x0058)
class UIMaterialBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IMaterialBehavior");
		}

		return uClassPointer;
	};

	void Behavior_SetTextureParameterValue(const struct FName& ParameterName, class UTexture* Value);
	void Behavior_SetScalarParameterValue(const struct FName& ParameterName, float Value);
	void Behavior_SetVectorParameterValue(const struct FName& ParameterName, const struct FLinearColor& Value);
	bool Behavior_GetScalarParameterValue(const struct FName& ParameterName, float& OutValue);
	bool Behavior_GetVectorParameterValue(const struct FName& ParameterName, struct FLinearColor& OutValue);
};

// Class Engine.INamedObject
// 0x0000 (0x0058 - 0x0058)
class UINamedObject : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.INamedObject");
		}

		return uClassPointer;
	};

};

// Class Engine.InGameAdManager
// 0x0048 (0x0058 - 0x00A0)
class UInGameAdManager : public UObject
{
public:
	uint32_t                                           bShouldPauseWhileAdOpen : 1;                   // 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 
	class TArray<struct FScriptDelegate>               ClickedBannerDelegates;                        // 0x0060 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FScriptDelegate>               ClosedAdDelegates;                             // 0x0070 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnUserClickedBanner__Delegate;               // 0x0080 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnUserClosedAdvertisement__Delegate;         // 0x0090 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InGameAdManager");
		}

		return uClassPointer;
	};

	void ClearClosedAdDelegate(const struct FScriptDelegate& InDelegate);
	void AddClosedAdDelegate(const struct FScriptDelegate& InDelegate);
	void OnUserClosedAdvertisement();
	void ClearClickedBannerDelegate(const struct FScriptDelegate& InDelegate);
	void AddClickedBannerDelegate(const struct FScriptDelegate& InDelegate);
	void OnUserClickedBanner();
	void SetPauseWhileAdOpen(bool bShouldPause);
	void ForceCloseAd();
	void HideBanner();
	void ShowBanner(bool bShowBottomOfScreen);
	void eventInit();
};

// Class Engine.InstanceDataHelper
// 0x0000 (0x0058 - 0x0058)
class UInstanceDataHelper : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InstanceDataHelper");
		}

		return uClassPointer;
	};

	static bool RemoveInstanceDataState(const struct FName& DataName, struct FInstanceData2& InstanceDataState);
	static bool GetInstanceDataState(const struct FName& DataName, struct FInstanceData2& InstanceDataState, class TArray<struct FInstanceDataItem2>& InstanceData);
	static bool eventSetInstanceDataState(class UObject* ContextObject, bool optionalBAllowDuplicateNames, struct FInstanceData2& InstanceDataState, struct FInstanceDataItem2& InstanceData);
	static class UObject* GetFirstInstanceDataObject(class UObject* ContextObj, const struct FName& DataName, class UObject* DefaultValue);
	static bool GetAllInstanceDataObjects(class UObject* ContextObj, const struct FName& DataName, class TArray<class UObject*>& InstanceDataObjects);
	static void RemoveInstanceDataObject(class UIInstanceData* Owner, class UObject* Value);
};

// Class Engine.Interface_NavigationHandle
// 0x0000 (0x0058 - 0x0058)
class UInterface_NavigationHandle : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Interface_NavigationHandle");
		}

		return uClassPointer;
	};

};

// Class Engine.Interface_NavMeshPathObject
// 0x0000 (0x0058 - 0x0058)
class UInterface_NavMeshPathObject : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Interface_NavMeshPathObject");
		}

		return uClassPointer;
	};

};

// Class Engine.Interface_NavMeshPathSwitch
// 0x0000 (0x0058 - 0x0058)
class UInterface_NavMeshPathSwitch : public UInterface_NavMeshPathObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Interface_NavMeshPathSwitch");
		}

		return uClassPointer;
	};

};

// Class Engine.Interface_NavMeshPathObstacle
// 0x0000 (0x0058 - 0x0058)
class UInterface_NavMeshPathObstacle : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Interface_NavMeshPathObstacle");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpCurveEdSetup
// 0x0018 (0x0058 - 0x0070)
class UInterpCurveEdSetup : public UObject
{
public:
	class TArray<struct FCurveEdTab>                   Tabs;                                          // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            ActiveTab;                                     // 0x0068 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpCurveEdSetup");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpFilter
// 0x0010 (0x0058 - 0x0068)
class UInterpFilter : public UObject
{
public:
	class FString                                      Caption;                                       // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpFilter");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpFilter_Classes
// 0x0000 (0x0068 - 0x0068)
class UInterpFilter_Classes : public UInterpFilter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpFilter_Classes");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpFilter_Custom
// 0x0000 (0x0068 - 0x0068)
class UInterpFilter_Custom : public UInterpFilter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpFilter_Custom");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpGroup
// 0x0040 (0x0058 - 0x0098)
class UInterpGroup : public UObject
{
public:
	struct FPointer                                    VfTable_FInterpEdInputInterface;               // 0x0058 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class TArray<class UInterpTrack*>                  InterpTracks;                                  // 0x0060 (0x0010) [0x0000000000400008] (CPF_ExportObject | CPF_NeedCtorLink)
	struct FName                                       GroupName;                                     // 0x0070 (0x0008) [0x0000000000000000]               
	struct FColor                                      GroupColor;                                    // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<class UAnimSet*>                      GroupAnimSets;                                 // 0x0080 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bCollapsed : 1;                                // 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bVisible : 1;                                  // 0x0090 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	uint32_t                                           bIsFolder : 1;                                 // 0x0090 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bIsParented : 1;                               // 0x0090 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bIsSelected : 1;                               // 0x0090 (0x0004) [0x0000000000002000] [0x00000010] (CPF_Transient)
	uint32_t                                           bRunTracksWhenSkippingToLastFrame : 1;         // 0x0090 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpGroup");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpGroupAI
// 0x0018 (0x0098 - 0x00B0)
class UInterpGroupAI : public UInterpGroup
{
public:
	struct FName                                       StageMarkGroup;                                // 0x0098 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           SnapToRootBoneLocationWhenFinished : 1;        // 0x00A0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bNoEncroachmentCheck : 1;                      // 0x00A0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bDisableWorldCollision : 1;                    // 0x00A0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bRecreatePreviewPawn : 1;                      // 0x00A0 (0x0004) [0x0000000800002000] [0x00000008] (CPF_Transient)
	uint32_t                                           bRefreshStageMarkGroup : 1;                    // 0x00A0 (0x0004) [0x0000000800002000] [0x00000010] (CPF_Transient)
	uint32_t                                           bEnableAIWhenAllAnimsFinished : 1;             // 0x00A0 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bUseStageMarkerForInitialLocation : 1;         // 0x00A0 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bPutInDemiGod : 1;                             // 0x00A0 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	EInterpGroupAlignmentTypes                         Alignment;                                     // 0x00A4 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              AlignmentLerpTime;                             // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpGroupAI");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpGroupDirector
// 0x0008 (0x0098 - 0x00A0)
class UInterpGroupDirector : public UInterpGroup
{
public:
	struct FName                                       AttachedGroupName;                             // 0x0098 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpGroupDirector");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpGroupInst
// 0x0028 (0x0058 - 0x0080)
class UInterpGroupInst : public UObject
{
public:
	class UInterpGroup*                                Group;                                         // 0x0058 (0x0008) [0x0000000000000000]               
	class AActor*                                      GroupActor;                                    // 0x0060 (0x0008) [0x0000000000000000]               
	class TArray<class UInterpTrackInst*>              TrackInst;                                     // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bWasNetworkRefreshed : 1;                      // 0x0078 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bDeleteIfNoGroupActor : 1;                     // 0x0078 (0x0004) [0x0000000000000000] [0x00000002] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpGroupInst");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpGroupInstAI
// 0x0018 (0x0080 - 0x0098)
class UInterpGroupInstAI : public UInterpGroupInst
{
public:
	class UInterpGroupAI*                              AIGroup;                                       // 0x0080 (0x0008) [0x0000000000002000] (CPF_Transient)
	EPhysics                                           SavedPhysics;                                  // 0x0088 (0x0001) [0x0000000000000000]               
	uint32_t                                           bSavedNoEncroachCheck : 1;                     // 0x008C (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bSavedCollideActors : 1;                       // 0x008C (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bSavedBlockActors : 1;                         // 0x008C (0x0004) [0x0000000000000000] [0x00000004] 
	class AActor*                                      StageMarkActor;                                // 0x0090 (0x0008) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpGroupInstAI");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpGroupInstDirector
// 0x0000 (0x0080 - 0x0080)
class UInterpGroupInstDirector : public UInterpGroupInst
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpGroupInstDirector");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrack
// 0x0048 (0x0058 - 0x00A0)
class UInterpTrack : public UObject
{
public:
	struct FPointer                                    VfTable_FInterpEdInputInterface;               // 0x0058 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    CurveEdVTable;                                 // 0x0060 (0x0008) [0x0000000000801000] (CPF_Native | CPF_NoExport)
	class TArray<class UInterpTrack*>                  SubTracks;                                     // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class UClass*                                      TrackInstClass;                                // 0x0078 (0x0008) [0x0000000000000000]               
	ETrackActiveCondition                              ActiveCondition;                               // 0x0080 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ETrackPlayDirection                                TrackPlayDirection;                            // 0x0081 (0x0001) [0x0000000000000001] (CPF_Edit)    
	class FString                                      TrackTitle;                                    // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bOnePerGroup : 1;                              // 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bDirGroupOnly : 1;                             // 0x0098 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bDisableTrack : 1;                             // 0x0098 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bIsAnimControlTrack : 1;                       // 0x0098 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bSubTrackOnly : 1;                             // 0x0098 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bVisible : 1;                                  // 0x0098 (0x0004) [0x0000000000002000] [0x00000020] (CPF_Transient)
	uint32_t                                           bIsSelected : 1;                               // 0x0098 (0x0004) [0x0000000000002000] [0x00000040] (CPF_Transient)
	uint32_t                                           bIsRecording : 1;                              // 0x0098 (0x0004) [0x0000000000002000] [0x00000080] (CPF_Transient)
	uint32_t                                           bIsCollapsed : 1;                              // 0x0098 (0x0004) [0x0000000800000000] [0x00000100] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrack");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackBoolProp
// 0x0018 (0x00A0 - 0x00B8)
class UInterpTrackBoolProp : public UInterpTrack
{
public:
	class TArray<struct FBoolTrackKey>                 BoolTrack;                                     // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FName                                       PropertyName;                                  // 0x00B0 (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackBoolProp");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackComment
// 0x0018 (0x00A0 - 0x00B8)
class UInterpTrackComment : public UInterpTrack
{
public:
	class TArray<struct FCommentTrackKey>              CommentTrack;                                  // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bOutputCommentsToScreen : 1;                   // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackComment");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackDirector
// 0x0018 (0x00A0 - 0x00B8)
class UInterpTrackDirector : public UInterpTrack
{
public:
	class TArray<struct FDirectorTrackCut>             CutTrack;                                      // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bSimulateCameraCutsOnClients : 1;              // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackDirector");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackEvent
// 0x0018 (0x00A0 - 0x00B8)
class UInterpTrackEvent : public UInterpTrack
{
public:
	class TArray<struct FEventTrackKey>                EventTrack;                                    // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bFireEventsWhenForwards : 1;                   // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bFireEventsWhenBackwards : 1;                  // 0x00B0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bFireEventsWhenJumpingForwards : 1;            // 0x00B0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackEvent");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackFaceFX
// 0x0038 (0x00A0 - 0x00D8)
class UInterpTrackFaceFX : public UInterpTrack
{
public:
	class TArray<class UFaceFXAnimSet*>                FaceFXAnimSets;                                // 0x00A0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FFaceFXTrackKey>               FaceFXSeqs;                                    // 0x00B0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class UFaceFXAsset*                                CachedActorFXAsset;                            // 0x00C0 (0x0008) [0x0000000000002000] (CPF_Transient)
	class TArray<struct FFaceFXSoundCueKey>            FaceFXSoundCueKeys;                            // 0x00C8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackFaceFX");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackFloatBase
// 0x0020 (0x00A0 - 0x00C0)
class UInterpTrackFloatBase : public UInterpTrack
{
public:
	struct FInterpCurveFloat                           FloatTrack;                                    // 0x00A0 (0x0018) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              CurveTension;                                  // 0x00B8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackFloatBase");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackAnimControl
// 0x0030 (0x00C0 - 0x00F0)
class UInterpTrackAnimControl : public UInterpTrackFloatBase
{
public:
	class TArray<class UAnimSet*>                      AnimSets;                                      // 0x00C0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FName                                       SlotName;                                      // 0x00D0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FAnimControlTrackKey>          AnimSeqs;                                      // 0x00D8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bEnableRootMotion : 1;                         // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bSkipAnimNotifiers : 1;                        // 0x00E8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackAnimControl");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackFade
// 0x0008 (0x00C0 - 0x00C8)
class UInterpTrackFade : public UInterpTrackFloatBase
{
public:
	uint32_t                                           bPersistFade : 1;                              // 0x00C0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FColor                                      FadeColor;                                     // 0x00C4 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackFade");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackFloatMaterialParam
// 0x0028 (0x00C0 - 0x00E8)
class UInterpTrackFloatMaterialParam : public UInterpTrackFloatBase
{
public:
	class TArray<struct FMaterialReferenceList>        Materials;                                     // 0x00C0 (0x0010) [0x0000000000480003] (CPF_Edit | CPF_Const | CPF_Component | CPF_NeedCtorLink)
	class UMaterialInterface*                          Material;                                      // 0x00D0 (0x0008) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	struct FName                                       ParamName;                                     // 0x00D8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bNeedsMaterialRefsUpdate : 1;                  // 0x00E0 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackFloatMaterialParam");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackFloatParticleParam
// 0x0008 (0x00C0 - 0x00C8)
class UInterpTrackFloatParticleParam : public UInterpTrackFloatBase
{
public:
	struct FName                                       ParamName;                                     // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackFloatParticleParam");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackFloatProp
// 0x0008 (0x00C0 - 0x00C8)
class UInterpTrackFloatProp : public UInterpTrackFloatBase
{
public:
	struct FName                                       PropertyName;                                  // 0x00C0 (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackFloatProp");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackMorphWeight
// 0x0008 (0x00C0 - 0x00C8)
class UInterpTrackMorphWeight : public UInterpTrackFloatBase
{
public:
	struct FName                                       MorphNodeName;                                 // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackMorphWeight");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackMoveAxis
// 0x0018 (0x00C0 - 0x00D8)
class UInterpTrackMoveAxis : public UInterpTrackFloatBase
{
public:
	EInterpMoveAxis                                    MoveAxis;                                      // 0x00C0 (0x0001) [0x0000000000000000]               
	struct FInterpLookupTrack                          LookupTrack;                                   // 0x00C8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackMoveAxis");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackSkelControlScale
// 0x0008 (0x00C0 - 0x00C8)
class UInterpTrackSkelControlScale : public UInterpTrackFloatBase
{
public:
	struct FName                                       SkelControlName;                               // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackSkelControlScale");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackSkelControlStrength
// 0x0008 (0x00C0 - 0x00C8)
class UInterpTrackSkelControlStrength : public UInterpTrackFloatBase
{
public:
	struct FName                                       SkelControlName;                               // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackSkelControlStrength");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackSlomo
// 0x0000 (0x00C0 - 0x00C0)
class UInterpTrackSlomo : public UInterpTrackFloatBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackSlomo");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackHeadTracking
// 0x0058 (0x00A0 - 0x00F8)
class UInterpTrackHeadTracking : public UInterpTrack
{
public:
	class TArray<struct FHeadTrackingKey>              HeadTrackingTrack;                             // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FName>                         TrackControllerName;                           // 0x00B0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              LookAtActorRadius;                             // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDisableBeyondLimit : 1;                       // 0x00C4 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bLookAtPawns : 1;                              // 0x00C4 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              MaxLookAtTime;                                 // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MinLookAtTime;                                 // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxInterestTime;                               // 0x00D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<class UClass*>                        ActorClassesToLookAt;                          // 0x00D8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FName>                         TargetBoneNames;                               // 0x00E8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackHeadTracking");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackLinearColorBase
// 0x0020 (0x00A0 - 0x00C0)
class UInterpTrackLinearColorBase : public UInterpTrack
{
public:
	struct FInterpCurveLinearColor                     LinearColorTrack;                              // 0x00A0 (0x0018) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              CurveTension;                                  // 0x00B8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackLinearColorBase");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackLinearColorProp
// 0x0008 (0x00C0 - 0x00C8)
class UInterpTrackLinearColorProp : public UInterpTrackLinearColorBase
{
public:
	struct FName                                       PropertyName;                                  // 0x00C0 (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackLinearColorProp");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackMove
// 0x0058 (0x00A0 - 0x00F8)
class UInterpTrackMove : public UInterpTrack
{
public:
	struct FInterpCurveVector                          PosTrack;                                      // 0x00A0 (0x0018) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FInterpCurveVector                          EulerTrack;                                    // 0x00B8 (0x0018) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FInterpLookupTrack                          LookupTrack;                                   // 0x00D0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FName                                       LookAtGroupName;                               // 0x00E0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              LinCurveTension;                               // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AngCurveTension;                               // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUseQuatInterpolation : 1;                     // 0x00F0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bShowArrowAtKeys : 1;                          // 0x00F0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bDisableMovement : 1;                          // 0x00F0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bShowTranslationOnCurveEd : 1;                 // 0x00F0 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bShowRotationOnCurveEd : 1;                    // 0x00F0 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bHide3DTrack : 1;                              // 0x00F0 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	EInterpTrackMoveFrame                              MoveFrame;                                     // 0x00F4 (0x0001) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	EInterpTrackMoveRotMode                            RotMode;                                       // 0x00F5 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackMove");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackParticleReplay
// 0x0010 (0x00A0 - 0x00B0)
class UInterpTrackParticleReplay : public UInterpTrack
{
public:
	class TArray<struct FParticleReplayTrackKey>       TrackKeys;                                     // 0x00A0 (0x0010) [0x0000000004400000] (CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackParticleReplay");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackTeleport
// 0x0010 (0x00A0 - 0x00B0)
class UInterpTrackTeleport : public UInterpTrack
{
public:
	class TArray<struct FTeleportKeyData>              TeleportKeys;                                  // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackTeleport");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackToggle
// 0x0018 (0x00A0 - 0x00B8)
class UInterpTrackToggle : public UInterpTrack
{
public:
	class TArray<struct FToggleTrackKey>               ToggleTrack;                                   // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bActivateSystemEachUpdate : 1;                 // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bActivateWithJustAttachedFlag : 1;             // 0x00B0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bFireEventsWhenForwards : 1;                   // 0x00B0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bFireEventsWhenBackwards : 1;                  // 0x00B0 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bFireEventsWhenJumpingForwards : 1;            // 0x00B0 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackToggle");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackVectorBase
// 0x0020 (0x00A0 - 0x00C0)
class UInterpTrackVectorBase : public UInterpTrack
{
public:
	struct FInterpCurveVector                          VectorTrack;                                   // 0x00A0 (0x0018) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              CurveTension;                                  // 0x00B8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackVectorBase");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackAudioMaster
// 0x0000 (0x00C0 - 0x00C0)
class UInterpTrackAudioMaster : public UInterpTrackVectorBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackAudioMaster");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackColorProp
// 0x0008 (0x00C0 - 0x00C8)
class UInterpTrackColorProp : public UInterpTrackVectorBase
{
public:
	struct FName                                       PropertyName;                                  // 0x00C0 (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackColorProp");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackColorScale
// 0x0000 (0x00C0 - 0x00C0)
class UInterpTrackColorScale : public UInterpTrackVectorBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackColorScale");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackVectorMaterialParam
// 0x0028 (0x00C0 - 0x00E8)
class UInterpTrackVectorMaterialParam : public UInterpTrackVectorBase
{
public:
	class TArray<struct FMaterialReferenceList>        Materials;                                     // 0x00C0 (0x0010) [0x0000000000480003] (CPF_Edit | CPF_Const | CPF_Component | CPF_NeedCtorLink)
	class UMaterialInterface*                          Material;                                      // 0x00D0 (0x0008) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	struct FName                                       ParamName;                                     // 0x00D8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bNeedsMaterialRefsUpdate : 1;                  // 0x00E0 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackVectorMaterialParam");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackVectorProp
// 0x0008 (0x00C0 - 0x00C8)
class UInterpTrackVectorProp : public UInterpTrackVectorBase
{
public:
	struct FName                                       PropertyName;                                  // 0x00C0 (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackVectorProp");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackVisibility
// 0x0018 (0x00A0 - 0x00B8)
class UInterpTrackVisibility : public UInterpTrack
{
public:
	class TArray<struct FVisibilityTrackKey>           VisibilityTrack;                               // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bFireEventsWhenForwards : 1;                   // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bFireEventsWhenBackwards : 1;                  // 0x00B0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bFireEventsWhenJumpingForwards : 1;            // 0x00B0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackVisibility");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInst
// 0x0000 (0x0058 - 0x0058)
class UInterpTrackInst : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInst");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstAnimControl
// 0x0020 (0x0058 - 0x0078)
class UInterpTrackInstAnimControl : public UInterpTrackInst
{
public:
	float                                              LastUpdatePosition;                            // 0x0058 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FVector                                     ResetLocation;                                 // 0x005C (0x000C) [0x0000000000000000]               
	struct FRotator                                    ResetRotation;                                 // 0x0068 (0x000C) [0x0000000000000000]               
	uint32_t                                           bLastAnimFinished : 1;                         // 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstAnimControl");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstAudioMaster
// 0x0000 (0x0058 - 0x0058)
class UInterpTrackInstAudioMaster : public UInterpTrackInst
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstAudioMaster");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstColorScale
// 0x0000 (0x0058 - 0x0058)
class UInterpTrackInstColorScale : public UInterpTrackInst
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstColorScale");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstComment
// 0x0008 (0x0058 - 0x0060)
class UInterpTrackInstComment : public UInterpTrackInst
{
public:
	float                                              LastUpdatePosition;                            // 0x0058 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstComment");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstDirector
// 0x0010 (0x0058 - 0x0068)
class UInterpTrackInstDirector : public UInterpTrackInst
{
public:
	class AActor*                                      InterpViewTarget;                              // 0x0058 (0x0008) [0x0000000000000000]               
	struct FRenderingPerformanceOverrides              OldRenderingOverrides;                         // 0x0060 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstDirector");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstEvent
// 0x0008 (0x0058 - 0x0060)
class UInterpTrackInstEvent : public UInterpTrackInst
{
public:
	float                                              LastUpdatePosition;                            // 0x0058 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstEvent");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstFaceFX
// 0x0008 (0x0058 - 0x0060)
class UInterpTrackInstFaceFX : public UInterpTrackInst
{
public:
	uint32_t                                           bFirstUpdate : 1;                              // 0x0058 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)
	float                                              LastUpdatePosition;                            // 0x005C (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstFaceFX");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstFade
// 0x0000 (0x0058 - 0x0058)
class UInterpTrackInstFade : public UInterpTrackInst
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstFade");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstFloatMaterialParam
// 0x0018 (0x0058 - 0x0070)
class UInterpTrackInstFloatMaterialParam : public UInterpTrackInst
{
public:
	class TArray<struct FFloatMaterialParamMICData>    MICInfos;                                      // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class UInterpTrackFloatMaterialParam*              InstancedTrack;                                // 0x0068 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstFloatMaterialParam");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstFloatParticleParam
// 0x0008 (0x0058 - 0x0060)
class UInterpTrackInstFloatParticleParam : public UInterpTrackInst
{
public:
	float                                              ResetFloat;                                    // 0x0058 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstFloatParticleParam");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstHeadTracking
// 0x0078 (0x0058 - 0x00D0)
class UInterpTrackInstHeadTracking : public UInterpTrackInst
{
public:
	EHeadTrackingAction                                Action;                                        // 0x0058 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData00[0x50];                           // 0x0060 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.InterpTrackInstHeadTracking.CurrentActorMap
	class USkeletalMeshComponent*                      Mesh;                                          // 0x00B0 (0x0008) [0x0000000004082008] (CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	class TArray<class USkelControlLookAt*>            TrackControls;                                 // 0x00B8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	float                                              LastUpdatePosition;                            // 0x00C8 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstHeadTracking");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstMorphWeight
// 0x0000 (0x0058 - 0x0058)
class UInterpTrackInstMorphWeight : public UInterpTrackInst
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstMorphWeight");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstMove
// 0x0068 (0x0058 - 0x00C0)
class UInterpTrackInstMove : public UInterpTrackInst
{
public:
	struct FVector                                     ResetLocation;                                 // 0x0058 (0x000C) [0x0000000000000000]               
	struct FRotator                                    ResetRotation;                                 // 0x0064 (0x000C) [0x0000000000000000]               
	struct FMatrix                                     InitialTM;                                     // 0x0070 (0x0040) [0x0000000000000000]               
	struct FQuat                                       InitialQuat;                                   // 0x00B0 (0x0010) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstMove");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstParticleReplay
// 0x0008 (0x0058 - 0x0060)
class UInterpTrackInstParticleReplay : public UInterpTrackInst
{
public:
	float                                              LastUpdatePosition;                            // 0x0058 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstParticleReplay");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstProperty
// 0x0010 (0x0058 - 0x0068)
class UInterpTrackInstProperty : public UInterpTrackInst
{
public:
	class UFunction*                                   PropertyUpdateCallback;                        // 0x0058 (0x0008) [0x0000000000000000]               
	class UObject*                                     PropertyOuterObjectInst;                       // 0x0060 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstProperty");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstBoolProp
// 0x0010 (0x0068 - 0x0078)
class UInterpTrackInstBoolProp : public UInterpTrackInstProperty
{
public:
	struct FPointer                                    BoolProp;                                      // 0x0068 (0x0008) [0x0000000000000000]               
	int32_t                                            BitMask;                                       // 0x0070 (0x0004) [0x0000000000000000]               
	uint32_t                                           ResetBool : 1;                                 // 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstBoolProp");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstColorProp
// 0x0010 (0x0068 - 0x0078)
class UInterpTrackInstColorProp : public UInterpTrackInstProperty
{
public:
	struct FPointer                                    ColorProp;                                     // 0x0068 (0x0008) [0x0000000000000000]               
	struct FColor                                      ResetColor;                                    // 0x0070 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstColorProp");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstFloatProp
// 0x0010 (0x0068 - 0x0078)
class UInterpTrackInstFloatProp : public UInterpTrackInstProperty
{
public:
	struct FPointer                                    FloatProp;                                     // 0x0068 (0x0008) [0x0000000000000000]               
	float                                              ResetFloat;                                    // 0x0070 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstFloatProp");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstLinearColorProp
// 0x0018 (0x0068 - 0x0080)
class UInterpTrackInstLinearColorProp : public UInterpTrackInstProperty
{
public:
	struct FPointer                                    ColorProp;                                     // 0x0068 (0x0008) [0x0000000000000000]               
	struct FLinearColor                                ResetColor;                                    // 0x0070 (0x0010) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstLinearColorProp");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstVectorProp
// 0x0018 (0x0068 - 0x0080)
class UInterpTrackInstVectorProp : public UInterpTrackInstProperty
{
public:
	struct FPointer                                    VectorProp;                                    // 0x0068 (0x0008) [0x0000000000000000]               
	struct FVector                                     ResetVector;                                   // 0x0070 (0x000C) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstVectorProp");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstSkelControlScale
// 0x0000 (0x0058 - 0x0058)
class UInterpTrackInstSkelControlScale : public UInterpTrackInst
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstSkelControlScale");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstSkelControlStrength
// 0x0008 (0x0058 - 0x0060)
class UInterpTrackInstSkelControlStrength : public UInterpTrackInst
{
public:
	uint32_t                                           bSavedControlledByAnimMetaData : 1;            // 0x0058 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstSkelControlStrength");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstSlomo
// 0x0008 (0x0058 - 0x0060)
class UInterpTrackInstSlomo : public UInterpTrackInst
{
public:
	float                                              OldTimeDilation;                               // 0x0058 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstSlomo");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstTeleport
// 0x0020 (0x0058 - 0x0078)
class UInterpTrackInstTeleport : public UInterpTrackInst
{
public:
	struct FVector                                     ResetLocation;                                 // 0x0058 (0x000C) [0x0000000000000000]               
	struct FRotator                                    ResetRotation;                                 // 0x0064 (0x000C) [0x0000000000000000]               
	float                                              LastUpdatePosition;                            // 0x0070 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstTeleport");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstToggle
// 0x0010 (0x0058 - 0x0068)
class UInterpTrackInstToggle : public UInterpTrackInst
{
public:
	ETrackToggleAction                                 Action;                                        // 0x0058 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              LastUpdatePosition;                            // 0x005C (0x0004) [0x0000000000000000]               
	uint32_t                                           bSavedActiveState : 1;                         // 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstToggle");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstVectorMaterialParam
// 0x0018 (0x0058 - 0x0070)
class UInterpTrackInstVectorMaterialParam : public UInterpTrackInst
{
public:
	class TArray<struct FVectorMaterialParamMICData>   MICInfos;                                      // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class UInterpTrackVectorMaterialParam*             InstancedTrack;                                // 0x0068 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstVectorMaterialParam");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpTrackInstVisibility
// 0x0008 (0x0058 - 0x0060)
class UInterpTrackInstVisibility : public UInterpTrackInst
{
public:
	EVisibilityTrackAction                             Action;                                        // 0x0058 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              LastUpdatePosition;                            // 0x005C (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpTrackInstVisibility");
		}

		return uClassPointer;
	};

};

// Class Engine.IParameterBehavior
// 0x0000 (0x0058 - 0x0058)
class UIParameterBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IParameterBehavior");
		}

		return uClassPointer;
	};

	void Behavior_SetColorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FLinearColor& Value);
	void Behavior_SetFloatParameterValue(int32_t& SectionIndex, struct FName& ParameterName, float& Value);
	void Behavior_SetObjectParameterValue(class UObject* Value, int32_t& SectionIndex, struct FName& ParameterName);
	void Behavior_SetVectorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FVector& Value);
	bool Behavior_GetColorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FLinearColor& OutValue);
	bool Behavior_GetFloatParameterValue(int32_t& SectionIndex, struct FName& ParameterName, float& OutValue);
	bool Behavior_GetObjectParameterValueW(int32_t& SectionIndex, struct FName& ParameterName, class UObject*& OutValue);
	bool Behavior_GetVectorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FVector& OutValue);
};

// Class Engine.IParticleSystemBehavior
// 0x0000 (0x0058 - 0x0058)
class UIParticleSystemBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IParticleSystemBehavior");
		}

		return uClassPointer;
	};

	void Behavior_ChangeParticleSystemActiveState(EChangeStatus ChangeType);
};

// Class Engine.IPhysicsBehavior
// 0x0000 (0x0058 - 0x0058)
class UIPhysicsBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IPhysicsBehavior");
		}

		return uClassPointer;
	};

	struct FVector GetDamageVector();
	class UMeshComponent* GetRigidBodyMesh();
};

// Class Engine.IPickupable
// 0x0000 (0x0058 - 0x0058)
class UIPickupable : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IPickupable");
		}

		return uClassPointer;
	};

};

// Class Engine.IPlayerInputObserver
// 0x0000 (0x0058 - 0x0058)
class UIPlayerInputObserver : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IPlayerInputObserver");
		}

		return uClassPointer;
	};

	void OnUsingGamepadChanged(class UPlayerInput* InPlayerInput);
};

// Class Engine.IResourcePoolProvider
// 0x0000 (0x0058 - 0x0058)
class UIResourcePoolProvider : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IResourcePoolProvider");
		}

		return uClassPointer;
	};

	class AActor* GetResourcePoolProviderActor();
	void SetResourcePoolManager(class AResourcePoolManager* InManager);
	class AResourcePoolManager* GetResourcePoolManager();
	struct FResourcePoolReference GetResourcePoolForResourceDefinition(class UResourceDefinition* Resource, bool optionalBCreatePoolIfOneDoesntExist);
};

// Class Engine.IScaleBehavior
// 0x0000 (0x0058 - 0x0058)
class UIScaleBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IScaleBehavior");
		}

		return uClassPointer;
	};

	void Behavior_ChangeScale3D(const struct FVector& InScale3D);
	void Behavior_ChangeScale(float InScale);
};

// Class Engine.ISoundBehavior
// 0x0000 (0x0058 - 0x0058)
class UISoundBehavior : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ISoundBehavior");
		}

		return uClassPointer;
	};

};

// Class Engine.ISpawnActor
// 0x0000 (0x0058 - 0x0058)
class UISpawnActor : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ISpawnActor");
		}

		return uClassPointer;
	};

	class AActor* GetSpawnOwner();
	class AActor* SpawnForMap(class UClass* SpawnClass, class AActor* optionalSpawnOwner, const struct FName& optionalSpawnTag, const struct FVector& optionalSpawnLocation, const struct FRotator& optionalSpawnRotation, class AActor* optionalActorTemplate, bool optionalBNoCollisionFail);
};

// Class Engine.ISpawningModule
// 0x0000 (0x0058 - 0x0058)
class UISpawningModule : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ISpawningModule");
		}

		return uClassPointer;
	};

	bool IsEnabled();
	int32_t GetMaximumBurstCount();
	float GetEstimatedSpawnRate();
	float GetMaximumSpawnRate();
};

// Class Engine.ISpecialOcclusionProvider
// 0x0000 (0x0058 - 0x0058)
class UISpecialOcclusionProvider : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ISpecialOcclusionProvider");
		}

		return uClassPointer;
	};

};

// Class Engine.ITargetable
// 0x0000 (0x0058 - 0x0058)
class UITargetable : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ITargetable");
		}

		return uClassPointer;
	};

	float GetAudibility();
	float GetVisibility();
	void SetPatsy(class UITargetable* NewPatsy);
	class UITargetable* GetPatsy();
	bool IsBeingHealed();
	void SetBeingHealed(bool bNewBeingHealed);
	bool IsBoss();
	void Behavior_RegisterTargetable(bool bUnregister);
	bool IsTargetableProxy();
	EAutoAimProfile GetAutoAimProfile();
	float GetMagnetismRange();
	struct FVector GetMagnetismOrigin();
	bool IsAutoAimTarget();
	float GetTargetingModifier();
	bool IsValidHomingTarget();
	bool GetTargetableIsHidden();
	bool CanSnapZoom();
	void GetSnapRegion(struct FTargetSnapRegion& SnapRegion);
	struct FVector GetSnapLocation();
	void GetAuxiliaryTargetableLocations(class TArray<struct FVector>& AuxLocations);
	struct FVector GetTargetableLocation();
	void Behavior_SetCanTarget(EChangeStatus ChangeStatus);
	bool IsTargetable(int32_t optionalTargetFlags);
	int32_t ShowSelfAsTarget(bool bControllersOnly);
	EOpinion GetOpinion(class UObject* Other);
	void SetAllegiance(class UPawnAllegiance* NewAllegiance);
	class UPawnAllegiance* GetDefaultAllegiance();
	class UPawnAllegiance* GetObjectAllegianceW();
	bool IsSameAllegiance(class UObject* anObject);
	bool IsNeutral(class UObject* anObject);
	bool IsFriendly(class UObject* anObject);
	bool IsEnemy(class UObject* anObject);
	void SetInfoBarVisibility(bool bVisible);
	bool HideTargetInfoOnHud(class APawn* optionalHUDOwner);
	bool IsChampion();
	bool DoesTargetableTakeDamage();
	bool DisplayParentInfo();
	void GetHealthInfo(struct FHealthInfo& OutHealthInfo);
	void GetExpInfo(int32_t& ExpLevelValue);
	class AActor* GetTargetableActor();
};

// Class Engine.ITeamAffiliated
// 0x0000 (0x0058 - 0x0058)
class UITeamAffiliated : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ITeamAffiliated");
		}

		return uClassPointer;
	};

	void ForceColorRefresh();
	class UGBXDefinition* GetTeamDefinition();
	void SetTeamInfo(class ATeamInfo* InTeamInfo);
	class ATeamInfo* GetTeamInfo();
};

// Class Engine.ITeleportAware
// 0x0000 (0x0058 - 0x0058)
class UITeleportAware : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ITeleportAware");
		}

		return uClassPointer;
	};

};

// Class Engine.IViewTarget
// 0x0000 (0x0058 - 0x0058)
class UIViewTarget : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IViewTarget");
		}

		return uClassPointer;
	};

};

// Class Engine.IWorldBody
// 0x0000 (0x0058 - 0x0058)
class UIWorldBody : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IWorldBody");
		}

		return uClassPointer;
	};

	bool WorldBodyAttachComponent(class UActorComponent* Attachment, const struct FVector& optionalAttachmentRelativeLocation, const struct FRotator& optionalAttachmentRelativeRotation, const struct FName& optionalAttachmentPointName);
	bool WorldBodyAttachActor(class AActor* Attachment, const struct FVector& optionalAttachmentRelativeLocation, const struct FRotator& optionalAttachmentRelativeRotation, const struct FName& optionalAttachmentPointName);
	bool WorldBodyAttachTo(class UIWorldBody* OtherWorldBody, const struct FVector& optionalAttachmentRelativeLocation, const struct FRotator& optionalAttachmentRelativeRotation, const struct FName& optionalAttachmentPointName);
	struct FName GetWorldBodyAttachmentBoneForComponent(class UActorComponent* AttachedComponent);
	bool GetWorldBodyAttachmentLocationAndRotation(const struct FName& AttachmentPointName, struct FVector& OutLocation, struct FRotator& OutRotation);
	bool GetWorldBodyAttachmentRotation(const struct FName& AttachmentPointName, struct FRotator& OutRotation);
	bool GetWorldBodyAttachmentLocation(const struct FName& AttachmentPointName, struct FVector& OutLocation);
	class UIWorldBody* GetWorldBodyFirstPersonAttachmentBase();
	class UIWorldBody* GetWorldBodyAttachmentBase();
	struct FVector GetWorldBodyVelocity();
	struct FRotator GetWorldBodyRotation();
	struct FVector GetWorldBodyLocation();
};

// Class Engine.JsonObject
// 0x00D0 (0x0058 - 0x0128)
class UJsonObject : public UObject
{
public:
	struct FMap_Mirror                                 ValueMap;                                      // 0x0058 (0x0050) [0x0000000000001000] (CPF_Native)  
	struct FMap_Mirror                                 ObjectMap;                                     // 0x00A8 (0x0050) [0x0000000000001000] (CPF_Native)  
	class TArray<class FString>                        ValueArray;                                    // 0x00F8 (0x0010) [0x0000000000001000] (CPF_Native)  
	class TArray<class UJsonObject*>                   ObjectArray;                                   // 0x0108 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<class UJsonObject*>                   ObjectReferencesForGC;                         // 0x0118 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.JsonObject");
		}

		return uClassPointer;
	};

	class UJsonObject* SetBoolValue(const class FString& Key, bool Value);
	class UJsonObject* SetFloatValue(const class FString& Key, float Value);
	class UJsonObject* SetIntValue(const class FString& Key, int32_t Value);
	class UJsonObject* AddArrayStringValue(const class FString& Value);
	class UJsonObject* AddArrayObject(class UJsonObject* Object);
	class UJsonObject* SetStringValue(const class FString& Key, const class FString& Value);
	class UJsonObject* SetObject(const class FString& Key, class UJsonObject* Object);
	bool eventGetBoolValue(const class FString& Key);
	float eventGetFloatValue(const class FString& Key);
	int32_t eventGetIntValue(const class FString& Key);
	class FString GetStringValue(const class FString& Key);
	class FString GetArrayStringValue(int32_t Index);
	class UJsonObject* GetArrayObject(int32_t Index);
	class UJsonObject* GetObjectW(const class FString& Key);
};

// Class Engine.KMeshProps
// 0x0078 (0x0058 - 0x00D0)
class UKMeshProps : public UObject
{
public:
	struct FVector                                     COMNudge;                                      // 0x0058 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FKAggregateGeom                             AggGeom;                                       // 0x0068 (0x0068) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.KMeshProps");
		}

		return uClassPointer;
	};

};

struct FKCachedConvexData {
	char UnknownData[0x10];
};

// Class Engine.RB_BodySetup
// 0x0078 (0x00D0 - 0x0148)
class URB_BodySetup : public UKMeshProps
{
public:
	ESleepFamily                                       SleepFamily;                                   // 0x00D0 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EParentVelocityBlendType                           ParentVelocityBlendType;                       // 0x00D1 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       BoneName;                                      // 0x00D4 (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	uint32_t                                           bFixed : 1;                                    // 0x00DC (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bNoCollision : 1;                              // 0x00DC (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bBlockZeroExtent : 1;                          // 0x00DC (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bBlockNonZeroExtent : 1;                       // 0x00DC (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bEnableContinuousCollisionDetection : 1;       // 0x00DC (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bConsiderForBounds : 1;                        // 0x00DC (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	float                                              PhysicsWeight;                                 // 0x00E0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ParentVelocityBlendWeight;                     // 0x00E4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            PositionIterationCount;                        // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            VelocityIterationCount;                        // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UPhysicalMaterial*                           PhysMaterial;                                  // 0x00F0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              MassScale;                                     // 0x00F8 (0x0004) [0x0000000020000000]  CPF_Deprecated)
	float                                              Mass;                                          // 0x00FC (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FPointer>                      CollisionGeom;                                 // 0x0100 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<struct FVector>                       CollisionGeomScale3D;                          // 0x0110 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<struct FVector>                       PreCachedPhysScale;                            // 0x0120 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	struct FKCachedConvexData                          PreCachedPhysData;                             // 0x0130 (0x0010) [0x0000000000003000] (CPF_Native | CPF_Transient)
	int32_t                                            PreCachedPhysDataVersion;                      // 0x0140 (0x0004) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_BodySetup");
		}

		return uClassPointer;
	};

};

// Class Engine.LensFlare
// 0x0280 (0x0058 - 0x02D8)
class ULensFlare : public UObject
{
public:
	struct FLensFlareElement                           SourceElement;                                 // 0x0058 (0x01C8) [0x0000000004480008] (CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	class UStaticMesh*                                 SourceMesh;                                    // 0x0220 (0x0008) [0x0000000000000000]               
	ESceneDepthPriorityGroup                           SourceDPG;                                     // 0x0228 (0x0001) [0x0000000000000002] (CPF_Const)   
	ESceneDepthPriorityGroup                           ReflectionsDPG;                                // 0x0229 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              OuterCone;                                     // 0x022C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              InnerCone;                                     // 0x0230 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ConeFudgeFactor;                               // 0x0234 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Radius;                                        // 0x0238 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FLensFlareElement>             Reflections;                                   // 0x0240 (0x0010) [0x0000000004480008] (CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	uint32_t                                           bUseTrueConeCalculation : 1;                   // 0x0250 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseFixedRelativeBoundingBox : 1;              // 0x0250 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bRenderDebugLines : 1;                         // 0x0250 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           ThumbnailImageOutOfDate : 1;                   // 0x0250 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bIsSoloing : 1;                                // 0x0250 (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              MinStrength;                                   // 0x0254 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       ScreenPercentageMap;                           // 0x0258 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FBox                                        FixedRelativeBoundingBox;                      // 0x0280 (0x001C) [0x0000000000000001] (CPF_Edit)    
	class UInterpCurveEdSetup*                         CurveEdSetup;                                  // 0x02A0 (0x0008) [0x0000000000000008] (CPF_ExportObject)
	int32_t                                            ReflectionCount;                               // 0x02A8 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FRotator                                    ThumbnailAngle;                                // 0x02AC (0x000C) [0x0000000000000000]               
	float                                              ThumbnailDistance;                             // 0x02B8 (0x0004) [0x0000000000000000]               
	class UTexture2D*                                  ThumbnailImage;                                // 0x02C0 (0x0008) [0x0000000000000000]               
	class TArray<uint8_t>                              PreSoloEnabledSettings;                        // 0x02C8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LensFlare");
		}

		return uClassPointer;
	};

};

// Class Engine.LevelBase
// 0x0078 (0x0058 - 0x00D0)
class ULevelBase : public UObject
{
public:
	uint8_t                                           UnknownData00[0x78];                           // 0x0058 (0x0078) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LevelBase");
		}

		return uClassPointer;
	};

};

// Class Engine.Level
// 0x04E0 (0x00D0 - 0x05B0)
class ULevel : public ULevelBase
{
public:
	uint8_t                                           UnknownData00[0x120];                          // 0x00D0 (0x0120) MISSED OFFSET
	float                                              LightmapTotalSize;                             // 0x01F0 (0x0004) [0x0000000000020002] (CPF_Const | CPF_EditConst)
	float                                              ShadowmapTotalSize;                            // 0x01F4 (0x0004) [0x0000000000020002] (CPF_Const | CPF_EditConst)
	uint8_t                                           UnknownData01[0x3B8];                          // 0x01F8 (0x03B8) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Level");
		}

		return uClassPointer;
	};

};

// Class Engine.PendingLevel
// 0x0040 (0x00D0 - 0x0110)
class UPendingLevel : public ULevelBase
{
public:
	uint8_t                                           UnknownData00[0x40];                           // 0x00D0 (0x0040) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PendingLevel");
		}

		return uClassPointer;
	};

};

// Class Engine.DemoPlayPendingLevel
// 0x0000 (0x0110 - 0x0110)
class UDemoPlayPendingLevel : public UPendingLevel
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DemoPlayPendingLevel");
		}

		return uClassPointer;
	};

};

// Class Engine.NetPendingLevel
// 0x0000 (0x0110 - 0x0110)
class UNetPendingLevel : public UPendingLevel
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NetPendingLevel");
		}

		return uClassPointer;
	};

};

// Class Engine.LevelStreaming
// 0x0070 (0x0058 - 0x00C8)
class ULevelStreaming : public UObject
{
public:
	struct FName                                       PackageName;                                   // 0x0058 (0x0008) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	class ULevel*                                      LoadedLevel;                                   // 0x0060 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FVector                                     Offset;                                        // 0x0068 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     OldOffset;                                     // 0x0074 (0x000C) [0x0000000000000002] (CPF_Const)   
	uint32_t                                           bIsVisible : 1;                                // 0x0080 (0x0004) [0x0000000000002002] [0x00000001] (CPF_Const | CPF_Transient)
	uint32_t                                           bHasLoadRequestPending : 1;                    // 0x0080 (0x0004) [0x0000000000002002] [0x00000002] (CPF_Const | CPF_Transient)
	uint32_t                                           bHasUnloadRequestPending : 1;                  // 0x0080 (0x0004) [0x0000000000002002] [0x00000004] (CPF_Const | CPF_Transient)
	uint32_t                                           bShouldBeVisibleInEditor : 1;                  // 0x0080 (0x0004) [0x0000000000002002] [0x00000008] (CPF_Const | CPF_Transient)
	uint32_t                                           bShouldBeVisibleInEditorOnLoad : 1;            // 0x0080 (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	uint32_t                                           bBoundingBoxVisible : 1;                       // 0x0080 (0x0004) [0x0000000000000002] [0x00000020] (CPF_Const)
	uint32_t                                           bLocked : 1;                                   // 0x0080 (0x0004) [0x0000000000000003] [0x00000040] (CPF_Edit | CPF_Const)
	uint32_t                                           bIsFullyStatic : 1;                            // 0x0080 (0x0004) [0x0000000000000003] [0x00000080] (CPF_Edit | CPF_Const)
	uint32_t                                           bShouldBeLoaded : 1;                           // 0x0080 (0x0004) [0x0000000000002002] [0x00000100] (CPF_Const | CPF_Transient)
	uint32_t                                           bShouldBeVisible : 1;                          // 0x0080 (0x0004) [0x0000000000002002] [0x00000200] (CPF_Const | CPF_Transient)
	uint32_t                                           bShouldBlockOnLoad : 1;                        // 0x0080 (0x0004) [0x0000000000002000] [0x00000400] (CPF_Transient)
	uint32_t                                           bDrawOnLevelStatusMap : 1;                     // 0x0080 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bIsRequestingUnloadAndRemoval : 1;             // 0x0080 (0x0004) [0x0000000000002002] [0x00001000] (CPF_Const | CPF_Transient)
	uint32_t                                           bClientSideOnly : 1;                           // 0x0080 (0x0004) [0x0000000000000000] [0x00002000] 
	struct FColor                                      DrawColor;                                     // 0x0084 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	class TArray<class ALevelStreamingVolume*>         EditorStreamingVolumes;                        // 0x0088 (0x0010) [0x0000000000420003] (CPF_Edit | CPF_Const | CPF_EditConst | CPF_NeedCtorLink)
	float                                              MinTimeBetweenVolumeUnloadRequests;            // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LastVolumeUnloadRequestTime;                   // 0x009C (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class TArray<class FString>                        Keywords;                                      // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class ALevelGridVolume*                            EditorGridVolume;                              // 0x00B0 (0x0008) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	int32_t                                            GridPosition[0x3];                             // 0x00B8 (0x000C) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LevelStreaming");
		}

		return uClassPointer;
	};

};

// Class Engine.LevelStreamingAlwaysLoaded
// 0x0008 (0x00C8 - 0x00D0)
class ULevelStreamingAlwaysLoaded : public ULevelStreaming
{
public:
	uint32_t                                           bIsProceduralBuildingLODLevel : 1;             // 0x00C8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LevelStreamingAlwaysLoaded");
		}

		return uClassPointer;
	};

};

// Class Engine.LevelStreamingDistance
// 0x0010 (0x00C8 - 0x00D8)
class ULevelStreamingDistance : public ULevelStreaming
{
public:
	struct FVector                                     Origin;                                        // 0x00C8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxDistance;                                   // 0x00D4 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LevelStreamingDistance");
		}

		return uClassPointer;
	};

};

// Class Engine.LevelStreamingKismet
// 0x0000 (0x00C8 - 0x00C8)
class ULevelStreamingKismet : public ULevelStreaming
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LevelStreamingKismet");
		}

		return uClassPointer;
	};

};

// Class Engine.LevelStreamingDomino
// 0x0010 (0x00C8 - 0x00D8)
class ULevelStreamingDomino : public ULevelStreamingKismet
{
public:
	class TArray<struct FName>                         TilePossibilities;                             // 0x00C8 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LevelStreamingDomino");
		}

		return uClassPointer;
	};

};

// Class Engine.LevelStreamingPersistent
// 0x0000 (0x00C8 - 0x00C8)
class ULevelStreamingPersistent : public ULevelStreaming
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LevelStreamingPersistent");
		}

		return uClassPointer;
	};

};

// Class Engine.LightFunction
// 0x0018 (0x0058 - 0x0070)
class ULightFunction : public UObject
{
public:
	class UMaterialInterface*                          SourceMaterial;                                // 0x0058 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     Scale;                                         // 0x0060 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              DisabledBrightness;                            // 0x006C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LightFunction");
		}

		return uClassPointer;
	};

};

// Class Engine.LightmappedSurfaceCollection
// 0x0018 (0x0058 - 0x0070)
class ULightmappedSurfaceCollection : public UObject
{
public:
	class UModel*                                      SourceModel;                                   // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class TArray<int32_t>                              Surfaces;                                      // 0x0060 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LightmappedSurfaceCollection");
		}

		return uClassPointer;
	};

};

// Class Engine.LightmassPrimitiveSettingsObject
// 0x0020 (0x0058 - 0x0078)
class ULightmassPrimitiveSettingsObject : public UObject
{
public:
	struct FLightmassPrimitiveSettings                 LightmassSettings;                             // 0x0058 (0x001C) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LightmassPrimitiveSettingsObject");
		}

		return uClassPointer;
	};

};

// Class Engine.Line
// 0x0070 (0x0058 - 0x00C8)
class ULine : public UObject
{
public:
	class ULineData*                                   Parent;                                        // 0x0058 (0x0008) [0x0000000000000000]               
	class TArray<class ULineSegment*>                  LineSegments;                                  // 0x0060 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<class UVertex*>                       Verts;                                         // 0x0070 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class UMaterial*                                   RegionMaterial;                                // 0x0080 (0x0008) [0x0000000000000000]               
	class UMaterial*                                   SIZoneMaterial;                                // 0x0088 (0x0008) [0x0000000000000000]               
	class UMaterial*                                   SIRetreatMaterial;                             // 0x0090 (0x0008) [0x0000000000000000]               
	class UMaterial*                                   SIStealthMaterial;                             // 0x0098 (0x0008) [0x0000000000000000]               
	uint32_t                                           bMakeRegion : 1;                               // 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bIsCircular : 1;                               // 0x00A0 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bIsMoving : 1;                                 // 0x00A0 (0x0004) [0x0000000000000000] [0x00000004] 
	int32_t                                            CombatZoneID;                                  // 0x00A4 (0x0004) [0x0000000000000000]               
	class FString                                      CombatZoneName;                                // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FVector>                       RegionData;                                    // 0x00B8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Line");
		}

		return uClassPointer;
	};

};

// Class Engine.LineData
// 0x0060 (0x0058 - 0x00B8)
class ULineData : public UObject
{
public:
	struct FVector                                     RubberBand[0x2];                               // 0x0058 (0x0018) [0x0000000000000000]               
	uint32_t                                           bShowRubberBand : 1;                           // 0x0070 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bTerrainTrace : 1;                             // 0x0070 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bShowOnlySelectedZone : 1;                     // 0x0070 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bAutoGenRedundantData : 1;                     // 0x0070 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bIsSelectedMap : 1;                            // 0x0070 (0x0004) [0x0000000000000000] [0x00000010] 
	int32_t                                            ParentID;                                      // 0x0074 (0x0004) [0x0000000000000000]               
	int32_t                                            SegmentID;                                     // 0x0078 (0x0004) [0x0000000000000000]               
	int32_t                                            CurrentCombatZoneID;                           // 0x007C (0x0004) [0x0000000000000000]               
	class FString                                      CurrentCombatZoneName;                         // 0x0080 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              VertexScale;                                   // 0x0090 (0x0004) [0x0000000000000000]               
	float                                              VertexScaleFactor;                             // 0x0094 (0x0004) [0x0000000000000000]               
	float                                              LineSegmentScale;                              // 0x0098 (0x0004) [0x0000000000000000]               
	float                                              LineSegmentScaleFactor;                        // 0x009C (0x0004) [0x0000000000000000]               
	ELineEditMode                                      EditorMode;                                    // 0x00A0 (0x0001) [0x0000000000000000]               
	class TArray<class ULine*>                         Lines;                                         // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LineData");
		}

		return uClassPointer;
	};

};

// Class Engine.LineSegment
// 0x0070 (0x0058 - 0x00C8)
class ULineSegment : public UObject
{
public:
	class ULine*                                       ParentLine;                                    // 0x0058 (0x0008) [0x0000000000000000]               
	class UVertex*                                     Verts[0x2];                                    // 0x0060 (0x0010) [0x0000000000000000]               
	struct FVector                                     Direction;                                     // 0x0070 (0x000C) [0x0000000000000000]               
	struct FVector                                     NormalLine[0x2];                               // 0x007C (0x0018) [0x0000000000000000]               
	uint32_t                                           RightNormal : 1;                               // 0x0094 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bIsSelected : 1;                               // 0x0094 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bDelete : 1;                                   // 0x0094 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              Size;                                          // 0x0098 (0x0004) [0x0000000000000000]               
	ELineSegmentType                                   SegmentType;                                   // 0x009C (0x0001) [0x0000000000000000]               
	ELineSegmentMaterial                               SegmentMaterial;                               // 0x009D (0x0001) [0x0000000000000000]               
	int32_t                                            SegmentID;                                     // 0x00A0 (0x0004) [0x0000000000000000]               
	struct FColor                                      LineColor;                                     // 0x00A4 (0x0004) [0x0000000000000000]               
	struct FColor                                      NormalColor;                                   // 0x00A8 (0x0004) [0x0000000000000000]               
	struct FColor                                      SelectedColor;                                 // 0x00AC (0x0004) [0x0000000000000000]               
	struct FColor                                      VulnerableColor;                               // 0x00B0 (0x0004) [0x0000000000000000]               
	struct FColor                                      VantageColor;                                  // 0x00B4 (0x0004) [0x0000000000000000]               
	struct FColor                                      SIColor;                                       // 0x00B8 (0x0004) [0x0000000000000000]               
	struct FColor                                      RetreatColor;                                  // 0x00BC (0x0004) [0x0000000000000000]               
	struct FColor                                      StealthColor;                                  // 0x00C0 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LineSegment");
		}

		return uClassPointer;
	};

};

// Class Engine.LocalMessage
// 0x0010 (0x0058 - 0x0068)
class ULocalMessage : public UObject
{
public:
	uint32_t                                           bIsSpecial : 1;                                // 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bIsUnique : 1;                                 // 0x0058 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bIsPartiallyUnique : 1;                        // 0x0058 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bIsConsoleMessage : 1;                         // 0x0058 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bBeep : 1;                                     // 0x0058 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bCountInstances : 1;                           // 0x0058 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              Lifetime;                                      // 0x005C (0x0004) [0x0000000000000000]               
	struct FColor                                      DrawColor;                                     // 0x0060 (0x0004) [0x0000000000000000]               
	ELocalMessageType                                  MsgType;                                       // 0x0064 (0x0001) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LocalMessage");
		}

		return uClassPointer;
	};

	static bool PartiallyDuplicates(int32_t Switch1, int32_t Switch2, class UObject* OptionalObject1, class UObject* OptionalObject2);
	static bool IsConsoleMessage(int32_t Switch);
	static float GetLifeTime(int32_t Switch);
	static struct FColor GetColor(int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	static struct FColor GetConsoleColor(class APlayerReplicationInfo* RelatedPRI);
	static class FString GetString(int32_t optionalSwitch, bool optionalBPRI1HUD, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	static ELocalMessageType GetMsgType(int32_t optionalSwitch, bool optionalBPRI1HUD, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	static void ClientReceive(class APlayerController* P, int32_t optionalSwitch, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
};

// Class Engine.FailedConnect
// 0x0040 (0x0068 - 0x00A8)
class UFailedConnect : public ULocalMessage
{
public:
	class FString                                      FailMessage[0x4];                              // 0x0068 (0x0040) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FailedConnect");
		}

		return uClassPointer;
	};

	static class FString GetString(int32_t optionalSwitch, bool optionalBPRI1HUD, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
	static int32_t GetFailSwitch(const class FString& FailString);
};

// Class Engine.GameMessage
// 0x0170 (0x0068 - 0x01D8)
class UGameMessage : public ULocalMessage
{
public:
	class FString                                      SwitchLevelMessage;                            // 0x0068 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      LeftMessage;                                   // 0x0078 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      FailedTeamMessage;                             // 0x0088 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      FailedPlaceMessage;                            // 0x0098 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      FailedSpawnMessage;                            // 0x00A8 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      EnteredMessage;                                // 0x00B8 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      MaxedOutMessage;                               // 0x00C8 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      ArbitrationMessage;                            // 0x00D8 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      OvertimeMessage;                               // 0x00E8 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      GlobalNameChange;                              // 0x00F8 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      NewTeamMessage;                                // 0x0108 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      NewTeamMessageTrailer;                         // 0x0118 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      NoNameChange;                                  // 0x0128 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      VoteStarted;                                   // 0x0138 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      VotePassed;                                    // 0x0148 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      MustHaveStats;                                 // 0x0158 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      CantBeSpectator;                               // 0x0168 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      CantBePlayer;                                  // 0x0178 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      BecameSpectator;                               // 0x0188 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      NewPlayerMessage;                              // 0x0198 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      KickWarning;                                   // 0x01A8 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      NewSpecMessage;                                // 0x01B8 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      SpecEnteredMessage;                            // 0x01C8 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GameMessage");
		}

		return uClassPointer;
	};

	static class FString GetString(int32_t optionalSwitch, bool optionalBPRI1HUD, class APlayerReplicationInfo* optionalRelatedPRI, class APlayerReplicationInfo* optionalRelatedPRI01, class UObject* optionalOptionalObject);
};

// Class Engine.LODObject
// 0x0058 (0x0058 - 0x00B0)
class ULODObject : public UObject
{
public:
	class TArray<class AActor*>                        MeshActors;                                    // 0x0058 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FLODProxyMeshData>             ProxyMeshData;                                 // 0x0068 (0x0010) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FVector                                     ProxyMeshLocation;                             // 0x0078 (0x000C) [0x0000000000000001] (CPF_Edit)    
	class FString                                      LODName;                                       // 0x0088 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FVector                                     MeshesOrigin;                                  // 0x0098 (0x000C) [0x0000000000000000]               
	float                                              MeshesRadius;                                  // 0x00A4 (0x0004) [0x0000000000000000]               
	int32_t                                            CurrentLOD;                                    // 0x00A8 (0x0004) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LODObject");
		}

		return uClassPointer;
	};

};

// Class Engine.MapInfo
// 0x0000 (0x0058 - 0x0058)
class UMapInfo : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MapInfo");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpression
// 0x0030 (0x0058 - 0x0088)
class UMaterialExpression : public UObject
{
public:
	uint32_t                                           bRealtimePreview : 1;                          // 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bNeedToUpdatePreview : 1;                      // 0x0058 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	uint32_t                                           bIsParameterExpression : 1;                    // 0x0058 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bShowOutputNameOnPin : 1;                      // 0x0058 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bHidePreviewWindow : 1;                        // 0x0058 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bShowInputs : 1;                               // 0x0058 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bShowOutputs : 1;                              // 0x0058 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bImmuneToClean : 1;                            // 0x0058 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bUsedByStaticParameterSet : 1;                 // 0x0058 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bPendingPostLoadConversion : 1;                // 0x0058 (0x0004) [0x0000000000002000] [0x00000200] (CPF_Transient)
	uint32_t                                           PackageVersionChanged : 1;                     // 0x0058 (0x0004) [0x0000000000002000] [0x00000400] (CPF_Transient)
	class UMaterial*                                   Material;                                      // 0x0060 (0x0008) [0x0000000000000002] (CPF_Const)   
	class UMaterialFunction*                           Function;                                      // 0x0068 (0x0008) [0x0000000000000002] (CPF_Const)   
	struct FColor                                      BorderColor;                                   // 0x0070 (0x0004) [0x0000000000000000]               
	class TArray<struct FExpressionOutput>             Outputs;                                       // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpression");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionAbs
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionAbs : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionAbs");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionAdd
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionAdd : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionAdd");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionAnd
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionAnd : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionAnd");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionAppendVector
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionAppendVector : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionAppendVector");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionArcCosine
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionArcCosine : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionArcCosine");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionArcSine
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionArcSine : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionArcSine");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionArcTangent
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionArcTangent : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionArcTangent");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionArcTangent2
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionArcTangent2 : public UMaterialExpression
{
public:
	struct FExpressionInput                            InputX;                                        // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            InputY;                                        // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionArcTangent2");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionBumpOffset
// 0x0078 (0x0088 - 0x0100)
class UMaterialExpressionBumpOffset : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinate;                                    // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Height;                                        // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              HeightRatio;                                   // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ReferencePlane;                                // 0x00FC (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionBumpOffset");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionBumpOffsetEx
// 0x00E0 (0x0088 - 0x0168)
class UMaterialExpressionBumpOffsetEx : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinate;                                    // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Height;                                        // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            HeightRatio;                                   // 0x00F8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            ReferencePlane;                                // 0x0130 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionBumpOffsetEx");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionBumpOffsetSloped
// 0x00C8 (0x0088 - 0x0150)
class UMaterialExpressionBumpOffsetSloped : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinate;                                    // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	class UTexture2D*                                  NormalTexture;                                 // 0x00C0 (0x0008) [0x0000000020000000]  CPF_Deprecated)
	class UTexture2D*                                  HeightTexture;                                 // 0x00C8 (0x0008) [0x0000000020000000]  CPF_Deprecated)
	struct FExpressionInput                            Normal;                                        // 0x00D0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Height;                                        // 0x0108 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              HeightRatio;                                   // 0x0140 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ReferencePlane;                                // 0x0144 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Iterations;                                    // 0x0148 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           NeedsConversionToParameter : 1;                // 0x014C (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionBumpOffsetSloped");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionCameraVector
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionCameraVector : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionCameraVector");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionCameraWorldPosition
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionCameraWorldPosition : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionCameraWorldPosition");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionCeil
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionCeil : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionCeil");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionChoose
// 0x00B0 (0x0088 - 0x0138)
class UMaterialExpressionChoose : public UMaterialExpression
{
public:
	struct FExpressionInput                            Bool;                                          // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            A;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00F8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bStaticSwitchCompatibility : 1;                // 0x0130 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bBranchHint : 1;                               // 0x0130 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionChoose");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionClamp
// 0x00A8 (0x0088 - 0x0130)
class UMaterialExpressionClamp : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Min;                                           // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Max;                                           // 0x00F8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionClamp");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionComment
// 0x0020 (0x0088 - 0x00A8)
class UMaterialExpressionComment : public UMaterialExpression
{
public:
	int32_t                                            PosX;                                          // 0x0088 (0x0004) [0x0000000000000000]               
	int32_t                                            PosY;                                          // 0x008C (0x0004) [0x0000000000000000]               
	int32_t                                            SizeX;                                         // 0x0090 (0x0004) [0x0000000000000000]               
	int32_t                                            SizeY;                                         // 0x0094 (0x0004) [0x0000000000000000]               
	class FString                                      Text;                                          // 0x0098 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionComment");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionCompare
// 0x0078 (0x0088 - 0x0100)
class UMaterialExpressionCompare : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	ECompareType                                       CompareType;                                   // 0x00F8 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionCompare");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionComponentMask
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionComponentMask : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           R : 1;                                         // 0x00C0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           G : 1;                                         // 0x00C0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           B : 1;                                         // 0x00C0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           A : 1;                                         // 0x00C0 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionComponentMask");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionConstant
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionConstant : public UMaterialExpression
{
public:
	float                                              R;                                             // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionConstant");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionConstant2Vector
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionConstant2Vector : public UMaterialExpression
{
public:
	float                                              R;                                             // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              G;                                             // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionConstant2Vector");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionConstant3Vector
// 0x0010 (0x0088 - 0x0098)
class UMaterialExpressionConstant3Vector : public UMaterialExpression
{
public:
	float                                              R;                                             // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              G;                                             // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              B;                                             // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionConstant3Vector");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionConstant4Vector
// 0x0010 (0x0088 - 0x0098)
class UMaterialExpressionConstant4Vector : public UMaterialExpression
{
public:
	float                                              R;                                             // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              G;                                             // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              B;                                             // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              A;                                             // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionConstant4Vector");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionConstantBiasScale
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionConstantBiasScale : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              Bias;                                          // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Scale;                                         // 0x00C4 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionConstantBiasScale");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionConstantBufferVariable
// 0x0028 (0x0088 - 0x00B0)
class UMaterialExpressionConstantBufferVariable : public UMaterialExpression
{
public:
	class UClass*                                      ConstantBufferClass;                           // 0x0088 (0x0008) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	struct FConstantBufferVariableDefinition           ConstantBufferVar;                             // 0x0090 (0x001C) [0x0000000000420003] (CPF_Edit | CPF_Const | CPF_EditConst | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionConstantBufferVariable");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionConstantClamp
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionConstantClamp : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              Min;                                           // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Max;                                           // 0x00C4 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionConstantClamp");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionConstantInt1
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionConstantInt1 : public UMaterialExpression
{
public:
	int32_t                                            X;                                             // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionConstantInt1");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionConstantInt2
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionConstantInt2 : public UMaterialExpression
{
public:
	int32_t                                            X;                                             // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Y;                                             // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionConstantInt2");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionConstantInt3
// 0x0010 (0x0088 - 0x0098)
class UMaterialExpressionConstantInt3 : public UMaterialExpression
{
public:
	int32_t                                            X;                                             // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Y;                                             // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Z;                                             // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionConstantInt3");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionConstantInt4
// 0x0010 (0x0088 - 0x0098)
class UMaterialExpressionConstantInt4 : public UMaterialExpression
{
public:
	int32_t                                            X;                                             // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Y;                                             // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Z;                                             // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            W;                                             // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionConstantInt4");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionCosine
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionCosine : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              Period;                                        // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionCosine");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionCrossProduct
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionCrossProduct : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionCrossProduct");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionCustom
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionCustom : public UMaterialExpression
{
public:
	class FString                                      Code;                                          // 0x0088 (0x0010) [0x0000040000400001] (CPF_Edit | CPF_NeedCtorLink)
	ECustomMaterialOutputType                          OutputType;                                    // 0x0098 (0x0001) [0x0000000000000001] (CPF_Edit)    
	class FString                                      Description;                                   // 0x00A0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FCustomInput>                  Inputs;                                        // 0x00B0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionCustom");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionCustomTexture
// 0x0010 (0x0088 - 0x0098)
class UMaterialExpressionCustomTexture : public UMaterialExpression
{
public:
	class UTexture*                                    Texture;                                       // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           NeedsConversionToParameter : 1;                // 0x0090 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionCustomTexture");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDdx
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionDdx : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDdx");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDdy
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionDdy : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDdy");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDegrees
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionDegrees : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDegrees");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDepthBiasedAlpha
// 0x0078 (0x0088 - 0x0100)
class UMaterialExpressionDepthBiasedAlpha : public UMaterialExpression
{
public:
	uint32_t                                           bNormalize : 1;                                // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              BiasScale;                                     // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FExpressionInput                            Alpha;                                         // 0x0090 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Bias;                                          // 0x00C8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDepthBiasedAlpha");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDepthBiasedBlend
// 0x00B0 (0x0088 - 0x0138)
class UMaterialExpressionDepthBiasedBlend : public UMaterialExpression
{
public:
	uint32_t                                           bNormalize : 1;                                // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              BiasScale;                                     // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FExpressionInput                            RGB;                                           // 0x0090 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Alpha;                                         // 0x00C8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Bias;                                          // 0x0100 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDepthBiasedBlend");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDepthOfFieldFunction
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionDepthOfFieldFunction : public UMaterialExpression
{
public:
	EDepthOfFieldFunctionValue                         FunctionValue;                                 // 0x0088 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FExpressionInput                            Depth;                                         // 0x0090 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDepthOfFieldFunction");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDeriveNormalZ
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionDeriveNormalZ : public UMaterialExpression
{
public:
	struct FExpressionInput                            InXY;                                          // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDeriveNormalZ");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDesaturation
// 0x0080 (0x0088 - 0x0108)
class UMaterialExpressionDesaturation : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Percent;                                       // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FLinearColor                                LuminanceFactors;                              // 0x00F8 (0x0010) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDesaturation");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDestColor
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionDestColor : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDestColor");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDestDepth
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionDestDepth : public UMaterialExpression
{
public:
	uint32_t                                           bNormalize : 1;                                // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bRawDepth : 1;                                 // 0x0088 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDestDepth");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDistance
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionDistance : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDistance");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDivide
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionDivide : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDivide");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDominantSkyLight
// 0x0010 (0x0088 - 0x0098)
class UMaterialExpressionDominantSkyLight : public UMaterialExpression
{
public:
	uint32_t                                           bUseTimeOfDay : 1;                             // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              TimeOfDayMax;                                  // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TimeOfDayMin;                                  // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDominantSkyLight");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDotProduct
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionDotProduct : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDotProduct");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDynamicParameter
// 0x0010 (0x0088 - 0x0098)
class UMaterialExpressionDynamicParameter : public UMaterialExpression
{
public:
	class TArray<class FString>                        ParamNames;                                    // 0x0088 (0x0010) [0x0000000000400041] (CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDynamicParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionMeshEmitterDynamicParameter
// 0x0000 (0x0098 - 0x0098)
class UMaterialExpressionMeshEmitterDynamicParameter : public UMaterialExpressionDynamicParameter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionMeshEmitterDynamicParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionExp
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionExp : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionExp");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionExp2
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionExp2 : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionExp2");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFloor
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionFloor : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFloor");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFluidNormal
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionFluidNormal : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinates;                                   // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFluidNormal");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFmod
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionFmod : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFmod");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFoliageImpulseDirection
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionFoliageImpulseDirection : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFoliageImpulseDirection");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFoliageNormalizedRotationAxisAndAngle
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionFoliageNormalizedRotationAxisAndAngle : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFoliageNormalizedRotationAxisAndAngle");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFontSample
// 0x0010 (0x0088 - 0x0098)
class UMaterialExpressionFontSample : public UMaterialExpression
{
public:
	class UFont*                                       Font;                                          // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            FontTexturePage;                               // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFontSample");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFontSampleParameter
// 0x0018 (0x0098 - 0x00B0)
class UMaterialExpressionFontSampleParameter : public UMaterialExpressionFontSample
{
public:
	struct FName                                       ParameterName;                                 // 0x0098 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FGuid                                       ExpressionGUID;                                // 0x00A0 (0x0010) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFontSampleParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFrac
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionFrac : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFrac");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFresnel
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionFresnel : public UMaterialExpression
{
public:
	float                                              Exponent;                                      // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FExpressionInput                            Normal;                                        // 0x0090 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFresnel");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFunctionInput
// 0x00A8 (0x0088 - 0x0130)
class UMaterialExpressionFunctionInput : public UMaterialExpression
{
public:
	struct FExpressionInput                            Preview;                                       // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      InputName;                                     // 0x00C0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class FString                                      Description;                                   // 0x00D0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FGuid                                       Id;                                            // 0x00E0 (0x0010) [0x0000000000000002] (CPF_Const)   
	EFunctionInputType                                 InputType;                                     // 0x00F0 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData00[0xF];                            // 0x00F1 (0x000F) MISSED OFFSET
	struct FVector4                                    PreviewValue;                                  // 0x0100 (0x0010) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            PreviewValueInt[0x4];                          // 0x0110 (0x0010) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUsePreviewValueAsDefault : 1;                 // 0x0120 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bCompilingFunctionPreview : 1;                 // 0x0120 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	int32_t                                            SortPriority;                                  // 0x0124 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData01[0x8];                            // 0x0128 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFunctionInput");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFunctionOutput
// 0x0078 (0x0088 - 0x0100)
class UMaterialExpressionFunctionOutput : public UMaterialExpression
{
public:
	class FString                                      OutputName;                                    // 0x0088 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class FString                                      Description;                                   // 0x0098 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	int32_t                                            SortPriority;                                  // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FExpressionInput                            A;                                             // 0x00B0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bLastPreviewed : 1;                            // 0x00E8 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FGuid                                       Id;                                            // 0x00EC (0x0010) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFunctionOutput");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionGradient
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionGradient : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinates;                                   // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	EGradientStyle                                     GradientStyle;                                 // 0x00C0 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ETextureAddress                                    AddressX;                                      // 0x00C1 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ETextureAddress                                    AddressY;                                      // 0x00C2 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FLinearColor                                ForegroundColor;                               // 0x00C4 (0x0010) [0x0000000000000001] (CPF_Edit)    
	struct FLinearColor                                BackgroundColor;                               // 0x00D4 (0x0010) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   ForegroundOffset;                              // 0x00E4 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   BackgroundOffset;                              // 0x00EC (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bReverse : 1;                                  // 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bSmoothInOut : 1;                              // 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionGradient");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionIf
// 0x0118 (0x0088 - 0x01A0)
class UMaterialExpressionIf : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            AGreaterThanB;                                 // 0x00F8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            AEqualsB;                                      // 0x0130 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            ALessThanB;                                    // 0x0168 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionIf");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLength
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionLength : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLength");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLensFlareIntensity
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionLensFlareIntensity : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLensFlareIntensity");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLensFlareOcclusion
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionLensFlareOcclusion : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLensFlareOcclusion");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLensFlareRadialDistance
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionLensFlareRadialDistance : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLensFlareRadialDistance");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLensFlareRayDistance
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionLensFlareRayDistance : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLensFlareRayDistance");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLensFlareSourceDistance
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionLensFlareSourceDistance : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLensFlareSourceDistance");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLightmapUVs
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionLightmapUVs : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLightmapUVs");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLightmassReplace
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionLightmassReplace : public UMaterialExpression
{
public:
	struct FExpressionInput                            Realtime;                                      // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Lightmass;                                     // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLightmassReplace");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLightVector
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionLightVector : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLightVector");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLinearInterpolate
// 0x00A8 (0x0088 - 0x0130)
class UMaterialExpressionLinearInterpolate : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Alpha;                                         // 0x00F8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLinearInterpolate");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLog
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionLog : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLog");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLog10
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionLog10 : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLog10");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionLog2
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionLog2 : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionLog2");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionMaterialFunctionCall
// 0x0028 (0x0088 - 0x00B0)
class UMaterialExpressionMaterialFunctionCall : public UMaterialExpression
{
public:
	class UMaterialFunction*                           MaterialFunction;                              // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FFunctionExpressionInput>      FunctionInputs;                                // 0x0090 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FFunctionExpressionOutput>     FunctionOutputs;                               // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionMaterialFunctionCall");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionMax
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionMax : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionMax");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionMeshEmitterVertexColor
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionMeshEmitterVertexColor : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionMeshEmitterVertexColor");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionMin
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionMin : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionMin");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionMultiply
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionMultiply : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionMultiply");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionMultiplyAndAdd
// 0x00A8 (0x0088 - 0x0130)
class UMaterialExpressionMultiplyAndAdd : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            WeightB;                                       // 0x00F8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionMultiplyAndAdd");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionNormalize
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionNormalize : public UMaterialExpression
{
public:
	struct FExpressionInput                            VectorInput;                                   // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionNormalize");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionNot
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionNot : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionNot");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionObjectOrientation
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionObjectOrientation : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionObjectOrientation");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionObjectPivotPosition
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionObjectPivotPosition : public UMaterialExpression
{
public:
	uint32_t                                           bUseViewSpace : 1;                             // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionObjectPivotPosition");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionObjectRadius
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionObjectRadius : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionObjectRadius");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionObjectVelocity
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionObjectVelocity : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionObjectVelocity");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionObjectWorldPosition
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionObjectWorldPosition : public UMaterialExpression
{
public:
	uint32_t                                           bUseViewSpace : 1;                             // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionObjectWorldPosition");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionOcclusionPercentage
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionOcclusionPercentage : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionOcclusionPercentage");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionOneMinus
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionOneMinus : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionOneMinus");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionOr
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionOr : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionOr");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionPanner
// 0x0078 (0x0088 - 0x0100)
class UMaterialExpressionPanner : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinate;                                    // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Time;                                          // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              SpeedX;                                        // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SpeedY;                                        // 0x00FC (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionPanner");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionParameter
// 0x0020 (0x0088 - 0x00A8)
class UMaterialExpressionParameter : public UMaterialExpression
{
public:
	struct FName                                       ParameterName;                                 // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FGuid                                       ExpressionGUID;                                // 0x0090 (0x0010) [0x0000000000000002] (CPF_Const)   
	uint32_t                                           bHiddenFromMaterialInstanceEditor : 1;         // 0x00A0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionBoolParameter
// 0x0008 (0x00A8 - 0x00B0)
class UMaterialExpressionBoolParameter : public UMaterialExpressionParameter
{
public:
	uint32_t                                           DefaultValue : 1;                              // 0x00A8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionBoolParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFloat1Parameter
// 0x0008 (0x00A8 - 0x00B0)
class UMaterialExpressionFloat1Parameter : public UMaterialExpressionParameter
{
public:
	struct FFloat1                                     DefaultValue;                                  // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFloat1Parameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFloat2Parameter
// 0x0008 (0x00A8 - 0x00B0)
class UMaterialExpressionFloat2Parameter : public UMaterialExpressionParameter
{
public:
	struct FFloat2                                     DefaultValue;                                  // 0x00A8 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFloat2Parameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFloat3Parameter
// 0x0010 (0x00A8 - 0x00B8)
class UMaterialExpressionFloat3Parameter : public UMaterialExpressionParameter
{
public:
	struct FFloat3                                     DefaultValue;                                  // 0x00A8 (0x000C) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFloat3Parameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFloat4Parameter
// 0x0010 (0x00A8 - 0x00B8)
class UMaterialExpressionFloat4Parameter : public UMaterialExpressionParameter
{
public:
	struct FFloat4                                     DefaultValue;                                  // 0x00A8 (0x0010) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFloat4Parameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionIntParameter
// 0x0008 (0x00A8 - 0x00B0)
class UMaterialExpressionIntParameter : public UMaterialExpressionParameter
{
public:
	int32_t                                            DefaultValue;                                  // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionIntParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSamplerParameter
// 0x0008 (0x00A8 - 0x00B0)
class UMaterialExpressionSamplerParameter : public UMaterialExpressionParameter
{
public:
	class USampler*                                    Sampler;                                       // 0x00A8 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSamplerParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionScalarParameter
// 0x0008 (0x00A8 - 0x00B0)
class UMaterialExpressionScalarParameter : public UMaterialExpressionParameter
{
public:
	float                                              DefaultValue;                                  // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           NeedsConversionToFloat1 : 1;                   // 0x00AC (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionScalarParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionStaticBoolParameter
// 0x0010 (0x00A8 - 0x00B8)
class UMaterialExpressionStaticBoolParameter : public UMaterialExpressionParameter
{
public:
	uint32_t                                           DefaultValue : 1;                              // 0x00A8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           ExtendedCaptionDisplay : 1;                    // 0x00A8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	struct FPointer                                    InstanceOverride;                              // 0x00B0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionStaticBoolParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionStaticSwitchParameter
// 0x0078 (0x00B8 - 0x0130)
class UMaterialExpressionStaticSwitchParameter : public UMaterialExpressionStaticBoolParameter
{
public:
	struct FExpressionInput                            A;                                             // 0x00B8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00F0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bPerformConversionToDynamicBool : 1;           // 0x0128 (0x0004) [0x0000000800002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionStaticSwitchParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionStaticComponentMaskParameter
// 0x0048 (0x00A8 - 0x00F0)
class UMaterialExpressionStaticComponentMaskParameter : public UMaterialExpressionParameter
{
public:
	struct FExpressionInput                            Input;                                         // 0x00A8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           DefaultR : 1;                                  // 0x00E0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           DefaultG : 1;                                  // 0x00E0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           DefaultB : 1;                                  // 0x00E0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           DefaultA : 1;                                  // 0x00E0 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	struct FPointer                                    InstanceOverride;                              // 0x00E8 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionStaticComponentMaskParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureParameter
// 0x0008 (0x00A8 - 0x00B0)
class UMaterialExpressionTextureParameter : public UMaterialExpressionParameter
{
public:
	class UTexture*                                    Texture;                                       // 0x00A8 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureParameter2D
// 0x0000 (0x00B0 - 0x00B0)
class UMaterialExpressionTextureParameter2D : public UMaterialExpressionTextureParameter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureParameter2D");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureParameter3D
// 0x0000 (0x00B0 - 0x00B0)
class UMaterialExpressionTextureParameter3D : public UMaterialExpressionTextureParameter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureParameter3D");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureParameterCube
// 0x0000 (0x00B0 - 0x00B0)
class UMaterialExpressionTextureParameterCube : public UMaterialExpressionTextureParameter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureParameterCube");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionVectorParameter
// 0x0018 (0x00A8 - 0x00C0)
class UMaterialExpressionVectorParameter : public UMaterialExpressionParameter
{
public:
	struct FLinearColor                                DefaultValue;                                  // 0x00A8 (0x0010) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           NeedsConversionToFloat4 : 1;                   // 0x00B8 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionVectorParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionParticleMacroUV
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionParticleMacroUV : public UMaterialExpression
{
public:
	uint32_t                                           bUseViewSpace : 1;                             // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionParticleMacroUV");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionPerInstanceRandom
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionPerInstanceRandom : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionPerInstanceRandom");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionPixelDepth
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionPixelDepth : public UMaterialExpression
{
public:
	uint32_t                                           bNormalize : 1;                                // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionPixelDepth");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionPlatformSwitch
// 0x00E0 (0x0088 - 0x0168)
class UMaterialExpressionPlatformSwitch : public UMaterialExpression
{
public:
	struct FExpressionInput                            Default;                                       // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            PC;                                            // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Ps4;                                           // 0x00F8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            XBox;                                          // 0x0130 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionPlatformSwitch");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionPower
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionPower : public UMaterialExpression
{
public:
	struct FExpressionInput                            Base;                                          // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Exponent;                                      // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionPower");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionRadians
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionRadians : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionRadians");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionRecipSquareRoot
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionRecipSquareRoot : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionRecipSquareRoot");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionReflectionVector
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionReflectionVector : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionReflectionVector");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionRelativeTeamColor
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionRelativeTeamColor : public UMaterialExpression
{
public:
	struct FExpressionInput                            TeamIndex;                                     // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionRelativeTeamColor");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionRotate3D
// 0x00E8 (0x0088 - 0x0170)
class UMaterialExpressionRotate3D : public UMaterialExpression
{
public:
	struct FExpressionInput                            Vec;                                           // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            MatrixForward;                                 // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            MatrixRight;                                   // 0x00F8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            MatrixUp;                                      // 0x0130 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bTranspose : 1;                                // 0x0168 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionRotate3D");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionRotateAboutAxis
// 0x00A8 (0x0088 - 0x0130)
class UMaterialExpressionRotateAboutAxis : public UMaterialExpression
{
public:
	struct FExpressionInput                            NormalizedRotationAxisAndAngle;                // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            PositionOnAxis;                                // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Position;                                      // 0x00F8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionRotateAboutAxis");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionRotator
// 0x0080 (0x0088 - 0x0108)
class UMaterialExpressionRotator : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinate;                                    // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Time;                                          // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              CenterX;                                       // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CenterY;                                       // 0x00FC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Speed;                                         // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionRotator");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionRound
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionRound : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionRound");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSaturate
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionSaturate : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSaturate");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSceneDepth
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionSceneDepth : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinates;                                   // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bNormalize : 1;                                // 0x00C0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSceneDepth");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSceneNormal
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionSceneNormal : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinates;                                   // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           ScreenAlign : 1;                               // 0x00C0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSceneNormal");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSceneTexture
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionSceneTexture : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinates;                                   // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	ESceneTextureType                                  SceneTextureType;                              // 0x00C0 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           ScreenAlign : 1;                               // 0x00C4 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSceneTexture");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionScreenPosition
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionScreenPosition : public UMaterialExpression
{
public:
	uint32_t                                           ScreenAlign : 1;                               // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionScreenPosition");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSine
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionSine : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              Period;                                        // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSine");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSkinnedVelocity
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionSkinnedVelocity : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSkinnedVelocity");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSphereMask
// 0x00E8 (0x0088 - 0x0170)
class UMaterialExpressionSphereMask : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Radius;                                        // 0x00F8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Hardness;                                      // 0x0130 (0x0038) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              AttenuationRadius;                             // 0x0168 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              HardnessPercent;                               // 0x016C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSphereMask");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSPHFluidNormal
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionSPHFluidNormal : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSPHFluidNormal");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSPHFluidThickness
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionSPHFluidThickness : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSPHFluidThickness");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSPHFluidVertexColor
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionSPHFluidVertexColor : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSPHFluidVertexColor");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSplitscreenIndex
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionSplitscreenIndex : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSplitscreenIndex");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSquareRoot
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionSquareRoot : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSquareRoot");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionStaticBool
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionStaticBool : public UMaterialExpression
{
public:
	uint32_t                                           Value : 1;                                     // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionStaticBool");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionStaticSwitch
// 0x00B0 (0x0088 - 0x0138)
class UMaterialExpressionStaticSwitch : public UMaterialExpression
{
public:
	uint32_t                                           DefaultValue : 1;                              // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           ExtendedCaptionDisplay : 1;                    // 0x0088 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	struct FExpressionInput                            A;                                             // 0x0090 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Value;                                         // 0x0100 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionStaticSwitch");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSubtract
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionSubtract : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSubtract");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionSwizzle
// 0x0048 (0x0088 - 0x00D0)
class UMaterialExpressionSwizzle : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      SwizzleMask;                                   // 0x00C0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionSwizzle");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTangent
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionTangent : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTangent");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTeamIndex
// 0x0008 (0x0088 - 0x0090)
class UMaterialExpressionTeamIndex : public UMaterialExpression
{
public:
	ETeamDataSource                                    TeamDataSource;                                // 0x0088 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTeamIndex");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTerrainLayerCoords
// 0x0018 (0x0088 - 0x00A0)
class UMaterialExpressionTerrainLayerCoords : public UMaterialExpression
{
public:
	ETerrainCoordMappingType                           MappingType;                                   // 0x0088 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              MappingScale;                                  // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MappingRotation;                               // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MappingPanU;                                   // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MappingPanV;                                   // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTerrainLayerCoords");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTerrainLayerWeight
// 0x0098 (0x0088 - 0x0120)
class UMaterialExpressionTerrainLayerWeight : public UMaterialExpression
{
public:
	struct FPointer                                    InstanceOverride;                              // 0x0088 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FExpressionInput                            Base;                                          // 0x0090 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Layer;                                         // 0x00C8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FName                                       ParameterName;                                 // 0x0100 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              PreviewWeight;                                 // 0x0108 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FGuid                                       ExpressionGUID;                                // 0x010C (0x0010) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTerrainLayerWeight");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTerrainTextureCoordinate
// 0x0010 (0x0088 - 0x0098)
class UMaterialExpressionTerrainTextureCoordinate : public UMaterialExpression
{
public:
	uint32_t                                           WeightMap : 1;                                 // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	int32_t                                            LayerIndex;                                    // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	ETerrainMaterialProjectionType                     LayerProjection;                               // 0x0090 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTerrainTextureCoordinate");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureCoordinate
// 0x0010 (0x0088 - 0x0098)
class UMaterialExpressionTextureCoordinate : public UMaterialExpression
{
public:
	int32_t                                            CoordinateIndex;                               // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              UTiling;                                       // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              VTiling;                                       // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           UnMirrorU : 1;                                 // 0x0094 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           UnMirrorV : 1;                                 // 0x0094 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureCoordinate");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureDimensions
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionTextureDimensions : public UMaterialExpression
{
public:
	struct FExpressionInput                            Texture;                                       // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureDimensions");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureObject
// 0x0010 (0x0088 - 0x0098)
class UMaterialExpressionTextureObject : public UMaterialExpression
{
public:
	class UTexture*                                    Texture;                                       // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           NeedsConversionToParameter : 1;                // 0x0090 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureObject");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureSample
// 0x00F8 (0x0088 - 0x0180)
class UMaterialExpressionTextureSample : public UMaterialExpression
{
public:
	ETextureSampleColorTransform                       ColorTransform;                                // 0x0088 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ETextureSampleSamplerConfiguration                 SamplerConfiguration;                          // 0x0089 (0x0001) [0x0000000000000001] (CPF_Edit)    
	class UTexture*                                    Texture;                                       // 0x0090 (0x0008) [0x0000000020000000]  CPF_Deprecated)
	struct FExpressionInput                            Coordinates;                                   // 0x0098 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            TextureObject;                                 // 0x00D0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            CustomSampler;                                 // 0x0108 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            SampleLevelOrBias;                             // 0x0140 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bSampleLevel : 1;                              // 0x0178 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           NeedsConversionToParameter : 1;                // 0x0178 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureSample");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionDepthBiasBlend
// 0x0040 (0x0180 - 0x01C0)
class UMaterialExpressionDepthBiasBlend : public UMaterialExpressionTextureSample
{
public:
	uint32_t                                           bNormalize : 1;                                // 0x0180 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              BiasScale;                                     // 0x0184 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FExpressionInput                            Bias;                                          // 0x0188 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionDepthBiasBlend");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionFlipBookSample
// 0x0000 (0x0180 - 0x0180)
class UMaterialExpressionFlipBookSample : public UMaterialExpressionTextureSample
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionFlipBookSample");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionMeshSubUV
// 0x0000 (0x0180 - 0x0180)
class UMaterialExpressionMeshSubUV : public UMaterialExpressionTextureSample
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionMeshSubUV");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionMeshSubUVBlend
// 0x0000 (0x0180 - 0x0180)
class UMaterialExpressionMeshSubUVBlend : public UMaterialExpressionMeshSubUV
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionMeshSubUVBlend");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionParticleSubUV
// 0x0000 (0x0180 - 0x0180)
class UMaterialExpressionParticleSubUV : public UMaterialExpressionTextureSample
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionParticleSubUV");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureSampleParameter
// 0x0018 (0x0180 - 0x0198)
class UMaterialExpressionTextureSampleParameter : public UMaterialExpressionTextureSample
{
public:
	struct FName                                       ParameterName;                                 // 0x0180 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FGuid                                       ExpressionGUID;                                // 0x0188 (0x0010) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureObjectParameter
// 0x0000 (0x0198 - 0x0198)
class UMaterialExpressionTextureObjectParameter : public UMaterialExpressionTextureSampleParameter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureObjectParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureSampleParameter2D
// 0x0000 (0x0198 - 0x0198)
class UMaterialExpressionTextureSampleParameter2D : public UMaterialExpressionTextureSampleParameter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameter2D");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionAntialiasedTextureMask
// 0x0008 (0x0198 - 0x01A0)
class UMaterialExpressionAntialiasedTextureMask : public UMaterialExpressionTextureSampleParameter2D
{
public:
	float                                              Threshold;                                     // 0x0198 (0x0004) [0x0000000000000001] (CPF_Edit)    
	ETextureColorChannel                               Channel;                                       // 0x019C (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionAntialiasedTextureMask");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureSampleParameterMeshSubUV
// 0x0000 (0x0198 - 0x0198)
class UMaterialExpressionTextureSampleParameterMeshSubUV : public UMaterialExpressionTextureSampleParameter2D
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameterMeshSubUV");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureSampleParameterMeshSubUVBlend
// 0x0000 (0x0198 - 0x0198)
class UMaterialExpressionTextureSampleParameterMeshSubUVBlend : public UMaterialExpressionTextureSampleParameterMeshSubUV
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameterMeshSubUVBlend");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureSampleParameterNormal
// 0x0000 (0x0198 - 0x0198)
class UMaterialExpressionTextureSampleParameterNormal : public UMaterialExpressionTextureSampleParameter2D
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameterNormal");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureSampleParameterSubUV
// 0x0000 (0x0198 - 0x0198)
class UMaterialExpressionTextureSampleParameterSubUV : public UMaterialExpressionTextureSampleParameter2D
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameterSubUV");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureSampleParameter3D
// 0x0000 (0x0198 - 0x0198)
class UMaterialExpressionTextureSampleParameter3D : public UMaterialExpressionTextureSampleParameter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameter3D");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureSampleParameterCube
// 0x0000 (0x0198 - 0x0198)
class UMaterialExpressionTextureSampleParameterCube : public UMaterialExpressionTextureSampleParameter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameterCube");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureSampleParameterMovie
// 0x0000 (0x0198 - 0x0198)
class UMaterialExpressionTextureSampleParameterMovie : public UMaterialExpressionTextureSampleParameter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameterMovie");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTextureSplat
// 0x00B8 (0x0088 - 0x0140)
class UMaterialExpressionTextureSplat : public UMaterialExpression
{
public:
	class UTexture*                                    BackdropTexture;                               // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UTexture*                                    OverlayTexture;                                // 0x0090 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FExpressionInput                            UVs;                                           // 0x0098 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Offset;                                        // 0x00D0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Scale;                                         // 0x0108 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTextureSplat");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTime
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionTime : public UMaterialExpression
{
public:
	struct FExpressionInput                            Period;                                        // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bIgnorePause : 1;                              // 0x00C0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bPrimitiveOriginTime : 1;                      // 0x00C0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bMaterialOriginTime : 1;                       // 0x00C0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTime");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionToFloat
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionToFloat : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionToFloat");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTransform
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionTransform : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	EMaterialVectorCoordTransformSource                TransformSourceType;                           // 0x00C0 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	EMaterialVectorCoordTransform                      TransformType;                                 // 0x00C1 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTransform");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTransformPosition
// 0x0040 (0x0088 - 0x00C8)
class UMaterialExpressionTransformPosition : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	EMaterialPositionTransform                         TransformType;                                 // 0x00C0 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTransformPosition");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTrunc
// 0x0038 (0x0088 - 0x00C0)
class UMaterialExpressionTrunc : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                         // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTrunc");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionTwoSidedSign
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionTwoSidedSign : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionTwoSidedSign");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionVectorIf
// 0x00E8 (0x0088 - 0x0170)
class UMaterialExpressionVectorIf : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                             // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            B;                                             // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            IfTrue;                                        // 0x00F8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            IfFalse;                                       // 0x0130 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	EVectorIfComparator                                CompareFunc;                                   // 0x0168 (0x0001) [0x0000000020000000]  CPF_Deprecated)
	ECompareType                                       CompareType;                                   // 0x0169 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUpgradeCompareFunc : 1;                       // 0x016C (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionVectorIf");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionVertexColor
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionVertexColor : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionVertexColor");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionVertexVelocity
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionVertexVelocity : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionVertexVelocity");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionViewIndex
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionViewIndex : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionViewIndex");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWindDirectionAndSpeed
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionWindDirectionAndSpeed : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWindDirectionAndSpeed");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWorldAmbientColor
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionWorldAmbientColor : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWorldAmbientColor");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWorldEnvironmentColor
// 0x0070 (0x0088 - 0x00F8)
class UMaterialExpressionWorldEnvironmentColor : public UMaterialExpression
{
public:
	struct FExpressionInput                            ReflectionVector;                              // 0x0088 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FExpressionInput                            Roughness;                                     // 0x00C0 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWorldEnvironmentColor");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWorldLightColor
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionWorldLightColor : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWorldLightColor");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWorldNormal
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionWorldNormal : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWorldNormal");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWorldPosition
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionWorldPosition : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWorldPosition");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWorldSilhouetteBrightness
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionWorldSilhouetteBrightness : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWorldSilhouetteBrightness");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWorldSilhouetteData
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionWorldSilhouetteData : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWorldSilhouetteData");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWorldSilhouetteDesaturation
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionWorldSilhouetteDesaturation : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWorldSilhouetteDesaturation");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWorldSilhouetteMaxBrightness
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionWorldSilhouetteMaxBrightness : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWorldSilhouetteMaxBrightness");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWorldSilhouetteMinBrightness
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionWorldSilhouetteMinBrightness : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWorldSilhouetteMinBrightness");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialExpressionWorldSilhouetteRamp
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionWorldSilhouetteRamp : public UMaterialExpression
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialExpressionWorldSilhouetteRamp");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialFunction
// 0x0048 (0x0058 - 0x00A0)
class UMaterialFunction : public UObject
{
public:
	struct FGuid                                       StateId;                                       // 0x0058 (0x0010) [0x0000000000200000]               
	class FString                                      Description;                                   // 0x0068 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bExposeToLibrary : 1;                          // 0x0078 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bReentrantFlag : 1;                            // 0x0078 (0x0004) [0x0000000000002002] [0x00000002] (CPF_Const | CPF_Transient)
	uint32_t                                           PostPostLoadCompleted : 1;                     // 0x0078 (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)
	uint32_t                                           PackageVersionChanged : 1;                     // 0x0078 (0x0004) [0x0000000000002000] [0x00000008] (CPF_Transient)
	uint32_t                                           bCheckUniqueExpressionGUIDs : 1;               // 0x0078 (0x0004) [0x0000000000002000] [0x00000010] (CPF_Transient)
	uint32_t                                           Importing : 1;                                 // 0x0078 (0x0004) [0x0000000000002000] [0x00000020] (CPF_Transient)
	class TArray<class FString>                        LibraryCategories;                             // 0x0080 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UMaterialExpression*>           FunctionExpressions;                           // 0x0090 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialFunction");
		}

		return uClassPointer;
	};

};

// Class Engine.Model
// 0x0A38 (0x0058 - 0x0A90)
class UModel : public UObject
{
public:
	uint8_t                                           UnknownData00[0xA38];                          // 0x0058 (0x0A38) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Model");
		}

		return uClassPointer;
	};

};

// Class Engine.MorphTarget
// 0x0020 (0x0058 - 0x0078)
class UMorphTarget : public UObject
{
public:
	class TArray<int32_t>                              MorphLODModels;                                // 0x0058 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	int32_t                                            MaterialSlotId;                                // 0x0068 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       ScalarParameterName;                           // 0x006C (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MorphTarget");
		}

		return uClassPointer;
	};

};

// Class Engine.MorphTargetSet
// 0x0028 (0x0058 - 0x0080)
class UMorphTargetSet : public UObject
{
public:
	class TArray<class UMorphTarget*>                  Targets;                                       // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class USkeletalMesh*                               BaseSkelMesh;                                  // 0x0068 (0x0008) [0x0000000000000000]               
	struct FArray_Mirror                               RawWedgePointIndices;                          // 0x0070 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MorphTargetSet");
		}

		return uClassPointer;
	};

	class UMorphTarget* FindMorphTarget(const struct FName& MorphTargetName);
};

// Class Engine.MorphWeightSequence
// 0x0000 (0x0058 - 0x0058)
class UMorphWeightSequence : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MorphWeightSequence");
		}

		return uClassPointer;
	};

};

// Class Engine.MusicTrackDataStructures
// 0x0000 (0x0058 - 0x0058)
class UMusicTrackDataStructures : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MusicTrackDataStructures");
		}

		return uClassPointer;
	};

};

// Class Engine.NavigationHandle
// 0x0098 (0x0058 - 0x00F0)
class UNavigationHandle : public UObject
{
public:
	struct FBasedPosition                              FinalDestination;                              // 0x0058 (0x0038) [0x0000000000000000]               
	struct FNavMeshPathParams                          CachedPathParams;                              // 0x0090 (0x0060) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavigationHandle");
		}

		return uClassPointer;
	};

	bool PopulatePathfindingParamCache();
};

// Class Engine.NetDriver
// 0x01C8 (0x0060 - 0x0228)
class UNetDriver : public USubsystem
{
public:
	uint8_t                                           UnknownData00[0x3C - sizeof(double) - sizeof(__int64)];                           // 0x0060 (0x003C) MISSED OFFSET
	UPackageMap* PackageMap;
	double Time;
	float                                              ConnectionTimeout;                             // 0x009C (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              InitialConnectTimeout;                         // 0x00A0 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              KeepAliveTime;                                 // 0x00A4 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              RelevantTimeout;                               // 0x00A8 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              SpawnPrioritySeconds;                          // 0x00AC (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              ServerTravelPause;                             // 0x00B0 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            MaxClientRate;                                 // 0x00B4 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            MaxInternetClientRate;                         // 0x00B8 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            NetServerMaxTickRate;                          // 0x00BC (0x0004) [0x0000000000004000] (CPF_Config)  
	uint32_t                                           bClampListenServerTickRate : 1;                // 0x00C0 (0x0004) [0x0000000000004000] [0x00000001] (CPF_Config)
	uint32_t                                           AllowDownloads : 1;                            // 0x00C4 (0x0004) [0x0000000000004000] [0x00000001] (CPF_Config)
	uint8_t                                           UnknownData01[0x28];                           // 0x00C8 (0x0028) MISSED OFFSET
	int32_t                                            MaxDownloadSize;                               // 0x00F0 (0x0004) [0x0000000000004000] (CPF_Config)  
	class TArray<class FString>                        DownloadManagers;                              // 0x00F8 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	uint8_t                                           UnknownData02[0xC0];                           // 0x0108 (0x00C0) MISSED OFFSET
	class FString                                      NetConnectionClassName;                        // 0x01C8 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class UClass*										NetConnectionClass; //0x01d8
	uint8_t                                           UnknownData03[0x48];                           // 0x01D8 (0x0050) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NetDriver");
		}

		return uClassPointer;
	};

};

// Class Engine.DemoRecDriver
// 0x00E8 (0x0228 - 0x0310)
class UDemoRecDriver : public UNetDriver
{
public:
	uint8_t                                           UnknownData00[0x20];                           // 0x0228 (0x0020) MISSED OFFSET
	class FString                                      DemoSpectatorClass;                            // 0x0248 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	uint8_t                                           UnknownData01[0xA0];                           // 0x0258 (0x00A0) MISSED OFFSET
	int32_t                                            MaxRewindPoints;                               // 0x02F8 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              RewindPointInterval;                           // 0x0300 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            NumRecentRewindPoints;                         // 0x0304 (0x0004) [0x0000000000004000] (CPF_Config)  
	uint8_t                                           UnknownData02[0x8];                            // 0x0308 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DemoRecDriver");
		}

		return uClassPointer;
	};

};

// Class Engine.ObjectReferencer
// 0x0010 (0x0058 - 0x0068)
class UObjectReferencer : public UObject
{
public:
	class TArray<class UObject*>                       ReferencedObjects;                             // 0x0058 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ObjectReferencer");
		}

		return uClassPointer;
	};

};

// Class Engine.OnlineContentInterface
// 0x0090 (0x0058 - 0x00E8)
class UOnlineContentInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnContentChange__Delegate;                   // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReadContentComplete__Delegate;             // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReadMarketplaceContentListComplete__Delegate;// 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnCheckMarketplaceContentList__Delegate;     // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReadEntitlementsComplete__Delegate;        // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnConsumeEntitlementComplete__Delegate;      // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnContentPurchased__Delegate;                // 0x00B8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReadGameLicenseTypeComplete__Delegate;     // 0x00C8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnGameLicenseTypeChange__Delegate;           // 0x00D8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineContentInterface");
		}

		return uClassPointer;
	};

	void OnGameLicenseTypeChange(EGameLicenseType GameLicenseType);
	void OnReadGameLicenseTypeComplete(EOnlineSubsystemResult Result, EGameLicenseType GameLicenseType);
	void OnContentPurchased(const struct FPlatformUserId& UserId);
	void OnConsumeEntitlementComplete(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result, const class FString& EntitlementId);
	void OnReadEntitlementsComplete(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result);
	void OnCheckMarketplaceContentList(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result, bool bMarketplaceContentListAvailable);
	void OnReadMarketplaceContentListComplete(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result);
	void OnReadContentComplete(bool bWasSuccessful);
	void OnContentChange();
};

// Class Engine.OnlineFeedInterface
// 0x0060 (0x0058 - 0x00B8)
class UOnlineFeedInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnPostFeedStory__Delegate;                   // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnGetUserFeed__Delegate;                     // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnGetUserNews__Delegate;                     // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnGetRecentlyPlayedWith__Delegate;           // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnGetTitleFeed__Delegate;                    // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnGetTitleNews__Delegate;                    // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineFeedInterface");
		}

		return uClassPointer;
	};

	void OnGetTitleNews(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result, const class TArray<struct FFeedStoryRequestData>& ActivityStories);
	void OnGetTitleFeed(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result, const class TArray<struct FFeedStoryRequestData>& ActivityStories);
	void OnGetRecentlyPlayedWith(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result, const class TArray<struct FFeedStoryRequestData>& ActivityStories);
	void OnGetUserNews(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result, const class TArray<struct FFeedStoryRequestData>& ActivityStories);
	void OnGetUserFeed(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result, const class TArray<struct FFeedStoryRequestData>& ActivityStories);
	void OnPostFeedStory(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result, float DelayIntervalInSeconds);
};

// Class Engine.OnlineGameClipInterface
// 0x0000 (0x0058 - 0x0058)
class UOnlineGameClipInterface : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineGameClipInterface");
		}

		return uClassPointer;
	};

};

// Class Engine.OnlineGameInstallationInterface
// 0x0010 (0x0058 - 0x0068)
class UOnlineGameInstallationInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnGameInstallationStatusChange__Delegate;    // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineGameInstallationInterface");
		}

		return uClassPointer;
	};

	void OnGameInstallationStatusChange(bool bIsComplete);
};

// Class Engine.OnlineGameInterface
// 0x00E0 (0x0058 - 0x0138)
class UOnlineGameInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnCreateOnlineGameComplete__Delegate;        // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnUpdateOnlineGameComplete__Delegate;        // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnDestroyOnlineGameComplete__Delegate;       // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnFindOnlineGamesComplete__Delegate;         // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnCancelFindOnlineGamesComplete__Delegate;   // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnQosStatusChanged__Delegate;                // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnJoinOnlineGameComplete__Delegate;          // 0x00B8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnRegisterPlayerComplete__Delegate;          // 0x00C8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnUnregisterPlayerComplete__Delegate;        // 0x00D8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnStartOnlineGameComplete__Delegate;         // 0x00E8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnEndOnlineGameComplete__Delegate;           // 0x00F8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnGameInviteAccepted__Delegate;              // 0x0108 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnGameInviteProcessingStarted__Delegate;     // 0x0118 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnResolveSessionComplete__Delegate;          // 0x0128 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineGameInterface");
		}

		return uClassPointer;
	};

	void OnResolveSessionComplete(bool bWasSuccessful, const struct FOnlineGameSearchResult& Result);
	void OnGameInviteProcessingStarted();
	void OnGameInviteAccepted(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result, struct FOnlineGameSearchResult& InviteResult);
	void OnEndOnlineGameComplete(const struct FName& SessionName, EOnlineSubsystemResult Result);
	void OnStartOnlineGameComplete(const struct FName& SessionName, EOnlineSubsystemResult Result);
	void OnUnregisterPlayerComplete(const struct FName& SessionName, const struct FUniqueNetId& PlayerID, bool bWasSuccessful);
	void OnRegisterPlayerComplete(const struct FName& SessionName, const struct FUniqueNetId& PlayerID, bool bWasSuccessful);
	void OnJoinOnlineGameComplete(const struct FName& SessionName, EOnlineSubsystemResult Result);
	void OnQosStatusChanged(int32_t NumComplete, int32_t NumTotal);
	void OnCancelFindOnlineGamesComplete(bool bWasSuccessful);
	void OnFindOnlineGamesComplete(bool bWasSuccessful);
	void OnDestroyOnlineGameComplete(const struct FName& SessionName, EOnlineSubsystemResult Result);
	void OnUpdateOnlineGameComplete(const struct FName& SessionName, EOnlineSubsystemResult Result);
	void OnCreateOnlineGameComplete(const struct FName& SessionName, EOnlineSubsystemResult Result);
};

// Class Engine.OnlineMatchmakingInterface
// 0x0040 (0x0058 - 0x0098)
class UOnlineMatchmakingInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnMatchmakingComplete__Delegate;             // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnCancelMatchmakingComplete__Delegate;       // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnBecomeHostComplete__Delegate;              // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnWaitForHostComplete__Delegate;             // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineMatchmakingInterface");
		}

		return uClassPointer;
	};

	void OnWaitForHostComplete(bool bWasSuccessful, const struct FName& SessionName);
	void OnBecomeHostComplete(bool bWasSuccessful, const struct FName& SessionName, bool bIsHost);
	void OnCancelMatchmakingComplete(bool bWasSuccessful);
	void OnMatchmakingComplete(EMatchmakingResult Result);
};

// Class Engine.OnlinePartyChatInterface
// 0x0020 (0x0058 - 0x0078)
class UOnlinePartyChatInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnPartyMemberListChanged__Delegate;          // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnPartyStatusChanged__Delegate;              // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlinePartyChatInterface");
		}

		return uClassPointer;
	};

	void OnPartyStatusChanged(const struct FPlatformUserId& UserId, bool bJoinedOrLeft);
	void OnPartyMemberListChanged(const struct FPlatformUserId& UserId, bool bJoinedOrLeft, const class FString& PlayerName, const struct FUniqueNetId& PlayerID);
};

// Class Engine.OnlinePlayerInterface
// 0x0110 (0x0058 - 0x0168)
class UOnlinePlayerInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnMutingChange__Delegate;                    // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnFriendsChange__Delegate;                   // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnShowPlatformUserUIComplete__Delegate;      // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnPlayerDisplayDataChanged__Delegate;        // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReadOnlinePrivilegesComplete__Delegate;    // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnOnlinePrivilegeChanged__Delegate;          // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnLoginStatusChange__Delegate;               // 0x00B8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReadPlayerStorageComplete__Delegate;       // 0x00C8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnWritePlayerStorageComplete__Delegate;      // 0x00D8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReadFriendsComplete__Delegate;             // 0x00E8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnKeyboardInputComplete__Delegate;           // 0x00F8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnSentGameInvite__Delegate;                  // 0x0108 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReceivedGameInvite__Delegate;              // 0x0118 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReadAchievementsComplete__Delegate;        // 0x0128 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnGetPlatformTicketComplete__Delegate;       // 0x0138 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReadProfileImageComplete__Delegate;        // 0x0148 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReadPlayerDisplayDataComplete__Delegate;   // 0x0158 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlinePlayerInterface");
		}

		return uClassPointer;
	};

	void OnReadPlayerDisplayDataComplete(bool bWasSuccessful, const class TArray<struct FOnlinePlayerDisplayData>& DisplayDataList);
	void OnReadProfileImageComplete(const struct FUniqueNetId& PlayerID, bool bWasSuccessful, class UTexture2D* ProfileImage);
	void OnGetPlatformTicketComplete(const struct FPlatformUserId& UserId, bool bWasSuccessful, const class FString& Ticket);
	void OnReadAchievementsComplete();
	void OnReceivedGameInvite(const struct FPlatformUserId& UserId, const class FString& InviterName);
	void OnSentGameInvite(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result);
	void OnKeyboardInputComplete(bool bWasSuccessful, bool bWasCancelled, const class FString& KeyboardResults);
	void OnReadFriendsComplete(const struct FPlatformUserId& UserId, EOnlineSubsystemResult Result, int32_t NumFriendsRead, float DelayIntervalInSeconds);
	void OnWritePlayerStorageComplete(const struct FPlatformUserId& UserId, bool bWasSuccessful);
	void OnReadPlayerStorageComplete(const struct FPlatformUserId& UserId, bool bWasSuccessful);
	void OnLoginStatusChange(const struct FPlatformUserId& UserId, ELoginStatus PreviousStatus, ELoginStatus NewStatus, const struct FUniqueNetId& PreviousId, const struct FUniqueNetId& NewId);
	void OnOnlinePrivilegeChanged(const struct FPlatformUserId& UserId, EOnlineFeature Feature, EFeaturePrivilegeLevel PrivilegeLevel);
	void OnReadOnlinePrivilegesComplete(const struct FPlatformUserId& UserId, bool bWasSuccessful);
	void OnPlayerDisplayDataChanged(const struct FPlatformUserId& UserId, const class FString& DisplayName);
	void OnShowPlatformUserUIComplete(bool bWasSuccessful, const struct FPlatformUserId& ResultId);
	void OnFriendsChange();
	void OnMutingChange();
};

// Class Engine.OnlinePlayerInterfaceEx
// 0x0020 (0x0058 - 0x0078)
class UOnlinePlayerInterfaceEx : public UInterface
{
public:
	struct FScriptDelegate                             __OnShowMembershipMarketplaceUIComplete__Delegate;// 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnUnlockAvatarAwardComplete__Delegate;       // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlinePlayerInterfaceEx");
		}

		return uClassPointer;
	};

	void OnUnlockAvatarAwardComplete(bool bWasSuccessful);
	void OnShowMembershipMarketplaceUIComplete(const struct FPlatformUserId& UserId, EOnlineFeature Feature, EFeaturePrivilegeLevel Level);
};

// Class Engine.OnlineServerInterface
// 0x0060 (0x0058 - 0x00B8)
class UOnlineServerInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnQuarantineComplete__Delegate;              // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnShutdownComplete__Delegate;                // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnWaitForSessionAssignmentComplete__Delegate;// 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnDownloadGameVariantToFileComplete__Delegate;// 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnGetServerTicketComplete__Delegate;         // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnResolveHostNameComplete__Delegate;         // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineServerInterface");
		}

		return uClassPointer;
	};

	void OnResolveHostNameComplete(const class FString& HostName, const class FString& IPAddress);
	void OnGetServerTicketComplete(bool bWasSuccessful, const class FString& Ticket);
	void OnDownloadGameVariantToFileComplete(bool bSuccess, const class FString& Path);
	void OnWaitForSessionAssignmentComplete(bool bSuccess);
	void OnShutdownComplete();
	void OnQuarantineComplete();
};

// Class Engine.OnlineService
// 0x0000 (0x0058 - 0x0058)
class UOnlineService : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineService");
		}

		return uClassPointer;
	};

};

// Class Engine.OnlineStats
// 0x0010 (0x0058 - 0x0068)
class UOnlineStats : public UObject
{
public:
	class TArray<struct FStringIdToStringMapping>      ViewIdMappings;                                // 0x0058 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineStats");
		}

		return uClassPointer;
	};

	struct FName GetViewName(int32_t ViewId);
	bool GetViewId(const struct FName& ViewName, int32_t& ViewId);
};

// Class Engine.OnlineStatsRead
// 0x0050 (0x0068 - 0x00B8)
class UOnlineStatsRead : public UOnlineStats
{
public:
	int32_t                                            ViewId;                                        // 0x0068 (0x0004) [0x0000000000000000]               
	int32_t                                            SortColumnId;                                  // 0x006C (0x0004) [0x0000000000000002] (CPF_Const)   
	class TArray<int32_t>                              ColumnIds;                                     // 0x0070 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	int32_t                                            TotalRowsInView;                               // 0x0080 (0x0004) [0x0000000000000002] (CPF_Const)   
	class TArray<struct FOnlineStatsRow>               Rows;                                          // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FColumnMetaData>               ColumnMappings;                                // 0x0098 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class FString                                      ViewName;                                      // 0x00A8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineStatsRead");
		}

		return uClassPointer;
	};

	int32_t GetRankForPlayer(const struct FUniqueNetId& PlayerID);
	void AddPlayer(const class FString& PlayerName, const struct FUniqueNetId& PlayerID);
	bool IsStatZero(const struct FUniqueNetId& PlayerID, int32_t StatColumnNo);
	bool GetStatValueForPlayerAsString(const struct FUniqueNetId& PlayerID, int32_t StatColumnNo, class FString& StatValue);
	bool SetFloatStatValueForPlayer(const struct FUniqueNetId& PlayerID, int32_t StatColumnNo, float StatValue);
	bool GetFloatStatValueForPlayer(const struct FUniqueNetId& PlayerID, int32_t StatColumnNo, float& StatValue);
	bool SetIntStatValueForPlayer(const struct FUniqueNetId& PlayerID, int32_t StatColumnNo, int32_t StatValue);
	bool GetIntStatValueForPlayer(const struct FUniqueNetId& PlayerID, int32_t StatColumnNo, int32_t& StatValue);
	void eventOnReadComplete();
};

// Class Engine.OnlineStatsWrite
// 0x0048 (0x0068 - 0x00B0)
class UOnlineStatsWrite : public UOnlineStats
{
public:
	class TArray<struct FStringIdToStringMapping>      StatMappings;                                  // 0x0068 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FSettingsProperty>             Properties;                                    // 0x0078 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<int32_t>                              ViewIds;                                       // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            RatingId;                                      // 0x0098 (0x0004) [0x0000000000000002] (CPF_Const)   
	struct FScriptDelegate                             __OnStatsWriteComplete__Delegate;              // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineStatsWrite");
		}

		return uClassPointer;
	};

	void DecrementIntStat(int32_t StatId, int32_t optionalDecBy);
	void DecrementFloatStat(int32_t StatId, float optionalDecBy);
	void IncrementIntStat(int32_t StatId, int32_t optionalIncBy);
	void IncrementFloatStat(int32_t StatId, float optionalIncBy);
	void SetIntStat(int32_t StatId, int32_t Value);
	void SetFloatStat(int32_t StatId, float Value);
	struct FName GetStatName(int32_t StatId);
	bool GetStatId(const struct FName& StatName, int32_t& StatId);
	void OnStatsWriteComplete();
};

// Class Engine.OnlineStatsInterface
// 0x0020 (0x0058 - 0x0078)
class UOnlineStatsInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnReadOnlineStatsComplete__Delegate;         // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnFlushOnlineStatsComplete__Delegate;        // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineStatsInterface");
		}

		return uClassPointer;
	};

	void OnFlushOnlineStatsComplete(const struct FName& SessionName, bool bWasSuccessful);
	void OnReadOnlineStatsComplete(bool bWasSuccessful);
};

// Class Engine.OnlineStreamingInterface
// 0x0010 (0x0058 - 0x0068)
class UOnlineStreamingInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnStreamingStatusUpdated__Delegate;          // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineStreamingInterface");
		}

		return uClassPointer;
	};

	void OnStreamingStatusUpdated(bool bIsStreaming);
};

// Class Engine.OnlineSubsystem
// 0x0178 (0x0058 - 0x01D0)
class UOnlineSubsystem : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                       // 0x0058 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class UOnlinePlayerInterface*                      PlayerInterface_Object;                        // 0x0060 (0x0008) [0x0000000000000000] 
	class UOnlinePlayerInterface*                      PlayerInterface_Interface;                     // 0x0068 (0x0008) [0x0000000000000000]               
	class UOnlinePlayerInterfaceEx*                    PlayerInterfaceEx_Object;                      // 0x0070 (0x0008) [0x0000000000000000] 
	class UOnlinePlayerInterfaceEx*                    PlayerInterfaceEx_Interface;                   // 0x0078 (0x0008) [0x0000000000000000]               
	class UOnlineSystemInterface*                      SystemInterface_Object;                        // 0x0080 (0x0008) [0x0000000000000000] 
	class UOnlineSystemInterface*                      SystemInterface_Interface;                     // 0x0088 (0x0008) [0x0000000000000000]               
	class UOnlineGameInterface*                        GameInterface_Object;                          // 0x0090 (0x0008) [0x0000000000000000] 
	class UOnlineGameInterface*                        GameInterface_Interface;                       // 0x0098 (0x0008) [0x0000000000000000]               
	class UOnlineContentInterface*                     ContentInterface_Object;                       // 0x00A0 (0x0008) [0x0000000000000000] 
	class UOnlineContentInterface*                     ContentInterface_Interface;                    // 0x00A8 (0x0008) [0x0000000000000000]               
	class UOnlineVoiceInterface*                       VoiceInterface_Object;                         // 0x00B0 (0x0008) [0x0000000000000000] 
	class UOnlineVoiceInterface*                       VoiceInterface_Interface;                      // 0x00B8 (0x0008) [0x0000000000000000]               
	class UOnlineStatsInterface*                       StatsInterface_Object;                         // 0x00C0 (0x0008) [0x0000000000000000] 
	class UOnlineStatsInterface*                       StatsInterface_Interface;                      // 0x00C8 (0x0008) [0x0000000000000000]               
	class UOnlinePartyChatInterface*                   PartyChatInterface_Object;                     // 0x00D0 (0x0008) [0x0000000000000000] 
	class UOnlinePartyChatInterface*                   PartyChatInterface_Interface;                  // 0x00D8 (0x0008) [0x0000000000000000]               
	class UOnlineMatchmakingInterface*                 MatchmakingInterface_Object;                   // 0x00E0 (0x0008) [0x0000000000000000] 
	class UOnlineMatchmakingInterface*                 MatchmakingInterface_Interface;                // 0x00E8 (0x0008) [0x0000000000000000]               
	class UOnlineTitleFileInterface*                   TitleFileInterface_Object;                     // 0x00F0 (0x0008) [0x0000000000000000] 
	class UOnlineTitleFileInterface*                   TitleFileInterface_Interface;                  // 0x00F8 (0x0008) [0x0000000000000000]               
	class UOnlineFeedInterface*                        FeedInterface_Object;                          // 0x0100 (0x0008) [0x0000000000000000] 
	class UOnlineFeedInterface*                        FeedInterface_Interface;                       // 0x0108 (0x0008) [0x0000000000000000]               
	class UOnlineServerInterface*                      ServerInterface_Object;                        // 0x0110 (0x0008) [0x0000000000000000] 
	class UOnlineServerInterface*                      ServerInterface_Interface;                     // 0x0118 (0x0008) [0x0000000000000000]               
	class UOnlineStreamingInterface*                   StreamingInterface_Object;                     // 0x0120 (0x0008) [0x0000000000000000] 
	class UOnlineStreamingInterface*                   StreamingInterface_Interface;                  // 0x0128 (0x0008) [0x0000000000000000]               
	class UOnlineGameClipInterface*                    GameClipInterface_Object;                      // 0x0130 (0x0008) [0x0000000000000000] 
	class UOnlineGameClipInterface*                    GameClipInterface_Interface;                   // 0x0138 (0x0008) [0x0000000000000000]               
	class UOnlineGameInstallationInterface*            GameInstallationInterface_Object;              // 0x0140 (0x0008) [0x0000000000000000] 
	class UOnlineGameInstallationInterface*            GameInstallationInterface_Interface;           // 0x0148 (0x0008) [0x0000000000000000]               
	class UOnlineTransactionInterface*                 TransactionInterface_Object;                   // 0x0150 (0x0008) [0x0000000000000000] 
	class UOnlineTransactionInterface*                 TransactionInterface_Interface;                // 0x0158 (0x0008) [0x0000000000000000]               
	class TArray<struct FNamedSession>                 Sessions;                                      // 0x0160 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	uint32_t                                           bUseBuildIdOverride : 1;                       // 0x0170 (0x0004) [0x0000000000004000] [0x00000001] (CPF_Config)
	uint32_t                                           bClearMuteOnUnregister : 1;                    // 0x0170 (0x0004) [0x0000000000004000] [0x00000002] (CPF_Config)
	int32_t                                            BuildIdOverride;                               // 0x0174 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              AsyncMinCompletionTime;                        // 0x0178 (0x0004) [0x0000000000004000] (CPF_Config)  
	class TArray<struct FPointer>                      AsyncTasks;                                    // 0x0180 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FOnlineTitleFileHeader                      TitleFileHeader;                               // 0x0190 (0x0040) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineSubsystem");
		}

		return uClassPointer;
	};

	void SetDebugSpewLevel(int32_t DebugSpewLevel);
	void DebugDrawUserInfo(class UCanvas* C);
	void DumpUserInfo();
	static void DumpNetIds(const class FString& DebugLabel, class TArray<struct FUniqueNetId>& Players);
	void DumpSessionState();
	static void DumpGameSettings(class UOnlineGameSettings* GameSettings);
	int32_t GetBuildUniqueId();
	bool GetSessionId(const struct FName& SessionName, class FString& SessionId);
	bool GetHostAddress(const struct FUniqueNetId& NetId, class FString& HostAddress);
	bool GetPlatformUserId(const struct FUniqueNetId& NetId, struct FPlatformUserId& UserId);
	bool GetUniquePlayerId(const struct FPlatformUserId& UserId, struct FUniqueNetId& PlayerID);
	bool eventSetGameInstallationInterface(class UObject* InOnlineGameInstallationInterface);
	bool eventSetGameClipInterface(class UObject* InGameClipInterface);
	bool eventSetStreamingInterface(class UObject* InStreamingInterface);
	bool eventSetServerInterface(class UObject* InServerInterface);
	bool eventSetTransactionInterface(class UObject* InTransactionInterface);
	bool eventSetFeedInterface(class UObject* NewInterface);
	bool eventSetTitleFileInterface(class UObject* NewInterface);
	bool eventSetMatchmakingInterface(class UObject* NewInterface);
	bool eventSetPartyChatInterface(class UObject* NewInterface);
	bool eventSetStatsInterface(class UObject* NewInterface);
	bool eventSetVoiceInterface(class UObject* NewInterface);
	bool eventSetContentInterface(class UObject* NewInterface);
	bool eventSetGameInterface(class UObject* NewInterface);
	bool eventSetSystemInterface(class UObject* NewInterface);
	bool eventSetPlayerInterfaceEx(class UObject* NewInterface);
	bool eventSetPlayerInterface(class UObject* NewInterface);
};

// Class Engine.OnlineSystemInterface
// 0x0060 (0x0058 - 0x00B8)
class UOnlineSystemInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnLinkStatusChange__Delegate;                // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnExternalUIChange__Delegate;                // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnControllerChange__Delegate;                // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnPatchCheckComplete__Delegate;              // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnServiceStatusChange__Delegate;             // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnSystemResume__Delegate;                    // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineSystemInterface");
		}

		return uClassPointer;
	};

	void OnSystemResume();
	void OnServiceStatusChange(bool bIsConnected);
	void OnPatchCheckComplete(bool bWasSuccessful, bool bPatchAvailable, const struct FQWord& PlatformError);
	void OnControllerChange(const struct FPlatformUserId& UserId, bool bIsConnected);
	void OnExternalUIChange(bool bIsOpening);
	void OnLinkStatusChange(bool bIsConnected);
};

// Class Engine.OnlineTitleFileInterface
// 0x0010 (0x0058 - 0x0068)
class UOnlineTitleFileInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnReadTitleFileComplete__Delegate;           // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineTitleFileInterface");
		}

		return uClassPointer;
	};

	void OnReadTitleFileComplete(bool bWasSuccessful);
};

// Class Engine.OnlineTransactionInterface
// 0x0040 (0x0058 - 0x0098)
class UOnlineTransactionInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnTransactionInitialization__Delegate;       // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnTransactionAuthorization__Delegate;        // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnTransactionFinalization__Delegate;         // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnTransactionCancellation__Delegate;         // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineTransactionInterface");
		}

		return uClassPointer;
	};

	void OnTransactionCancellation(const struct FPlatformUserId& UserId, const struct FQWord& OrderId, bool bCancelled);
	void OnTransactionFinalization(const struct FPlatformUserId& UserId, const struct FQWord& OrderId, bool bFinalized);
	void OnTransactionAuthorization(const struct FQWord& OrderId, bool bAuthorized);
	void OnTransactionInitialization(const struct FPlatformUserId& UserId, const class FString& ItemId, bool bInitialized, const class FString& ErrorCode);
};

// Class Engine.OnlineVoiceInterface
// 0x0010 (0x0058 - 0x0068)
class UOnlineVoiceInterface : public UInterface
{
public:
	struct FScriptDelegate                             __OnPlayerTalkingStateChange__Delegate;        // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineVoiceInterface");
		}

		return uClassPointer;
	};

	void OnPlayerTalkingStateChange(const struct FUniqueNetId& Player, bool bIsTalking);
};

// Class Engine.PackageMapLevel
// 0x0008 (0x0108 - 0x0110)
class UPackageMapLevel : public UPackageMap
{
public:
	uint8_t                                           UnknownData00[0x8];                            // 0x0108 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PackageMapLevel");
		}

		return uClassPointer;
	};

};

// Class Engine.PackageMapSeekFree
// 0x0000 (0x0110 - 0x0110)
class UPackageMapSeekFree : public UPackageMapLevel
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PackageMapSeekFree");
		}

		return uClassPointer;
	};

};

// Class Engine.PackageReferencer
// 0x0010 (0x0058 - 0x0068)
class UPackageReferencer : public UObject
{
public:
	class TArray<class FString>                        PackageNames;                                  // 0x0058 (0x0010) [0x0000000004400001] (CPF_Edit | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PackageReferencer");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleEmitter
// 0x0048 (0x0058 - 0x00A0)
class UParticleEmitter : public UObject
{
public:
	struct FName                                       EmitterName;                                   // 0x0058 (0x0008) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            SubUVDataOffset;                               // 0x0060 (0x0004) [0x0000000000002000] (CPF_Transient)
	EEmitterRenderMode                                 EmitterRenderMode;                             // 0x0064 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EEmitterLODFlag                                    LODFlags[0x4];                                 // 0x0065 (0x0004) [0x0000000000000000]               
	uint32_t                                           bDisableOnPS4 : 1;                             // 0x006C (0x0004) [0x0000000800000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDisableOnXboxOne : 1;                         // 0x006C (0x0004) [0x0000000800000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bDisableOnPC : 1;                              // 0x006C (0x0004) [0x0000000800000001] [0x00000004] (CPF_Edit)
	uint32_t                                           ConvertedModules : 1;                          // 0x006C (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bCollapsed : 1;                                // 0x006C (0x0004) [0x0000000800000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bIsSoloing : 1;                                // 0x006C (0x0004) [0x0000000000002000] [0x00000020] (CPF_Transient)
	uint32_t                                           bCookedOut : 1;                                // 0x006C (0x0004) [0x0000000000000000] [0x00000040] 
	class TArray<class UParticleLODLevel*>             LODLevels;                                     // 0x0070 (0x0010) [0x0000000004400008] (CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	int32_t                                            PeakActiveParticles;                           // 0x0080 (0x0004) [0x0000000000000000]               
	int32_t                                            InitialAllocationCount;                        // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MediumDetailSpawnRateScale;                    // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LowDetailSpawnRateScale;                       // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       Layer;                                         // 0x0090 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UFlexContainer*                              FlexContainerTemplate;                         // 0x0098 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleEmitter");
		}

		return uClassPointer;
	};

	float GetMaxLifespan(float InComponentDelay);
};

// Class Engine.ParticleSpriteEmitter
// 0x0000 (0x00A0 - 0x00A0)
class UParticleSpriteEmitter : public UParticleEmitter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleSpriteEmitter");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleLODLevel
// 0x00A0 (0x0058 - 0x00F8)
class UParticleLODLevel : public UObject
{
public:
	uint32_t                                           bEnabled : 1;                                  // 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           ConvertedModules : 1;                          // 0x0058 (0x0004) [0x0000000000000000] [0x00000002] 
	class UParticleModuleRequired*                     RequiredModule;                                // 0x0060 (0x0008) [0x0000000004400008] (CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class UParticleModule*>               Modules;                                       // 0x0068 (0x0010) [0x0000000004400008] (CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class UParticleModule*                             TypeDataModule;                                // 0x0078 (0x0008) [0x0000000000000008] (CPF_ExportObject)
	class UParticleModuleSpawn*                        SpawnModule;                                   // 0x0080 (0x0008) [0x0000000000000008] (CPF_ExportObject)
	class UParticleModuleEventGenerator*               EventGenerator;                                // 0x0088 (0x0008) [0x0000000000000008] (CPF_ExportObject)
	class TArray<class UISpawningModule*>              SpawningModules;                               // 0x0090 (0x0010) [0x0000000000001000] (CPF_Native)  
	class TArray<class UParticleModule*>               SpawnModules;                                  // 0x00A0 (0x0010) [0x0000000000001000] (CPF_Native)  
	class TArray<class UParticleModule*>               UpdateModules;                                 // 0x00B0 (0x0010) [0x0000000000001000] (CPF_Native)  
	class TArray<class UParticleModule*>               TransitionNotifyModules;                       // 0x00C0 (0x0010) [0x0000000000001000] (CPF_Native)  
	class TArray<class UParticleModuleOrbit*>          OrbitModules;                                  // 0x00D0 (0x0010) [0x0000000000001000] (CPF_Native)  
	class TArray<class UParticleModuleEventReceiverBase*> EventReceiverModules;                          // 0x00E0 (0x0010) [0x0000000000001000] (CPF_Native)  
	int32_t                                            PeakActiveParticles;                           // 0x00F0 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleLODLevel");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModule
// 0x0008 (0x0058 - 0x0060)
class UParticleModule : public UObject
{
public:
	uint8_t                                            LODValidity;                                   // 0x0058 (0x0001) [0x0000000000000002] (CPF_Const)   
	uint32_t                                           bSpawnModule : 1;                              // 0x005C (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bUpdateModule : 1;                             // 0x005C (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bTransitionNotifyModule : 1;                   // 0x005C (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bCurvesAsColor : 1;                            // 0x005C (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           b3DDrawMode : 1;                               // 0x005C (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bSupported3DDrawMode : 1;                      // 0x005C (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bEnabled : 1;                                  // 0x005C (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bEditable : 1;                                 // 0x005C (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           LODDuplicate : 1;                              // 0x005C (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bSupportsRandomSeed : 1;                       // 0x005C (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bRequiresLoopingNotification : 1;              // 0x005C (0x0004) [0x0000000000000000] [0x00000400] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModule");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleAccelerationBase
// 0x0008 (0x0060 - 0x0068)
class UParticleModuleAccelerationBase : public UParticleModule
{
public:
	uint32_t                                           bAlwaysInWorldSpace : 1;                       // 0x0060 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleAccelerationBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleAcceleration
// 0x0030 (0x0068 - 0x0098)
class UParticleModuleAcceleration : public UParticleModuleAccelerationBase
{
public:
	struct FRawDistributionVector                      Acceleration;                                  // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bApplyOwnerScale : 1;                          // 0x0090 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleAcceleration");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleAccelerationOverLifetime
// 0x0028 (0x0068 - 0x0090)
class UParticleModuleAccelerationOverLifetime : public UParticleModuleAccelerationBase
{
public:
	struct FRawDistributionVector                      AccelOverLife;                                 // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleAccelerationOverLifetime");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleAttractorBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleAttractorBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleAttractorBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleAttractorLine
// 0x0068 (0x0060 - 0x00C8)
class UParticleModuleAttractorLine : public UParticleModuleAttractorBase
{
public:
	struct FVector                                     EndPoint0;                                     // 0x0060 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     EndPoint1;                                     // 0x006C (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       Range;                                         // 0x0078 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       Strength;                                      // 0x00A0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleAttractorLine");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleAttractorParticle
// 0x0068 (0x0060 - 0x00C8)
class UParticleModuleAttractorParticle : public UParticleModuleAttractorBase
{
public:
	struct FName                                       EmitterName;                                   // 0x0060 (0x0008) [0x0000000002000009] (CPF_Edit | CPF_ExportObject | CPF_NoClear)
	struct FRawDistributionFloat                       Range;                                         // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bStrengthByDistance : 1;                       // 0x0090 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAffectBaseVelocity : 1;                       // 0x0090 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bRenewSource : 1;                              // 0x0090 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bInheritSourceVel : 1;                         // 0x0090 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	struct FRawDistributionFloat                       Strength;                                      // 0x0098 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	EAttractorParticleSelectionMethod                  SelectionMethod;                               // 0x00C0 (0x0001) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            LastSelIndex;                                  // 0x00C4 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleAttractorParticle");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleAttractorPoint
// 0x0080 (0x0060 - 0x00E0)
class UParticleModuleAttractorPoint : public UParticleModuleAttractorBase
{
public:
	struct FRawDistributionVector                      Position;                                      // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       Range;                                         // 0x0088 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       Strength;                                      // 0x00B0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           StrengthByDistance : 1;                        // 0x00D8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAffectBaseVelocity : 1;                       // 0x00D8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bOverrideVelocity : 1;                         // 0x00D8 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bUseWorldSpacePosition : 1;                    // 0x00D8 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bApplyOwnerScale : 1;                          // 0x00D8 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleAttractorPoint");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleBeamBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleBeamBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleBeamBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleBeam
// 0x0040 (0x0060 - 0x00A0)
class UParticleModuleBeam : public UParticleModuleBeamBase
{
public:
	struct FPointer                                    VfTable_IISpawningModule;                      // 0x0060 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	EBeamMethod                                        BeamMethod;                                    // 0x0068 (0x0001) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            TextureTile;                                   // 0x006C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TextureTileDistance;                           // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Speed;                                         // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       Distance;                                      // 0x0078 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleBeam");
		}

		return uClassPointer;
	};

	bool IsEnabled();
	int32_t GetMaximumBurstCount();
	float GetEstimatedSpawnRate();
	float GetMaximumSpawnRate();
};

// Class Engine.ParticleModuleBeamNoise
// 0x00F0 (0x0060 - 0x0150)
class UParticleModuleBeamNoise : public UParticleModuleBeamBase
{
public:
	int32_t                                            Frequency;                                     // 0x0060 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Frequency_LowRange;                            // 0x0064 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionVector                      NoiseRange;                                    // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       NoiseRangeScale;                               // 0x0090 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bNRScaleEmitterTime : 1;                       // 0x00B8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bSmooth : 1;                                   // 0x00B8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bNoiseLock : 1;                                // 0x00B8 (0x0004) [0x0000000000000002] [0x00000004] (CPF_Const)
	uint32_t                                           bOscillate : 1;                                // 0x00B8 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bUseNoiseTangents : 1;                         // 0x00B8 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bTargetNoise : 1;                              // 0x00B8 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bApplyNoiseScale : 1;                          // 0x00B8 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	struct FRawDistributionVector                      NoiseSpeed;                                    // 0x00C0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	float                                              NoiseLockRadius;                               // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              NoiseLockTime;                                 // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              NoiseTension;                                  // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       NoiseTangentStrength;                          // 0x00F8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	int32_t                                            NoiseTessellation;                             // 0x0120 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FrequencyDistance;                             // 0x0124 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       NoiseScale;                                    // 0x0128 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleBeamNoise");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleBeamSource
// 0x0088 (0x0060 - 0x00E8)
class UParticleModuleBeamSource : public UParticleModuleBeamBase
{
public:
	EBeam2SourceTargetMethod                           SourceMethod;                                  // 0x0060 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EBeam2SourceTargetTangentMethod                    SourceTangentMethod;                           // 0x0061 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       SourceName;                                    // 0x0064 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bSourceAbsolute : 1;                           // 0x006C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bLockSource : 1;                               // 0x006C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bLockSourceTangent : 1;                        // 0x006C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bLockSourceStength : 1;                        // 0x006C (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	struct FRawDistributionVector                      Source;                                        // 0x0070 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      SourceTangent;                                 // 0x0098 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       SourceStrength;                                // 0x00C0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleBeamSource");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleBeamTarget
// 0x0098 (0x0060 - 0x00F8)
class UParticleModuleBeamTarget : public UParticleModuleBeamBase
{
public:
	EBeam2SourceTargetMethod                           TargetMethod;                                  // 0x0060 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EBeam2SourceTargetTangentMethod                    TargetTangentMethod;                           // 0x0061 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       TargetName;                                    // 0x0064 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionVector                      Target;                                        // 0x0070 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bTargetAbsolute : 1;                           // 0x0098 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bLockTarget : 1;                               // 0x0098 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bLockTargetTangent : 1;                        // 0x0098 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bLockTargetStength : 1;                        // 0x0098 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	struct FRawDistributionVector                      TargetTangent;                                 // 0x00A0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       TargetStrength;                                // 0x00C8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	float                                              LockRadius;                                    // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleBeamTarget");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleBeamTrace
// 0x0038 (0x00F8 - 0x0130)
class UParticleModuleBeamTrace : public UParticleModuleBeamTarget
{
public:
	struct FRawDistributionVector                      TraceDirection;                                // 0x00F8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	float                                              MaxTraceDistance;                              // 0x0120 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RetraceDelay;                                  // 0x0124 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MaxTraceEvents;                                // 0x0128 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bAlwaysGenerateEvent : 1;                      // 0x012C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseLocalSpace : 1;                            // 0x012C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bTraceWorld : 1;                               // 0x012C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bTraceActors : 1;                              // 0x012C (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bTraceBlockers : 1;                            // 0x012C (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bTraceMaterials : 1;                           // 0x012C (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bTraceProjectiles : 1;                         // 0x012C (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bTracePhysicsVolumes : 1;                      // 0x012C (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bTraceComplexCollision : 1;                    // 0x012C (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bTraceLightProjectiles : 1;                    // 0x012C (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bIgnoreNonBlockingTriggers : 1;                // 0x012C (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleBeamTrace");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleCameraBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleCameraBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleCameraBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleCameraOffset
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleCameraOffset : public UParticleModuleCameraBase
{
public:
	struct FRawDistributionVector                      CameraOffset;                                  // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bSpawnTimeOnly : 1;                            // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bApplyOwnerScale : 1;                          // 0x0088 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	EParticleCameraOffsetUpdateMethod                  UpdateMethod;                                  // 0x008C (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleCameraOffset");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleCollisionBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleCollisionBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleCollisionBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleCollision
// 0x00E0 (0x0060 - 0x0140)
class UParticleModuleCollision : public UParticleModuleCollisionBase
{
public:
	struct FRawDistributionVector                      DampingFactor;                                 // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      DampingFactorRotation;                         // 0x0088 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       MaxCollisions;                                 // 0x00B0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	EParticleCollisionComplete                         CollisionCompletionOption;                     // 0x00D8 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bApplyPhysics : 1;                             // 0x00DC (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bPawnsDoNotDecrementCount : 1;                 // 0x00DC (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bOnlyVerticalNormalsDecrementCount : 1;        // 0x00DC (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bDropDetail : 1;                               // 0x00DC (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bCollideOnlyIfVisible : 1;                     // 0x00DC (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	struct FRawDistributionFloat                       ParticleMass;                                  // 0x00E0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	float                                              DirScalar;                                     // 0x0108 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              VerticalFudgeFactor;                           // 0x010C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       DelayAmount;                                   // 0x0110 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	float                                              MaxCollisionDistance;                          // 0x0138 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleCollision");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleCollisionActor
// 0x0018 (0x0140 - 0x0158)
class UParticleModuleCollisionActor : public UParticleModuleCollision
{
public:
	class TArray<struct FName>                         ActorsToCollideWith;                           // 0x0140 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bCheckPawnCollisions : 1;                      // 0x0150 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleCollisionActor");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleColorBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleColorBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleColorBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleColor
// 0x0058 (0x0060 - 0x00B8)
class UParticleModuleColor : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                      StartColor;                                    // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       StartAlpha;                                    // 0x0088 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bClampAlpha : 1;                               // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleColor");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleColor_Seeded
// 0x0020 (0x00B8 - 0x00D8)
class UParticleModuleColor_Seeded : public UParticleModuleColor
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x00B8 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleColor_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleColorByParameter
// 0x0010 (0x0060 - 0x0070)
class UParticleModuleColorByParameter : public UParticleModuleColorBase
{
public:
	struct FName                                       ColorParam;                                    // 0x0060 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FColor                                      DefaultColor;                                  // 0x0068 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleColorByParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleColorOverLife
// 0x0058 (0x0060 - 0x00B8)
class UParticleModuleColorOverLife : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                      ColorOverLife;                                 // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       AlphaOverLife;                                 // 0x0088 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bClampAlpha : 1;                               // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bColorOverParticles : 1;                       // 0x00B0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleColorOverLife");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleColorScaleOverDensity
// 0x0050 (0x0060 - 0x00B0)
class UParticleModuleColorScaleOverDensity : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                      ColorScaleOverDensity;                         // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       AlphaScaleOverDensity;                         // 0x0088 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleColorScaleOverDensity");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleColorScaleOverLife
// 0x0058 (0x0060 - 0x00B8)
class UParticleModuleColorScaleOverLife : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                      ColorScaleOverLife;                            // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       AlphaScaleOverLife;                            // 0x0088 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bEmitterTime : 1;                              // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleColorScaleOverLife");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleEventBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleEventBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleEventBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleEventGenerator
// 0x0010 (0x0060 - 0x0070)
class UParticleModuleEventGenerator : public UParticleModuleEventBase
{
public:
	class TArray<struct FParticleEvent_GenerateInfo>   Events;                                        // 0x0060 (0x0010) [0x0000000002400009] (CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_NoClear)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleEventGenerator");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleEventGeneratorDecal
// 0x0030 (0x0070 - 0x00A0)
class UParticleModuleEventGeneratorDecal : public UParticleModuleEventGenerator
{
public:
	class TArray<class UMaterialInterface*>            DecalMaterials;                                // 0x0070 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              DecalWidth;                                    // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DecalHeight;                                   // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SizeVariance;                                  // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DecalThickness;                                // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DecalLifeSpan;                                 // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   DecalBlendRange;                               // 0x0094 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bNoClip : 1;                                   // 0x009C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bProjectOnTerrain : 1;                         // 0x009C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bProjectOnSkeletalMeshes : 1;                  // 0x009C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleEventGeneratorDecal");
		}

		return uClassPointer;
	};

	void eventSpawnDecal(class AActor* HitActor, class UPrimitiveComponent* HitComponent, const struct FVector& HitLocation, const struct FVector& HitNormal);
};

// Class Engine.ParticleModuleEventReceiverBase
// 0x0010 (0x0060 - 0x0070)
class UParticleModuleEventReceiverBase : public UParticleModuleEventBase
{
public:
	EParticleEventType                                 EventGeneratorType;                            // 0x0060 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       EventName;                                     // 0x0064 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bIsAsyncReceiver : 1;                          // 0x006C (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleEventReceiverBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleEventReceiverAkEvent
// 0x0010 (0x0070 - 0x0080)
class UParticleModuleEventReceiverAkEvent : public UParticleModuleEventReceiverBase
{
public:
	class UAkEvent*                                    AkEvent;                                       // 0x0070 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUsePSysLocation : 1;                          // 0x0078 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleEventReceiverAkEvent");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleEventReceiverConstruct
// 0x0008 (0x0070 - 0x0078)
class UParticleModuleEventReceiverConstruct : public UParticleModuleEventReceiverBase
{
public:
	struct FName                                       ConstructEventName;                            // 0x0070 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleEventReceiverConstruct");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleEventReceiverEnabler
// 0x0010 (0x0070 - 0x0080)
class UParticleModuleEventReceiverEnabler : public UParticleModuleEventReceiverBase
{
public:
	class TArray<struct FParticleEventReceiverEnabler_Info> Targets;                                       // 0x0070 (0x0010) [0x0000000002400009] (CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_NoClear)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleEventReceiverEnabler");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleEventReceiverKillParticles
// 0x0008 (0x0070 - 0x0078)
class UParticleModuleEventReceiverKillParticles : public UParticleModuleEventReceiverBase
{
public:
	uint32_t                                           bStopSpawning : 1;                             // 0x0070 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleEventReceiverKillParticles");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleEventReceiverSpawn
// 0x0058 (0x0070 - 0x00C8)
class UParticleModuleEventReceiverSpawn : public UParticleModuleEventReceiverBase
{
public:
	struct FRawDistributionFloat                       SpawnCount;                                    // 0x0070 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bUseParticleTime : 1;                          // 0x0098 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUsePSysLocation : 1;                          // 0x0098 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bInheritVelocity : 1;                          // 0x0098 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bInheritRotation : 1;                          // 0x0098 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	struct FRawDistributionVector                      InheritVelocityScale;                          // 0x00A0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleEventReceiverSpawn");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleEventReceiverSpawn_Seeded
// 0x0020 (0x00C8 - 0x00E8)
class UParticleModuleEventReceiverSpawn_Seeded : public UParticleModuleEventReceiverSpawn
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x00C8 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleEventReceiverSpawn_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleForceFieldBase
// 0x0008 (0x0060 - 0x0068)
class UParticleModuleForceFieldBase : public UParticleModule
{
public:
	class UNxForceFieldComponent*                      ForceField;                                    // 0x0060 (0x0008) [0x0000000004080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleForceFieldBase");
		}

		return uClassPointer;
	};

	class UNxForceFieldComponent* eventGetForceFieldInstance(const struct FVector& Location);
};

// Class Engine.ParticleModuleForceFieldCylindrical
// 0x0000 (0x0068 - 0x0068)
class UParticleModuleForceFieldCylindrical : public UParticleModuleForceFieldBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleForceFieldCylindrical");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleForceFieldGeneric
// 0x0000 (0x0068 - 0x0068)
class UParticleModuleForceFieldGeneric : public UParticleModuleForceFieldBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleForceFieldGeneric");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleForceFieldRadial
// 0x0000 (0x0068 - 0x0068)
class UParticleModuleForceFieldRadial : public UParticleModuleForceFieldBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleForceFieldRadial");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleForceFieldTornado
// 0x0000 (0x0068 - 0x0068)
class UParticleModuleForceFieldTornado : public UParticleModuleForceFieldBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleForceFieldTornado");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleKillBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleKillBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleKillBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleKillBox
// 0x0058 (0x0060 - 0x00B8)
class UParticleModuleKillBox : public UParticleModuleKillBase
{
public:
	struct FRawDistributionVector                      LowerLeftCorner;                               // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      UpperRightCorner;                              // 0x0088 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bAbsolute : 1;                                 // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bKillInside : 1;                               // 0x00B0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleKillBox");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleKillHeight
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleKillHeight : public UParticleModuleKillBase
{
public:
	struct FRawDistributionFloat                       Height;                                        // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bAbsolute : 1;                                 // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bFloor : 1;                                    // 0x0088 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bApplyPSysScale : 1;                           // 0x0088 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleKillHeight");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLifetimeBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleLifetimeBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLifetimeBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLifetime
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleLifetime : public UParticleModuleLifetimeBase
{
public:
	struct FRawDistributionFloat                       Lifetime;                                      // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLifetime");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLifetime_Seeded
// 0x0020 (0x0088 - 0x00A8)
class UParticleModuleLifetime_Seeded : public UParticleModuleLifetime
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0088 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLifetime_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLightBase
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleLightBase : public UParticleModule
{
public:
	struct FParticleModuleLightConfig                  LightConfiguration;                            // 0x0060 (0x002C) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bInheritViewProperties : 1;                    // 0x008C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLightBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLight
// 0x0080 (0x0090 - 0x0110)
class UParticleModuleLight : public UParticleModuleLightBase
{
public:
	int32_t                                            InstanceLimit;                                 // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       StartBrightness;                               // 0x0098 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       StartFalloffExponent;                          // 0x00C0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       StartRadius;                                   // 0x00E8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLight");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLight_Seeded
// 0x0020 (0x0110 - 0x0130)
class UParticleModuleLight_Seeded : public UParticleModuleLight
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0110 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLight_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLightOverLifetime
// 0x0080 (0x0090 - 0x0110)
class UParticleModuleLightOverLifetime : public UParticleModuleLightBase
{
public:
	int32_t                                            InstanceLimit;                                 // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUseRelativeTime : 1;                          // 0x0094 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FRawDistributionFloat                       BrightnessOverLife;                            // 0x0098 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       FalloffExponentOverLife;                       // 0x00C0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       RadiusOverLife;                                // 0x00E8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLightOverLifetime");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleLocationBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocation
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleLocation : public UParticleModuleLocationBase
{
public:
	struct FRawDistributionVector                      StartLocation;                                 // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocation");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocation_Seeded
// 0x0020 (0x0088 - 0x00A8)
class UParticleModuleLocation_Seeded : public UParticleModuleLocation
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0088 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocation_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationBoneSocket
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleLocationBoneSocket : public UParticleModuleLocationBase
{
public:
	ELocationBoneSocketSource                          SourceType;                                    // 0x0060 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ELocationBoneSocketSelectionMethod                 SelectionMethod;                               // 0x0061 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     UniversalOffset;                               // 0x0064 (0x000C) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FLocationBoneSocketInfo>       SourceLocations;                               // 0x0070 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bUpdatePositionEachFrame : 1;                  // 0x0080 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bOrientMeshEmitters : 1;                       // 0x0080 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	struct FName                                       SkelMeshActorParamName;                        // 0x0084 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationBoneSocket");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationDirect
// 0x00A0 (0x0060 - 0x0100)
class UParticleModuleLocationDirect : public UParticleModuleLocationBase
{
public:
	struct FRawDistributionVector                      Location;                                      // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      LocationOffset;                                // 0x0088 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      ScaleFactor;                                   // 0x00B0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      Direction;                                     // 0x00D8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationDirect");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationEmitter
// 0x0018 (0x0060 - 0x0078)
class UParticleModuleLocationEmitter : public UParticleModuleLocationBase
{
public:
	struct FName                                       EmitterName;                                   // 0x0060 (0x0008) [0x0000000002000009] (CPF_Edit | CPF_ExportObject | CPF_NoClear)
	ELocationEmitterSelectionMethod                    SelectionMethod;                               // 0x0068 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           InheritSourceVelocity : 1;                     // 0x006C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bInheritSourceRotation : 1;                    // 0x006C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bInheritSourceMeshRotation : 1;                // 0x006C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bInheritSourceMeshRotationRate : 1;            // 0x006C (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	float                                              InheritSourceVelocityScale;                    // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              InheritSourceRotationScale;                    // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationEmitter");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationEmitterDirect
// 0x0010 (0x0060 - 0x0070)
class UParticleModuleLocationEmitterDirect : public UParticleModuleLocationBase
{
public:
	struct FName                                       EmitterName;                                   // 0x0060 (0x0008) [0x0000000002000009] (CPF_Edit | CPF_ExportObject | CPF_NoClear)
	uint32_t                                           bEvenDistribution : 1;                         // 0x0068 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bInheritParentRotation : 1;                    // 0x0068 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bAtSpawnOnly : 1;                              // 0x0068 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	float                                              RelativeSourceIndex;                           // 0x006C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationEmitterDirect");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationIceChunks
// 0x0018 (0x0060 - 0x0078)
class UParticleModuleLocationIceChunks : public UParticleModuleLocationBase
{
public:
	struct FVector                                     UniversalOffset;                               // 0x0060 (0x000C) [0x0000000000000001] (CPF_Edit)    
	ELocationIceChunkSelectionMethod                   SelectionMethod;                               // 0x006C (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       IceChunkShatterIDParamName;                    // 0x0070 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationIceChunks");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationOffset
// 0x0038 (0x0060 - 0x0098)
class UParticleModuleLocationOffset : public UParticleModuleLocationBase
{
public:
	uint32_t                                           bInWorldSpace : 1;                             // 0x0060 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bApplyOwnerScale : 1;                          // 0x0060 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           Absolute : 1;                                  // 0x0060 (0x0004) [0x0000000000000009] [0x00000004] (CPF_Edit | CPF_ExportObject)
	uint32_t                                           bSpawnTimeOnly : 1;                            // 0x0060 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	struct FRawDistributionVector                      LocationOffset;                                // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	EParticleLocationOffsetUpdateMethod                UpdateMethod;                                  // 0x0090 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationOffset");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationPrimitiveBase
// 0x0058 (0x0060 - 0x00B8)
class UParticleModuleLocationPrimitiveBase : public UParticleModuleLocationBase
{
public:
	uint32_t                                           Positive_X : 1;                                // 0x0060 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           Positive_Y : 1;                                // 0x0060 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           Positive_Z : 1;                                // 0x0060 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           Negative_X : 1;                                // 0x0060 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           Negative_Y : 1;                                // 0x0060 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           Negative_Z : 1;                                // 0x0060 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           SurfaceOnly : 1;                               // 0x0060 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           Velocity : 1;                                  // 0x0060 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	struct FRawDistributionFloat                       VelocityScale;                                 // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      StartLocation;                                 // 0x0090 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationPrimitiveBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationPrimitiveCylinder
// 0x0060 (0x00B8 - 0x0118)
class UParticleModuleLocationPrimitiveCylinder : public UParticleModuleLocationPrimitiveBase
{
public:
	uint32_t                                           RadialVelocity : 1;                            // 0x00B8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FRawDistributionFloat                       StartRadius;                                   // 0x00C0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       StartHeight;                                   // 0x00E8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	ECylinderHeightAxis                                HeightAxis;                                    // 0x0110 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationPrimitiveCylinder");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationPrimitiveCylinder_Seeded
// 0x0020 (0x0118 - 0x0138)
class UParticleModuleLocationPrimitiveCylinder_Seeded : public UParticleModuleLocationPrimitiveCylinder
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0118 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationPrimitiveCylinder_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationPrimitiveSphere
// 0x0028 (0x00B8 - 0x00E0)
class UParticleModuleLocationPrimitiveSphere : public UParticleModuleLocationPrimitiveBase
{
public:
	struct FRawDistributionFloat                       StartRadius;                                   // 0x00B8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationPrimitiveSphere");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationPrimitiveSphere_Seeded
// 0x0020 (0x00E0 - 0x0100)
class UParticleModuleLocationPrimitiveSphere_Seeded : public UParticleModuleLocationPrimitiveSphere
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x00E0 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationPrimitiveSphere_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationStaticMesh
// 0x00D0 (0x00B8 - 0x0188)
class UParticleModuleLocationStaticMesh : public UParticleModuleLocationPrimitiveBase
{
public:
	uint32_t                                           bDoNothingOnFail : 1;                          // 0x00B8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseConvexDecompParameters : 1;                // 0x00B8 (0x0004) [0x0000000800000001] [0x00000002] (CPF_Edit)
	int32_t                                            SuggestedVoxelGridByteSize;                    // 0x00BC (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MeshLocation;                                  // 0x00C0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MeshRotation;                                  // 0x00CC (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MeshScale;                                     // 0x00D8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionVector                      StartRotation;                                 // 0x00E8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      StartScale;                                    // 0x0110 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FMeshVoxelInfo                              VoxelInfo;                                     // 0x0138 (0x0050) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationStaticMesh");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationStaticMesh_Seeded
// 0x0020 (0x0188 - 0x01A8)
class UParticleModuleLocationStaticMesh_Seeded : public UParticleModuleLocationStaticMesh
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0188 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationStaticMesh_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleLocationSkelVertSurface
// 0x0058 (0x0060 - 0x00B8)
class UParticleModuleLocationSkelVertSurface : public UParticleModuleLocationBase
{
public:
	ELocationSkelVertSurfaceSource                     SourceType;                                    // 0x0060 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     UniversalOffset;                               // 0x0064 (0x000C) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUpdatePositionEachFrame : 1;                  // 0x0070 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bOrientMeshEmitters : 1;                       // 0x0070 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bEnforceNormalCheck : 1;                       // 0x0070 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	struct FName                                       SkelMeshActorParamName;                        // 0x0074 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FName>                         ValidAssociatedBones;                          // 0x0080 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FVector                                     NormalToCompare;                               // 0x0090 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              NormalCheckToleranceDegrees;                   // 0x009C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              NormalCheckTolerance;                          // 0x00A0 (0x0004) [0x0000000000000000]               
	class TArray<int32_t>                              ValidMaterialIndices;                          // 0x00A8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleLocationSkelVertSurface");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSourceMovement
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleSourceMovement : public UParticleModuleLocationBase
{
public:
	struct FRawDistributionVector                      SourceMovementScale;                           // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSourceMovement");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleMaterialBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleMaterialBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleMaterialBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleMaterialByParameter
// 0x0020 (0x0060 - 0x0080)
class UParticleModuleMaterialByParameter : public UParticleModuleMaterialBase
{
public:
	class TArray<struct FName>                         MaterialParameters;                            // 0x0060 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UMaterialInterface*>            DefaultMaterials;                              // 0x0070 (0x0010) [0x0000000000400041] (CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleMaterialByParameter");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleMeshMaterial
// 0x0010 (0x0060 - 0x0070)
class UParticleModuleMeshMaterial : public UParticleModuleMaterialBase
{
public:
	class TArray<class UMaterialInterface*>            MeshMaterials;                                 // 0x0060 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleMeshMaterial");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleOrbitBase
// 0x0008 (0x0060 - 0x0068)
class UParticleModuleOrbitBase : public UParticleModule
{
public:
	uint32_t                                           bUseEmitterTime : 1;                           // 0x0060 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleOrbitBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleOrbit
// 0x0098 (0x0068 - 0x0100)
class UParticleModuleOrbit : public UParticleModuleOrbitBase
{
public:
	EOrbitChainMode                                    ChainMode;                                     // 0x0068 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionVector                      OffsetAmount;                                  // 0x0070 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FOrbitOptions                               OffsetOptions;                                 // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionVector                      RotationAmount;                                // 0x00A0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FOrbitOptions                               RotationOptions;                               // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionVector                      RotationRateAmount;                            // 0x00D0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FOrbitOptions                               RotationRateOptions;                           // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleOrbit");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleOrbit_Seeded
// 0x0020 (0x0100 - 0x0120)
class UParticleModuleOrbit_Seeded : public UParticleModuleOrbit
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0100 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleOrbit_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleOrientationBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleOrientationBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleOrientationBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleOrientationAxisLock
// 0x0008 (0x0060 - 0x0068)
class UParticleModuleOrientationAxisLock : public UParticleModuleOrientationBase
{
public:
	EParticleAxisLock                                  LockAxisFlags;                                 // 0x0060 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleOrientationAxisLock");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleParameterBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleParameterBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleParameterBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleParameterDynamic
// 0x0010 (0x0060 - 0x0070)
class UParticleModuleParameterDynamic : public UParticleModuleParameterBase
{
public:
	class TArray<struct FEmitterDynamicParameter>      DynamicParams;                                 // 0x0060 (0x0010) [0x0000000000480041] (CPF_Edit | CPF_EditConstArray | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleParameterDynamic");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleParameterDynamic_Seeded
// 0x0020 (0x0070 - 0x0090)
class UParticleModuleParameterDynamic_Seeded : public UParticleModuleParameterDynamic
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0070 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleParameterDynamic_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleRequired
// 0x0078 (0x0060 - 0x00D8)
class UParticleModuleRequired : public UParticleModule
{
public:
	class UMaterialInterface*                          Material;                                      // 0x0060 (0x0008) [0x0000000000000001] (CPF_Edit)    
	EParticleScreenAlignment                           ScreenAlignment;                               // 0x0068 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EParticleSortMode                                  SortMode;                                      // 0x0069 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EParticleBurstMethod                               ParticleBurstMethod;                           // 0x006A (0x0001) [0x0000000000000000]               
	EParticleSubUVInterpMethod                         InterpolationMethod;                           // 0x006B (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUseLocalSpace : 1;                            // 0x006C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bKillOnDeactivate : 1;                         // 0x006C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bKillOnCompleted : 1;                          // 0x006C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bRequiresSorting : 1;                          // 0x006C (0x0004) [0x0000000020000000] [0x00000008]  CPF_Deprecated)
	uint32_t                                           bUseLegacyEmitterTime : 1;                     // 0x006C (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bExcludeFromBoundsCalculation : 1;             // 0x006C (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bEmitterDurationUseRange : 1;                  // 0x006C (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bDurationRecalcEachLoop : 1;                   // 0x006C (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bEmitterDelayUseRange : 1;                     // 0x006C (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bDelayFirstLoopOnly : 1;                       // 0x006C (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bScaleUV : 1;                                  // 0x006C (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	uint32_t                                           bDirectUV : 1;                                 // 0x006C (0x0004) [0x0000000000000000] [0x00000800] 
	float                                              EmitterDuration;                               // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              EmitterDurationLow;                            // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            EmitterLoops;                                  // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       SpawnRate;                                     // 0x0080 (0x0028) [0x0000000000480000] (CPF_Component | CPF_NeedCtorLink)
	class TArray<struct FParticleBurst>                BurstList;                                     // 0x00A8 (0x0010) [0x0000000002480008] (CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_NoClear)
	float                                              EmitterDelay;                                  // 0x00B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              EmitterDelayLow;                               // 0x00BC (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            SubImages_Horizontal;                          // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            SubImages_Vertical;                            // 0x00C4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RandomImageTime;                               // 0x00C8 (0x0004) [0x0000000000000000]               
	int32_t                                            RandomImageChanges;                            // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MaxDrawCount;                                  // 0x00D0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleRequired");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleRotationBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleRotationBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleRotationBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleMeshRotation
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleMeshRotation : public UParticleModuleRotationBase
{
public:
	struct FRawDistributionVector                      StartRotation;                                 // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bInheritParent : 1;                            // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleMeshRotation");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleMeshRotation_Seeded
// 0x0020 (0x0090 - 0x00B0)
class UParticleModuleMeshRotation_Seeded : public UParticleModuleMeshRotation
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0090 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleMeshRotation_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleMeshRotationOverLife
// 0x0058 (0x0060 - 0x00B8)
class UParticleModuleMeshRotationOverLife : public UParticleModuleRotationBase
{
public:
	struct FRawDistributionFloat                       RotationOverLife;                              // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      OrientationOverLife;                           // 0x0088 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bUseRelativeTime : 1;                          // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleMeshRotationOverLife");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleRotation
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleRotation : public UParticleModuleRotationBase
{
public:
	struct FRawDistributionFloat                       StartRotation;                                 // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleRotation");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleRotation_Seeded
// 0x0020 (0x0088 - 0x00A8)
class UParticleModuleRotation_Seeded : public UParticleModuleRotation
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0088 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleRotation_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleRotationOverBeam
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleRotationOverBeam : public UParticleModuleRotationBase
{
public:
	struct FRawDistributionFloat                       RotationOverBeam;                              // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bFullRotationPerParticle : 1;                  // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleRotationOverBeam");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleRotationOverLifetime
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleRotationOverLifetime : public UParticleModuleRotationBase
{
public:
	struct FRawDistributionFloat                       RotationOverLife;                              // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           Scale : 1;                                     // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bIncrement : 1;                                // 0x0088 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bUseRelativeTime : 1;                          // 0x0088 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleRotationOverLifetime");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleRotationRateBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleRotationRateBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleRotationRateBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleMeshRotationRate
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleMeshRotationRate : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionVector                      StartRotationRate;                             // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleMeshRotationRate");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleMeshRotationRate_Seeded
// 0x0020 (0x0088 - 0x00A8)
class UParticleModuleMeshRotationRate_Seeded : public UParticleModuleMeshRotationRate
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0088 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleMeshRotationRate_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleMeshRotationRateMultiplyLife
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleMeshRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionVector                      LifeMultiplier;                                // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleMeshRotationRateMultiplyLife");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleMeshRotationRateOverLife
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleMeshRotationRateOverLife : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionVector                      RotRate;                                       // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bScaleRotRate : 1;                             // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleMeshRotationRateOverLife");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleRotationRate
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleRotationRate : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionFloat                       StartRotationRate;                             // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleRotationRate");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleRotationRate_Seeded
// 0x0020 (0x0088 - 0x00A8)
class UParticleModuleRotationRate_Seeded : public UParticleModuleRotationRate
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0088 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleRotationRate_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleRotationRateMultiplyLife
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionFloat                       LifeMultiplier;                                // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleRotationRateMultiplyLife");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSizeBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleSizeBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSizeBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSize
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleSize : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      StartSize;                                     // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSize");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSize_Seeded
// 0x0020 (0x0088 - 0x00A8)
class UParticleModuleSize_Seeded : public UParticleModuleSize
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0088 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSize_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSizeMultiplyLife
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleSizeMultiplyLife : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      LifeMultiplier;                                // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           MultiplyX : 1;                                 // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           MultiplyY : 1;                                 // 0x0088 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           MultiplyZ : 1;                                 // 0x0088 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSizeMultiplyLife");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSizeMultiplyVelocity
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleSizeMultiplyVelocity : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      VelocityMultiplier;                            // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           MultiplyX : 1;                                 // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           MultiplyY : 1;                                 // 0x0088 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           MultiplyZ : 1;                                 // 0x0088 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSizeMultiplyVelocity");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSizeScale
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleSizeScale : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      SizeScale;                                     // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           EnableX : 1;                                   // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           EnableY : 1;                                   // 0x0088 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           EnableZ : 1;                                   // 0x0088 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSizeScale");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSizeScaleByTime
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleSizeScaleByTime : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      SizeScaleByTime;                               // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bEnableX : 1;                                  // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bEnableY : 1;                                  // 0x0088 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bEnableZ : 1;                                  // 0x0088 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSizeScaleByTime");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSizeScaleOverDensity
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleSizeScaleOverDensity : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      SizeScaleOverDensity;                          // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSizeScaleOverDensity");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSpawnBase
// 0x0010 (0x0060 - 0x0070)
class UParticleModuleSpawnBase : public UParticleModule
{
public:
	struct FPointer                                    VfTable_IISpawningModule;                      // 0x0060 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	uint32_t                                           bProcessSpawnRate : 1;                         // 0x0068 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bProcessBurstList : 1;                         // 0x0068 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSpawnBase");
		}

		return uClassPointer;
	};

	bool IsEnabled();
	int32_t GetMaximumBurstCount();
	float GetEstimatedSpawnRate();
	float GetMaximumSpawnRate();
};

// Class Engine.ParticleModuleSpawn
// 0x0070 (0x0070 - 0x00E0)
class UParticleModuleSpawn : public UParticleModuleSpawnBase
{
public:
	struct FRawDistributionFloat                       Rate;                                          // 0x0070 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       RateScale;                                     // 0x0098 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	EParticleBurstMethod                               ParticleBurstMethod;                           // 0x00C0 (0x0001) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FParticleBurst>                BurstList;                                     // 0x00C8 (0x0010) [0x0000000002480009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_NoClear)
	uint32_t                                           BurstOnceOnLoop : 1;                           // 0x00D8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSpawn");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSpawnPerUnit
// 0x0040 (0x0070 - 0x00B0)
class UParticleModuleSpawnPerUnit : public UParticleModuleSpawnBase
{
public:
	float                                              UnitScalar;                                    // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       SpawnPerUnit;                                  // 0x0078 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bIgnoreSpawnRateWhenMoving : 1;                // 0x00A0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bIgnoreMovementAlongX : 1;                     // 0x00A0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bIgnoreMovementAlongY : 1;                     // 0x00A0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bIgnoreMovementAlongZ : 1;                     // 0x00A0 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	float                                              MovementTolerance;                             // 0x00A4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxFrameDistance;                              // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSpawnPerUnit");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleStoreSpawnTimeBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleStoreSpawnTimeBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleStoreSpawnTimeBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleStoreSpawnTime
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleStoreSpawnTime : public UParticleModuleStoreSpawnTimeBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleStoreSpawnTime");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSubUVBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleSubUVBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSubUVBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSubUV
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleSubUV : public UParticleModuleSubUVBase
{
public:
	struct FRawDistributionFloat                       SubImageIndex;                                 // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bUseRealTime : 1;                              // 0x0088 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              LastKnownTimeDilation;                         // 0x008C (0x0004) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSubUV");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSubUVMovie
// 0x0038 (0x0090 - 0x00C8)
class UParticleModuleSubUVMovie : public UParticleModuleSubUV
{
public:
	uint32_t                                           bUseEmitterTime : 1;                           // 0x0090 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FRawDistributionFloat                       FrameRate;                                     // 0x0098 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	int32_t                                            StartingFrame;                                 // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSubUVMovie");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSubUVDirect
// 0x0050 (0x0060 - 0x00B0)
class UParticleModuleSubUVDirect : public UParticleModuleSubUVBase
{
public:
	struct FRawDistributionVector                      SubUVPosition;                                 // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      SubUVSize;                                     // 0x0088 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSubUVDirect");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleSubUVSelect
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleSubUVSelect : public UParticleModuleSubUVBase
{
public:
	struct FRawDistributionVector                      SubImageSelect;                                // 0x0060 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleSubUVSelect");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTrailBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleTrailBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTrailBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTrailNoise
// 0x0080 (0x0060 - 0x00E0)
class UParticleModuleTrailNoise : public UParticleModuleTrailBase
{
public:
	EParticleTrailNoiseType                            NoiseType;                                     // 0x0060 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bInWorldSpace : 1;                             // 0x0064 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseFramePosition : 1;                         // 0x0064 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bApplyOwnerScale : 1;                          // 0x0064 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bFrequencyUniformSeed : 1;                     // 0x0064 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bFrequencyOverEmitterTime : 1;                 // 0x0064 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bFrequencyOverLength : 1;                      // 0x0064 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bFrequencyIsRelative : 1;                      // 0x0064 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bPhaseUniformSeed : 1;                         // 0x0064 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bPhaseOverEmitterTime : 1;                     // 0x0064 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bPhaseOverLength : 1;                          // 0x0064 (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bPhaseIsContinuous : 1;                        // 0x0064 (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	uint32_t                                           bAmplitudeUniformSeed : 1;                     // 0x0064 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bAmplitudeOverEmitterTime : 1;                 // 0x0064 (0x0004) [0x0000000000000001] [0x00001000] (CPF_Edit)
	uint32_t                                           bAmplitudeOverLength : 1;                      // 0x0064 (0x0004) [0x0000000000000001] [0x00002000] (CPF_Edit)
	struct FRawDistributionVector                      Frequency;                                     // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      Phase;                                         // 0x0090 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      Amplitude;                                     // 0x00B8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTrailNoise");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTrailSource
// 0x0060 (0x0060 - 0x00C0)
class UParticleModuleTrailSource : public UParticleModuleTrailBase
{
public:
	ETrail2SourceMethod                                SourceMethod;                                  // 0x0060 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EParticleSourceSelectionMethod                     SelectionMethod;                               // 0x0061 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       SourceName;                                    // 0x0064 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       SourceStrength;                                // 0x0070 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bLockSourceStength : 1;                        // 0x0098 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bInheritRotation : 1;                          // 0x0098 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	int32_t                                            SourceOffsetCount;                             // 0x009C (0x0004) [0x0000000020000000]  CPF_Deprecated)
	class TArray<struct FVector>                       SourceOffsetDefaults;                          // 0x00A0 (0x0010) [0x0000000020400000] (CPF_NeedCtorLink | CPF_Deprecated)
	struct FVector                                     SourceOffset;                                  // 0x00B0 (0x000C) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTrailSource");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTrailSpawn
// 0x0010 (0x0060 - 0x0070)
class UParticleModuleTrailSpawn : public UParticleModuleTrailBase
{
public:
	class UDistributionFloatParticleParameter*         SpawnDistanceMap;                              // 0x0060 (0x0008) [0x0000000006080009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_NoClear | CPF_EditInline)
	float                                              MinSpawnVelocity;                              // 0x0068 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTrailSpawn");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTrailTaper
// 0x0030 (0x0060 - 0x0090)
class UParticleModuleTrailTaper : public UParticleModuleTrailBase
{
public:
	ETrailTaperMethod                                  TaperMethod;                                   // 0x0060 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       TaperFactor;                                   // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTrailTaper");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTypeDataBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleTypeDataBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTypeDataBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTypeDataApex
// 0x0010 (0x0060 - 0x0070)
class UParticleModuleTypeDataApex : public UParticleModuleTypeDataBase
{
public:
	class UApexGenericAsset*                           ApexIOFX;                                      // 0x0060 (0x0008) [0x0000000000000000]               
	class UApexGenericAsset*                           ApexEmitter;                                   // 0x0068 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTypeDataApex");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTypeDataBeam2
// 0x00C8 (0x0060 - 0x0128)
class UParticleModuleTypeDataBeam2 : public UParticleModuleTypeDataBase
{
public:
	EBeam2Method                                       BeamMethod;                                    // 0x0060 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EBeam2Interpolation                                BeamInterpolation;                             // 0x0061 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EBeamTaperMethod                                   TaperMethod;                                   // 0x0062 (0x0001) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            TextureTile;                                   // 0x0064 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TextureTileDistance;                           // 0x0068 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Sheets;                                        // 0x006C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Speed;                                         // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MinPoints;                                     // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            UnitsPerPoint;                                 // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MaxPoints;                                     // 0x007C (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            InterpolationPoints;                           // 0x0080 (0x0004) [0x0000000020000000]  CPF_Deprecated)
	uint32_t                                           bAlwaysOn : 1;                                 // 0x0084 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAllowWander : 1;                              // 0x0084 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           RenderGeometry : 1;                            // 0x0084 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           RenderDirectLine : 1;                          // 0x0084 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           RenderLines : 1;                               // 0x0084 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           RenderTessellation : 1;                        // 0x0084 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	int32_t                                            UpVectorStepSize;                              // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TangentScalePower;                             // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FRawDistributionVector>        SplineMidpoints;                               // 0x0090 (0x0010) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	float                                              TessellationSplineTension;                     // 0x00A0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       BranchParentName;                              // 0x00A4 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FRawDistributionFloat                       Distance;                                      // 0x00B0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       TaperFactor;                                   // 0x00D8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       TaperScale;                                    // 0x0100 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTypeDataBeam2");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTypeDataMesh
// 0x0020 (0x0060 - 0x0080)
class UParticleModuleTypeDataMesh : public UParticleModuleTypeDataBase
{
public:
	class UStaticMesh*                                 Mesh;                                          // 0x0060 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           CastShadows : 1;                               // 0x0068 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           DoCollisions : 1;                              // 0x0068 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bAllowMotionBlur : 1;                          // 0x0068 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bOverrideMaterial : 1;                         // 0x0068 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bCameraFacing : 1;                             // 0x0068 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bApplyParticleRotationAsSpin : 1;              // 0x0068 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	EMeshScreenAlignment                               MeshAlignment;                                 // 0x006C (0x0001) [0x0000000000000001] (CPF_Edit)    
	EParticleAxisLock                                  AxisLockOption;                                // 0x006D (0x0001) [0x0000000000000001] (CPF_Edit)    
	EMeshCameraFacingUpAxis                            CameraFacingUpAxisOption;                      // 0x006E (0x0001) [0x0000000020000000]  CPF_Deprecated)
	EMeshCameraFacingOptions                           CameraFacingOption;                            // 0x006F (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              Pitch;                                         // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Roll;                                          // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Yaw;                                           // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTypeDataMesh");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTypeDataMeshPhysX
// 0x0028 (0x0080 - 0x00A8)
class UParticleModuleTypeDataMeshPhysX : public UParticleModuleTypeDataMesh
{
public:
	class UPhysXParticleSystem*                        PhysXParSys;                                   // 0x0080 (0x0008) [0x0000000000000001] (CPF_Edit)    
	EPhysXMeshRotationMethod                           PhysXRotationMethod;                           // 0x0088 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              RotationCoefficient;                           // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FPhysXEmitterVerticalLodProperties          VerticalLod;                                   // 0x0090 (0x0010) [0x0000000000000001] (CPF_Edit)    
	float                                              ZOffset;                                       // 0x00A0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTypeDataMeshPhysX");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTypeDataPhysX
// 0x0028 (0x0060 - 0x0088)
class UParticleModuleTypeDataPhysX : public UParticleModuleTypeDataBase
{
public:
	class UPhysXParticleSystem*                        PhysXParSys;                                   // 0x0060 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FPhysXEmitterVerticalLodProperties          VerticalLod;                                   // 0x0068 (0x0010) [0x0000000000000001] (CPF_Edit)    
	float                                              SPHSmoothScreenRadius;                         // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SPHSmoothDepthRadius;                          // 0x007C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SPHCutoffThickness;                            // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTypeDataPhysX");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTypeDataRibbon
// 0x0020 (0x0060 - 0x0080)
class UParticleModuleTypeDataRibbon : public UParticleModuleTypeDataBase
{
public:
	int32_t                                            SheetsPerTrail;                                // 0x0060 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDeadTrailsOnDeactivate : 1;                   // 0x0064 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDeadTrailsOnSourceLoss : 1;                   // 0x0064 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bClipSourceSegement : 1;                       // 0x0064 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bRenderGeometry : 1;                           // 0x0064 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bRenderSpawnPoints : 1;                        // 0x0064 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bRenderTangents : 1;                           // 0x0064 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bRenderTessellation : 1;                       // 0x0064 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bEnableTangentDiffInterpScale : 1;             // 0x0064 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	ETrailsRenderAxisOption                            RenderAxis;                                    // 0x0068 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              TangentSpawningScalar;                         // 0x006C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TilingDistance;                                // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DistanceTessellationStepSize;                  // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TangentTessellationScalar;                     // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TessellationSplineTension;                     // 0x007C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTypeDataRibbon");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleVelocityBase
// 0x0008 (0x0060 - 0x0068)
class UParticleModuleVelocityBase : public UParticleModule
{
public:
	uint32_t                                           bInWorldSpace : 1;                             // 0x0060 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bApplyOwnerScale : 1;                          // 0x0060 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleVelocityBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleVelocity
// 0x0050 (0x0068 - 0x00B8)
class UParticleModuleVelocity : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionVector                      StartVelocity;                                 // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       StartVelocityRadial;                           // 0x0090 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleVelocity");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleVelocity_Seeded
// 0x0020 (0x00B8 - 0x00D8)
class UParticleModuleVelocity_Seeded : public UParticleModuleVelocity
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x00B8 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleVelocity_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleVelocityCurlNoise
// 0x0088 (0x0068 - 0x00F0)
class UParticleModuleVelocityCurlNoise : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionVector                      NoiseScale;                                    // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           bScaleUniformSeed : 1;                         // 0x0090 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bScaleOverEmitterTime : 1;                     // 0x0090 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bOffsetUniformSeed : 1;                        // 0x0090 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bOffsetOverEmitterTime : 1;                    // 0x0090 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bOffsetIsContinuous : 1;                       // 0x0090 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bStrengthUniformSeed : 1;                      // 0x0090 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bStrengthOverEmitterTime : 1;                  // 0x0090 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bHighFidelity : 1;                             // 0x0090 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	struct FRawDistributionVector                      NoiseOffset;                                   // 0x0098 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionVector                      NoiseStrength;                                 // 0x00C0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	float                                              HighFidelityFPS;                               // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AccumulatedDeltaTime;                          // 0x00EC (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleVelocityCurlNoise");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleVelocityInheritParent
// 0x0028 (0x0068 - 0x0090)
class UParticleModuleVelocityInheritParent : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionVector                      Scale;                                         // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleVelocityInheritParent");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleVelocityOverLifetime
// 0x0030 (0x0068 - 0x0098)
class UParticleModuleVelocityOverLifetime : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionVector                      VelOverLife;                                   // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	uint32_t                                           Absolute : 1;                                  // 0x0090 (0x0004) [0x0000000000000009] [0x00000001] (CPF_Edit | CPF_ExportObject)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleVelocityOverLifetime");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleVelocityVortex
// 0x00F0 (0x0068 - 0x0158)
class UParticleModuleVelocityVortex : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionFloat                       AxialStrength;                                 // 0x0068 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       RadialStrength;                                // 0x0090 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       RotationalStrength;                            // 0x00B8 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       DistanceFalloff;                               // 0x00E0 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	struct FRawDistributionFloat                       WorldSpaceRelaxation;                          // 0x0108 (0x0028) [0x0000000000480001] (CPF_Edit | CPF_Component | CPF_NeedCtorLink)
	float                                              WorldSpaceRelaxSensitivity;                    // 0x0130 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     CenterOffset;                                  // 0x0134 (0x000C) [0x0000000000000001] (CPF_Edit)    
	EVortexAxisAlignment                               AxisAlignment;                                 // 0x0140 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDontInheritCenterOffset : 1;                  // 0x0144 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseCenterFocalPoint : 1;                      // 0x0144 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bUseEmitterTime : 1;                           // 0x0144 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bUseWorldSpaceRelaxation : 1;                  // 0x0144 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	struct FVector                                     EffectiveCenterOffset;                         // 0x0148 (0x000C) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleVelocityVortex");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleVelocityVortex_Seeded
// 0x0020 (0x0158 - 0x0178)
class UParticleModuleVelocityVortex_Seeded : public UParticleModuleVelocityVortex
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                // 0x0158 (0x0020) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleVelocityVortex_Seeded");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleEventSendToGame
// 0x0000 (0x0058 - 0x0058)
class UParticleModuleEventSendToGame : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleEventSendToGame");
		}

		return uClassPointer;
	};

	void DoEvent(struct FVector& InCollideDirection, struct FVector& InHitLocation, struct FVector& InHitNormal, struct FName& InBoneName);
};

// Class Engine.ParticleSystem
// 0x00F8 (0x0058 - 0x0150)
class UParticleSystem : public UObject
{
public:
	EParticleSystemUpdateMode                          SystemUpdateMode;                              // 0x0058 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EParticleSystemLODMethod                           LODMethod;                                     // 0x0059 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EParticleSystemOcclusionBoundsMethod               OcclusionBoundsMethod;                         // 0x005A (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              UpdateTime_FPS;                                // 0x005C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              UpdateTime_Delta;                              // 0x0060 (0x0004) [0x0000000000000000]               
	float                                              WarmupTime;                                    // 0x0064 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bEnableThreading : 1;                          // 0x0068 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bLit : 1;                                      // 0x0068 (0x0004) [0x0000000020000002] [0x00000002] (CPF_Const | CPF_Deprecated)
	uint32_t                                           bOrientZAxisTowardCamera : 1;                  // 0x0068 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bFullResolution : 1;                           // 0x0068 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bRegenerateLODDuplicate : 1;                   // 0x0068 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bUseFixedRelativeBoundingBox : 1;              // 0x0068 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bShouldResetPeakCounts : 1;                    // 0x0068 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bHasPhysics : 1;                               // 0x0068 (0x0004) [0x0000000000002000] [0x00000080] (CPF_Transient)
	uint32_t                                           bUseRealtimeThumbnail : 1;                     // 0x0068 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           ThumbnailImageOutOfDate : 1;                   // 0x0068 (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bUseDelayRange : 1;                            // 0x0068 (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	uint32_t                                           bLoadIfPhysXLevel0 : 1;                        // 0x0068 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bLoadIfPhysXLevel1 : 1;                        // 0x0068 (0x0004) [0x0000000000000001] [0x00001000] (CPF_Edit)
	uint32_t                                           bLoadIfPhysXLevel2 : 1;                        // 0x0068 (0x0004) [0x0000000000000001] [0x00002000] (CPF_Edit)
	class TArray<class UParticleEmitter*>              Emitters;                                      // 0x0070 (0x0010) [0x0000000004400008] (CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class UParticleSystemComponent*                    PreviewComponent;                              // 0x0080 (0x0008) [0x0000000004082008] (CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	class UInterpCurveEdSetup*                         CurveEdSetup;                                  // 0x0088 (0x0008) [0x0000000000000008] (CPF_ExportObject)
	float                                              LODDistanceCheckTime;                          // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<float>                                LODDistances;                                  // 0x0098 (0x0010) [0x0000000000400041] (CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink)
	float                                              MaxDrawDistance;                               // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FParticleSystemLOD>            LODSettings;                                   // 0x00B0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FBox                                        FixedRelativeBoundingBox;                      // 0x00C0 (0x001C) [0x0000000000000001] (CPF_Edit)    
	float                                              SecondsBeforeInactive;                         // 0x00DC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Delay;                                         // 0x00E0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DelayLow;                                      // 0x00E4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     MacroUVPosition;                               // 0x00E8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              MacroUVRadius;                                 // 0x00F4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FBox                                        CustomOcclusionBounds;                         // 0x00F8 (0x001C) [0x0000000000000001] (CPF_Edit)    
	class UAkEvent*                                    StartAudioEvent;                               // 0x0118 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UAkEvent*                                    StopAudioEvent;                                // 0x0120 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UAkEvent*                                    StartLoopingAudioEvent;                        // 0x0128 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UAkEvent*                                    StopLoopingAudioEvent;                         // 0x0130 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              fAudioDelaySeconds;                            // 0x0138 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UParticleSystem*                             PhysxParticleSystemRef;                        // 0x0140 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              CachedMaxLifeSpan;                             // 0x0148 (0x0004) [0x0000000000003000] (CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleSystem");
		}

		return uClassPointer;
	};

	float GetMaxLifespan(float InComponentDelay);
	bool SetLODDistance(int32_t LODLevelIndex, float InDistance);
	void SetCurrentLODMethod(EParticleSystemLODMethod InMethod);
	float GetLODDistance(int32_t LODLevelIndex);
	int32_t GetLODLevelCount();
	EParticleSystemLODMethod GetCurrentLODMethod();
	class UParticleSystem* EffectiveParticleSystemAfterPhysXMutator();
};

// Class Engine.PatchScriptCommandlet
// 0x0000 (0x00B0 - 0x00B0)
class UPatchScriptCommandlet : public UCommandlet
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PatchScriptCommandlet");
		}

		return uClassPointer;
	};

};

// Class Engine.PersistentGameDataManager
// 0x0010 (0x0058 - 0x0068)
class UPersistentGameDataManager : public UObject
{
public:
	class TArray<class UPersistentSequenceData*>       SequencesWithPersistentData;                   // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PersistentGameDataManager");
		}

		return uClassPointer;
	};

};

// Class Engine.PersistentSequenceData
// 0x0060 (0x0058 - 0x00B8)
class UPersistentSequenceData : public UObject
{
public:
	struct FName                                       LevelPackageName;                              // 0x0058 (0x0008) [0x0000000000000000]               
	struct FName                                       SequenceName;                                  // 0x0060 (0x0008) [0x0000000000000000]               
	uint8_t                                           UnknownData00[0x50];                           // 0x0068 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.PersistentSequenceData.SavedSubsequenceData

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PersistentSequenceData");
		}

		return uClassPointer;
	};

};

// Class Engine.PhysicalMaterial
// 0x0080 (0x0058 - 0x00D8)
class UPhysicalMaterial : public UObject
{
public:
	struct FPointer                                    PhysXMaterial;                                 // 0x0058 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)
	int32_t                                            MaterialIndex;                                 // 0x0060 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              Friction;                                      // 0x0064 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Restitution;                                   // 0x0068 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bForceConeFriction : 1;                        // 0x006C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bEnableAnisotropicFriction : 1;                // 0x006C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	struct FVector                                     AnisoFrictionDir;                              // 0x0070 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              FrictionV;                                     // 0x007C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Density;                                       // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AngularDamping;                                // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LinearDamping;                                 // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MagneticResponse;                              // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WindResponse;                                  // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ImpactThreshold;                               // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ImpactReFireDelay;                             // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UParticleSystem*                             ImpactEffect;                                  // 0x00A0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UImpactDefinition*                           ImpactDefinition;                              // 0x00A8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              SlideThreshold;                                // 0x00B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SlideReFireDelay;                              // 0x00B4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UParticleSystem*                             SlideEffect;                                   // 0x00B8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UImpactDefinition*                           SlideImpactDefinition;                         // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UPhysicalMaterial*                           Parent;                                        // 0x00C8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UPhysicalMaterialPropertyBase*               PhysicalMaterialProperty;                      // 0x00D0 (0x0008) [0x0000000004400009] (CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PhysicalMaterial");
		}

		return uClassPointer;
	};

	class UPhysicalMaterialPropertyBase* GetPhysicalMaterialProperty(class UClass* DesiredClass);
	struct FPhysEffectInfo FindPhysEffectInfo(EPhysEffectType Type);
};

// Class Engine.PhysicalMaterialPropertyBase
// 0x0000 (0x0058 - 0x0058)
class UPhysicalMaterialPropertyBase : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PhysicalMaterialPropertyBase");
		}

		return uClassPointer;
	};

};

// Class Engine.PhysicsAsset
// 0x0090 (0x0058 - 0x00E8)
class UPhysicsAsset : public UObject
{
public:
	class TArray<class URB_BodySetup*>                 BodySetup;                                     // 0x0058 (0x0010) [0x000000000440000A] (CPF_Const | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	struct FMap_Mirror                                 BodySetupIndexMap;                             // 0x0068 (0x0050) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<int32_t>                              BoundsBodies;                                  // 0x00B8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<class URB_ConstraintSetup*>           ConstraintSetup;                               // 0x00C8 (0x0010) [0x000000000440000A] (CPF_Const | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class UPhysicsAssetInstance*                       DefaultInstance;                               // 0x00D8 (0x0008) [0x000000000440000A] (CPF_Const | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	float                                              Mass;                                          // 0x00E0 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PhysicsAsset");
		}

		return uClassPointer;
	};

	int32_t FindBodyIndex(const struct FName& BodyName);
};

// Class Engine.PhysicsAssetInstance
// 0x00A8 (0x0058 - 0x0100)
class UPhysicsAssetInstance : public UObject
{
public:
	class AActor*                                      Owner;                                         // 0x0058 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FPointer                                    PhysXScene;                                    // 0x0060 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)
	int32_t                                            RootBodyIndex;                                 // 0x0068 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class TArray<class URB_BodyInstance*>              Bodies;                                        // 0x0070 (0x0010) [0x000000000440000A] (CPF_Const | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	class TArray<class URB_ConstraintInstance*>        Constraints;                                   // 0x0080 (0x0010) [0x000000000440000A] (CPF_Const | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	struct FMap_Mirror                                 CollisionDisableTable;                         // 0x0090 (0x0050) [0x0000000000001002] (CPF_Const | CPF_Native)
	float                                              LinearSpringScale;                             // 0x00E0 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              LinearDampingScale;                            // 0x00E4 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              LinearForceLimitScale;                         // 0x00E8 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              AngularSpringScale;                            // 0x00EC (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              AngularDampingScale;                           // 0x00F0 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              AngularForceLimitScale;                        // 0x00F4 (0x0004) [0x0000000000000002] (CPF_Const)   
	uint32_t                                           bInitBodies : 1;                               // 0x00F8 (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PhysicsAssetInstance");
		}

		return uClassPointer;
	};

	class URB_ConstraintInstance* FindConstraintInstance(const struct FName& ConName, class UPhysicsAsset* InAsset);
	class URB_BodyInstance* FindBodyInstance(const struct FName& BodyName, class UPhysicsAsset* InAsset);
	void SetFullAnimWeightBonesFixed(bool bNewFixed, class USkeletalMeshComponent* SkelMesh);
	void SetFullAnimWeightBlockRigidBody(bool bNewBlockRigidBody, class USkeletalMeshComponent* SkelMesh);
	void SetNamedBodiesBlockRigidBody(bool bNewBlockRigidBody, const class TArray<struct FName>& BoneNames, class USkeletalMeshComponent* SkelMesh);
	void SetNamedRBBoneSprings(bool bEnable, const class TArray<struct FName>& BoneNames, float InBoneLinearSpring, float InBoneAngularSpring, class USkeletalMeshComponent* SkelMeshComp);
	void SetAllRBBoneSprings(bool bEnable, float InBoneLinearSpring, float InBoneAngularSpring, class USkeletalMeshComponent* SkelMeshComp, bool optionalKSkipFullAnimWeightBodies);
	void SetNamedMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, const class TArray<struct FName>& BoneNames, class USkeletalMeshComponent* SkelMeshComp, bool optionalBSetOtherBodiesToComplement);
	void SetNamedMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, const class TArray<struct FName>& BoneNames, class USkeletalMeshComponent* SkelMeshComp, bool optionalBSetOtherBodiesToComplement);
	void SetAllMotorsAngularDriveTypeAndParams(bool bEnableSwingDrive, bool bEnableTwistDrive, EConstraintDriveChange PositionDriveState, EConstraintDriveChange VelocityDriveState, float InSpring, float InDamping, float InForceLimit, class USkeletalMeshComponent* optionalSkelMesh, bool optionalBSkipFullAnimWeightBodies);
	void SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, class USkeletalMeshComponent* optionalSkelMesh, bool optionalBSkipFullAnimWeightBodies);
	void SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, class USkeletalMeshComponent* SkelMeshComp, bool optionalBSkipFullAnimWeightBodies);
	void SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, class USkeletalMeshComponent* optionalSkelMesh, bool optionalBSkipFullAnimWeightBodies);
	void ForceAllBodiesBelowUnfixed(class UPhysicsAsset* InAsset, class USkeletalMeshComponent* InSkelMesh, bool InbInstanceAlwaysEnableForwardDynamics, struct FName& InBoneName);
	void SetNamedBodiesFixed(bool bNewFixed, const class TArray<struct FName>& BoneNames, class USkeletalMeshComponent* SkelMesh, bool optionalBSetOtherBodiesToComplement, bool optionalBSkipFullAnimWeightBodies);
	void SetAllBodiesFixed(bool bNewFixed);
	float GetTotalMassBelowBone(const struct FName& InBoneName, class UPhysicsAsset* InAsset, class USkeletalMesh* InSkelMesh);
	void SetAngularDriveScale(float InAngularSpringScale, float InAngularDampingScale, float InAngularForceLimitScale);
	void SetLinearDriveScale(float InLinearSpringScale, float InLinearDampingScale, float InLinearForceLimitScale);
};

// Class Engine.PhysicsLODVerticalEmitter
// 0x0008 (0x0058 - 0x0060)
class UPhysicsLODVerticalEmitter : public UObject
{
public:
	int32_t                                            ParticlePercentage;                            // 0x0058 (0x0004) [0x0000000000005000] (CPF_Native | CPF_Config)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PhysicsLODVerticalEmitter");
		}

		return uClassPointer;
	};

};

// Class Engine.PhysXParticleSystem
// 0x0060 (0x0058 - 0x00B8)
class UPhysXParticleSystem : public UObject
{
public:
	int32_t                                            MaxParticles;                                  // 0x0058 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            ParticleSpawnReserve;                          // 0x005C (0x0004) [0x0000000000000001] (CPF_Edit)    
	ERBCollisionChannel                                RBChannel;                                     // 0x0060 (0x0001) [0x0000000000000003] (CPF_Edit | CPF_Const)
	ESimulationMethod                                  SimulationMethod;                              // 0x0061 (0x0001) [0x0000000000000000]               
	EPacketSizeMultiplier                              PacketSizeMultiplier;                          // 0x0062 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FRBCollisionChannelContainer                RBCollideWithChannels;                         // 0x0064 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              CollisionDistance;                             // 0x0068 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RestitutionWithStaticShapes;                   // 0x006C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RestitutionWithDynamicShapes;                  // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FrictionWithStaticShapes;                      // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FrictionWithDynamicShapes;                     // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StaticFrictionWithStaticShapes;                // 0x007C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StaticFrictionWithDynamicShapes;               // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDynamicCollision : 1;                         // 0x0084 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDisableGravity : 1;                           // 0x0084 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bStaticCollision : 1;                          // 0x0084 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bTwoWayCollision : 1;                          // 0x0084 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	float                                              MaxMotionDistance;                             // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Damping;                                       // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     ExternalAcceleration;                          // 0x0090 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              RestParticleDistance;                          // 0x009C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RestDensity;                                   // 0x00A0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              KernelRadiusMultiplier;                        // 0x00A4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Stiffness;                                     // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Viscosity;                                     // 0x00AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CollisionResponseCoefficient;                  // 0x00B0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PhysXParticleSystem");
		}

		return uClassPointer;
	};

};

// Class Engine.Player
// 0x0030 (0x0058 - 0x0088)
class UPlayer : public UObject
{
public:
	struct FPointer                                    VfTable_FExec;                                 // 0x0058 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class APlayerController*                           Actor;                                         // 0x0060 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            CurrentNetSpeed;                               // 0x0068 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            ConfiguredInternetSpeed;                       // 0x006C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            ConfiguredLanSpeed;                            // 0x0070 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              PP_DesaturationMultiplier;                     // 0x0074 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              PP_HighlightsMultiplier;                       // 0x0078 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              PP_MidTonesMultiplier;                         // 0x007C (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              PP_ShadowsMultiplier;                          // 0x0080 (0x0004) [0x0000000000004000] (CPF_Config)  

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Player");
		}

		return uClassPointer;
	};

	void SwitchController(class APlayerController* PC);
};

// Class Engine.LocalPlayer
// 0x0338 (0x0088 - 0x03C0)
class ULocalPlayer : public UPlayer
{
public:
	struct FPointer                                    VfTable_FObserverInterface;                    // 0x0088 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPlatformUserId                             UserId;                                        // 0x0090 (0x0008) [0x0000000000000000]               
	class UGameViewportClient*                         ViewportClient;                                // 0x0098 (0x0008) [0x0000000000000000]               
	struct FVector2D                                   Origin;                                        // 0x00A0 (0x0008) [0x0000000000000000]               
	struct FVector2D                                   Size;                                          // 0x00A8 (0x0008) [0x0000000000000000]               
	class UPostProcessChain*                           PlayerPostProcess;                             // 0x00B0 (0x0008) [0x0000000000000002] (CPF_Const)   
	class TArray<class UPostProcessChain*>             PlayerPostProcessChains;                       // 0x00B8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	struct FPointer                                    ViewState;                                     // 0x00C8 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FVector                                     LastViewLocation;                              // 0x00D0 (0x000C) [0x0000000000002000] (CPF_Transient)
	struct FCurrentPostProcessVolumeInfo               CurrentPPInfo;                                 // 0x00E0 (0x0128) [0x0000000001402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	struct FCurrentPostProcessVolumeInfo               LevelPPInfo;                                   // 0x0208 (0x0128) [0x0000000001402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FPostProcessSettingsOverride>  ActivePPOverrides;                             // 0x0330 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FWorldLightingOverride>        WorldLightingOverrides;                        // 0x0340 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	EAspectRatioAxisConstraint                         AspectRatioAxisConstraint;                     // 0x0350 (0x0001) [0x0000000000004000] (CPF_Config)  
	class FString                                      LastMap;                                       // 0x0358 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bWantToResetToMapDefaultPP : 1;                // 0x0368 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bSentSplitJoin : 1;                            // 0x0368 (0x0004) [0x0000000000022002] [0x00000002] (CPF_Const | CPF_Transient | CPF_EditConst)
	uint32_t                                           bHasMoved : 1;                                 // 0x0368 (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)
	struct FMatrix                                     ViewProjectionMatrix;                          // 0x0370 (0x0040) [0x0000000000002000] (CPF_Transient)
	float                                              ViewProjMatTimestamp;                          // 0x03B0 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              ScreenProjectionMultiplier;                    // 0x03B4 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FAudioListener                              AudioListener;                                 // 0x03B8 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LocalPlayer");
		}

		return uClassPointer;
	};

	void eventViewportClosed();
	class FString eventGetNickname();
	struct FUniqueNetId eventGetUniqueNetId();
	void DeProject(const struct FVector2D& RelativeScreenPos, struct FVector& WorldOrigin, struct FVector& WorldDirection);
	struct FPlane Project(const struct FVector& WorldLocation);
	void UpdateLightingOverrides(const struct FPointer& pSceneView, float DeltaTime);
	void RemoveWorldLightingOverride(class UObject* pMovie);
	void OverrideWorldLighting(class UObject* pMovie, float FadeInTime, float FadeOutTime);
	void TouchPlayerPostProcessChain();
	class UPostProcessChain* GetPostProcessChain(int32_t InIndex);
	bool RemoveAllPostProcessingChains();
	bool RemovePostProcessingChain(int32_t InIndex);
	bool InsertPostProcessingChain(class UPostProcessChain* InChain, int32_t InIndex, bool bInClone);
	void SetUserId(const struct FPlatformUserId& NewUserId);
	void ClearPostProcessSettingsOverride(float optionalBlendOutTime);
	void OverridePostProcessSettings(const struct FPostProcessSettings& OverrideSettings, float optionalBlendInTime);
	bool GetActorVisibility(class AActor* TestActor);
	void SendSplitJoin();
	bool SpawnPlayActor(const class FString& URL, class FString& OutError);
};

// Class Engine.NetConnection
// 0x5FF8 (0x0088 - 0x6080)
class UNetConnection : public UPlayer
{
public:
	uint8_t UnknownData02[0x78];
	UPackageMap* PackageMap; //0x100
	uint32_t ProtocolVersion;
	uint32_t MaxPacket;
	uint8_t                                           UnknownData03[0xE38];
	UChannel* Channels[0x3ff];
	uint8_t                                           UnknownData00[0x5F10 - 0x8 - 0xE40 - (sizeof(UChannel*) * 0x3ff)];  //UnknownData00[0x5E88];                         // 0x0088 (0x5F90) MISSED OFFSET
	class TArray<class UChildConnection*>              Children;                                      // 0x6018 (0x0010) [0x0000000000602000] (CPF_Transient | CPF_NeedCtorLink)
	uint8_t                                           UnknownData01[0x58];                           // 0x6028 (0x0058) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NetConnection");
		}

		return uClassPointer;
	};

};

// Class Engine.ChildConnection
// 0x0008 (0x6080 - 0x6088)
class UChildConnection : public UNetConnection
{
public:
	class UNetConnection*                              Parent;                                        // 0x6080 (0x0008) [0x0000000000202002] (CPF_Const | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ChildConnection");
		}

		return uClassPointer;
	};

};

// Class Engine.DemoRecConnection
// 0x0000 (0x6080 - 0x6080)
class UDemoRecConnection : public UNetConnection
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DemoRecConnection");
		}

		return uClassPointer;
	};

};

// Class Engine.Polys
// 0x0018 (0x0058 - 0x0070)
class UPolys : public UObject
{
public:
	uint8_t                                           UnknownData00[0x18];                           // 0x0058 (0x0018) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Polys");
		}

		return uClassPointer;
	};

};

// Class Engine.PostProcessChain
// 0x0010 (0x0058 - 0x0068)
class UPostProcessChain : public UObject
{
public:
	class TArray<class UPostProcessEffect*>            Effects;                                       // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PostProcessChain");
		}

		return uClassPointer;
	};

	class UPostProcessEffect* FindPostProcessEffect(const struct FName& EffectName);
};

// Class Engine.PostProcessEffect
// 0x0028 (0x0058 - 0x0080)
class UPostProcessEffect : public UObject
{
public:
	uint32_t                                           bShowInEditor : 1;                             // 0x0058 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bShowInGame : 1;                               // 0x0058 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bUseWorldSettings : 1;                         // 0x0058 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bPreAlphaPostProcess : 1;                      // 0x0058 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bAffectsLightingOnly : 1;                      // 0x0058 (0x0004) [0x0000000000000000] [0x00000010] 
	struct FName                                       EffectName;                                    // 0x005C (0x0008) [0x0000000000000001] (CPF_Edit)    
	ESceneDepthPriorityGroup                           SceneDPG;                                      // 0x0064 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EGameRenderPhase                                   GameRenderPhase;                               // 0x0065 (0x0001) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            NodePosY;                                      // 0x0068 (0x0004) [0x0000000000000000]               
	int32_t                                            NodePosX;                                      // 0x006C (0x0004) [0x0000000000000000]               
	int32_t                                            DrawWidth;                                     // 0x0070 (0x0004) [0x0000000000000000]               
	int32_t                                            DrawHeight;                                    // 0x0074 (0x0004) [0x0000000000000000]               
	int32_t                                            OutDrawY;                                      // 0x0078 (0x0004) [0x0000000000000000]               
	int32_t                                            InDrawY;                                       // 0x007C (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PostProcessEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.AmbientOcclusionEffect
// 0x00A8 (0x0080 - 0x0128)
class UAmbientOcclusionEffect : public UPostProcessEffect
{
public:
	struct FLinearColor                                OcclusionColor;                                // 0x0080 (0x0010) [0x0000000200000001] (CPF_Edit)    
	float                                              OcclusionPower;                                // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OcclusionScale;                                // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OcclusionBias;                                 // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MinOcclusion;                                  // 0x009C (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           SSAO2 : 1;                                     // 0x00A0 (0x0004) [0x0000000020000000] [0x00000001]  CPF_Deprecated)
	uint32_t                                           SharpenAO : 1;                                 // 0x00A0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              OcclusionRadius;                               // 0x00A4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OcclusionAttenuation;                          // 0x00A8 (0x0004) [0x0000000020000000]  CPF_Deprecated)
	EAmbientOcclusionType                              OcclusionType;                                 // 0x00AC (0x0001) [0x0000000000000001] (CPF_Edit)    
	EAmbientOcclusionQuality                           OcclusionQuality;                              // 0x00AD (0x0001) [0x0000000000000001] (CPF_Edit)    
	EComputeAmbientOcclusionQuality                    QualityLevel;                                  // 0x00AE (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              OcclusionFadeoutMinDistance;                   // 0x00B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OcclusionFadeoutMaxDistance;                   // 0x00B4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              HaloDistanceThreshold;                         // 0x00B8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              HaloDistanceScale;                             // 0x00BC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              HaloOcclusion;                                 // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              EdgeDistanceThreshold;                         // 0x00C4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              EdgeDistanceScale;                             // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FilterDistanceScale;                           // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            FilterSize;                                    // 0x00D0 (0x0004) [0x0000000020000000]  CPF_Deprecated)
	float                                              HistoryConvergenceTime;                        // 0x00D4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              HistoryWeightConvergenceTime;                  // 0x00D8 (0x0004) [0x0000000000000000]               
	float                                              AcceptRadius;                                  // 0x00DC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RejectRadius;                                  // 0x00E0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AcceptAngle;                                   // 0x00E4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Intensity;                                     // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              OcclusionMin;                                  // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              KernelScale;                                   // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FadeDistance;                                  // 0x00F4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              NormalScale;                                   // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DiscardUnder;                                  // 0x00FC (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            HDAOQuality;                                   // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            HierarchyDepth;                                // 0x0104 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RejectionFalloff;                              // 0x0108 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlurTolerance;                                 // 0x010C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              UpsampleTolerance;                             // 0x0110 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              NoiseFilterTolerance;                          // 0x0114 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ApplyCurve;                                    // 0x0118 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StartFadeDistance;                             // 0x011C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FadeExponent;                                  // 0x0120 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AmbientOcclusionEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.BlurEffect
// 0x0008 (0x0080 - 0x0088)
class UBlurEffect : public UPostProcessEffect
{
public:
	int32_t                                            BlurKernelSize;                                // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.BlurEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.DOFEffect
// 0x0060 (0x0080 - 0x00E0)
class UDOFEffect : public UPostProcessEffect
{
public:
	float                                              FalloffExponent;                               // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlurKernelSize;                                // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxNearBlurAmount;                             // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MinBlurAmount;                                 // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxFarBlurAmount;                              // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	EFocusType                                         FocusType;                                     // 0x0094 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              FocusInnerRadius;                              // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FocusDistance;                                 // 0x009C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     FocusPosition;                                 // 0x00A0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              TunnelVisionScale;                             // 0x00AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TunnelVisionYOffset;                           // 0x00B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bOverrideDOFSettings : 1;                      // 0x00B4 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              FalloffExponentOverride;                       // 0x00B8 (0x0004) [0x0000000000000000]               
	float                                              BlurKernelSizeOverride;                        // 0x00BC (0x0004) [0x0000000000000000]               
	float                                              MaxNearBlurAmountOverride;                     // 0x00C0 (0x0004) [0x0000000000000000]               
	float                                              MaxFarBlurAmountOverride;                      // 0x00C4 (0x0004) [0x0000000000000000]               
	float                                              MinBlurAmountOverride;                         // 0x00C8 (0x0004) [0x0000000000000000]               
	float                                              FocusInnerRadiusOverride;                      // 0x00CC (0x0004) [0x0000000000000000]               
	float                                              FocusDistanceOverride;                         // 0x00D0 (0x0004) [0x0000000000000000]               
	float                                              TunnelVisionScaleOverride;                     // 0x00D4 (0x0004) [0x0000000000000000]               
	float                                              TunnelVisionYOffsetOverride;                   // 0x00D8 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DOFEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.DOFAndBloomEffect
// 0x0020 (0x00E0 - 0x0100)
class UDOFAndBloomEffect : public UDOFEffect
{
public:
	float                                              BloomScale;                                    // 0x00E0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BloomThreshold;                                // 0x00E4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FColor                                      BloomTint;                                     // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BloomScreenBlendThreshold;                     // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SceneMultiplier;                               // 0x00F0 (0x0004) [0x0000000020000000]  CPF_Deprecated)
	float                                              BlurBloomKernelSize;                           // 0x00F4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bEnableReferenceDOF : 1;                       // 0x00F8 (0x0004) [0x0000000020000000] [0x00000001]  CPF_Deprecated)
	EDOFType                                           DepthOfFieldType;                              // 0x00FC (0x0001) [0x0000000000000001] (CPF_Edit)    
	EDOFQuality                                        DepthOfFieldQuality;                           // 0x00FD (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DOFAndBloomEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.DOFBloomMotionBlurEffect
// 0x0018 (0x0100 - 0x0118)
class UDOFBloomMotionBlurEffect : public UDOFAndBloomEffect
{
public:
	float                                              MaxVelocity;                                   // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MotionBlurAmount;                              // 0x0104 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           FullMotionBlur : 1;                            // 0x0108 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              CameraRotationThreshold;                       // 0x010C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CameraTranslationThreshold;                    // 0x0110 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DOFBloomMotionBlurEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.UberPostProcessEffect
// 0x00B8 (0x0118 - 0x01D0)
class UUberPostProcessEffect : public UDOFBloomMotionBlurEffect
{
public:
	struct FVector                                     SceneShadows;                                  // 0x0118 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     SceneHighLights;                               // 0x0124 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     SceneMidTones;                                 // 0x0130 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              SceneDesaturation;                             // 0x013C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     SceneColorize;                                 // 0x0140 (0x000C) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           VignetteEnabled : 1;                           // 0x014C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bEnableImageGrain : 1;                         // 0x014C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bScaleEffectsWithViewSize : 1;                 // 0x014C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bEnableHDRTonemapper : 1;                      // 0x014C (0x0004) [0x0000000020000000] [0x00000008]  CPF_Deprecated)
	struct FLinearColor                                VignetteColor;                                 // 0x0150 (0x0010) [0x0000000200000001] (CPF_Edit)    
	float                                              VignetteBrightness;                            // 0x0160 (0x0004) [0x0000000200000001] (CPF_Edit)    
	class UTexture*                                    VignetteTexture;                               // 0x0168 (0x0008) [0x0000000000000001] (CPF_Edit)    
	ETonemapperType                                    TonemapperType;                                // 0x0170 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              TonemapperRange;                               // 0x0174 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TonemapperToeFactor;                           // 0x0178 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TonemapperScale;                               // 0x017C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MotionBlurSoftEdgeKernelSize;                  // 0x0180 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SceneImageGrainScale;                          // 0x0184 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BloomWeightSmall;                              // 0x0188 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BloomWeightMedium;                             // 0x018C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BloomWeightLarge;                              // 0x0190 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BloomSizeScaleSmall;                           // 0x0194 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BloomSizeScaleMedium;                          // 0x0198 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BloomSizeScaleLarge;                           // 0x019C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FLUTBlender                                 PreviousLUTBlender;                            // 0x01A0 (0x0028) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	float                                              SceneHDRTonemapperScale;                       // 0x01C8 (0x0004) [0x0000000020000000]  CPF_Deprecated)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UberPostProcessEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.EdgeDetectionPostProcessEffect
// 0x0020 (0x0080 - 0x00A0)
class UEdgeDetectionPostProcessEffect : public UPostProcessEffect
{
public:
	float                                              HFilterAxisCoeff;                              // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              HFilterDiagCoeff;                              // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              VFilterAxisCoeff;                              // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              VFilterDiagCoeff;                              // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FarDist;                                       // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              NearDist;                                      // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SobelPower;                                    // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TexelOffset;                                   // 0x009C (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EdgeDetectionPostProcessEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.FXAAEffect
// 0x0018 (0x0080 - 0x0098)
class UFXAAEffect : public UPostProcessEffect
{
public:
	float                                              QualitySubpix;                                 // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              QualityEdgeThreshold;                          // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              QualityEdgeThresholdMin;                       // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ConsoleEdgeSharpness;                          // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ConsoleEdgeThreshold;                          // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ConsoleEdgeThresholdMin;                       // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FXAAEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialEffect
// 0x0008 (0x0080 - 0x0088)
class UMaterialEffect : public UPostProcessEffect
{
public:
	class UMaterialInterface*                          Material;                                      // 0x0080 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.MotionBlurEffect
// 0x0008 (0x0080 - 0x0088)
class UMotionBlurEffect : public UPostProcessEffect
{
public:
	float                                              MotionBlurScale;                               // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ZExtent;                                       // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MotionBlurEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.OutlinePostProcessEffect
// 0x0030 (0x0080 - 0x00B0)
class UOutlinePostProcessEffect : public UPostProcessEffect
{
public:
	float                                              GlobalIntensity;                               // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            BlurPasses;                                    // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlurKernelRadius;                              // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlurKernelScale;                               // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	EBlurDownSampleFactor                              BlurDownSampleFactor;                          // 0x0090 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDistanceFade : 1;                             // 0x0094 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bSobelEdgeDetection : 1;                       // 0x0094 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              FadeDistStart;                                 // 0x0098 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FadeDistRange;                                 // 0x009C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SobelFilterScale;                              // 0x00A0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SobelPower;                                    // 0x00A4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TexelOffset;                                   // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OutlinePostProcessEffect");
		}

		return uClassPointer;
	};

};

// Class Engine.Prefab
// 0x0030 (0x0058 - 0x0088)
class UPrefab : public UObject
{
public:
	int32_t                                            PrefabVersion;                                 // 0x0058 (0x0004) [0x0000000000000002] (CPF_Const)   
	class TArray<class UObject*>                       PrefabArchetypes;                              // 0x0060 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<class UObject*>                       RemovedArchetypes;                             // 0x0070 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class UPrefabSequence*                             PrefabSequence;                                // 0x0080 (0x0008) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Prefab");
		}

		return uClassPointer;
	};

};

// Class Engine.PrimitiveComponentFactory
// 0x0008 (0x0058 - 0x0060)
class UPrimitiveComponentFactory : public UObject
{
public:
	uint32_t                                           CollideActors : 1;                             // 0x0058 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           BlockActors : 1;                               // 0x0058 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           BlockZeroExtent : 1;                           // 0x0058 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           BlockNonZeroExtent : 1;                        // 0x0058 (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           BlockRigidBody : 1;                            // 0x0058 (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	uint32_t                                           HiddenGame : 1;                                // 0x0058 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           HiddenEditor : 1;                              // 0x0058 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           CastShadow : 1;                                // 0x0058 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PrimitiveComponentFactory");
		}

		return uClassPointer;
	};

};

// Class Engine.MeshComponentFactory
// 0x0010 (0x0060 - 0x0070)
class UMeshComponentFactory : public UPrimitiveComponentFactory
{
public:
	class TArray<class UMaterialInterface*>            Materials;                                     // 0x0060 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MeshComponentFactory");
		}

		return uClassPointer;
	};

};

// Class Engine.StaticMeshComponentFactory
// 0x0008 (0x0070 - 0x0078)
class UStaticMeshComponentFactory : public UMeshComponentFactory
{
public:
	class UStaticMesh*                                 StaticMesh;                                    // 0x0070 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.StaticMeshComponentFactory");
		}

		return uClassPointer;
	};

};

// Class Engine.ProxyMeshLODTemplates
// 0x0010 (0x0058 - 0x0068)
class UProxyMeshLODTemplates : public UObject
{
public:
	class TArray<struct FProxyMeshLODTemplateEntry>    ProxyMeshLODTemplateList;                      // 0x0058 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ProxyMeshLODTemplates");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_BodyInstance
// 0x0078 (0x0058 - 0x00D0)
class URB_BodyInstance : public UObject
{
public:
	class UPrimitiveComponent*                         OwnerComponent;                                // 0x0058 (0x0008) [0x000000000408200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	int32_t                                            BodyIndex;                                     // 0x0060 (0x0004) [0x0000000000000002] (CPF_Const)   
	struct FVector                                     Velocity;                                      // 0x0064 (0x000C) [0x0000000000000000]               
	struct FVector                                     PreviousVelocity;                              // 0x0070 (0x000C) [0x0000000000000000]               
	int32_t                                            SceneIndex;                                    // 0x007C (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FPointer                                    BodyData;                                      // 0x0080 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FPointer                                    BoneSpring;                                    // 0x0088 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FPointer                                    BoneSpringKinActor;                            // 0x0090 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	uint32_t                                           bEnableBoneSpringLinear : 1;                   // 0x0098 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bEnableBoneSpringAngular : 1;                  // 0x0098 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bDisableOnOverextension : 1;                   // 0x0098 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bNotifyOwnerOnOverextension : 1;               // 0x0098 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bTeleportOnOverextension : 1;                  // 0x0098 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bUseKinActorForBoneSpring : 1;                 // 0x0098 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bMakeSpringToBaseCollisionComponent : 1;       // 0x0098 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bOnlyCollideWithPawns : 1;                     // 0x0098 (0x0004) [0x0000000000000003] [0x00000080] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableCollisionResponse : 1;                  // 0x0098 (0x0004) [0x0000000000000003] [0x00000100] (CPF_Edit | CPF_Const)
	uint32_t                                           bPushBody : 1;                                 // 0x0098 (0x0004) [0x0000000000000003] [0x00000200] (CPF_Edit | CPF_Const)
	uint32_t                                           bForceUnfixed : 1;                             // 0x0098 (0x0004) [0x0000000000002000] [0x00000400] (CPF_Transient)
	uint32_t                                           bInstanceAlwaysEnableForwardDynamics : 1;      // 0x0098 (0x0004) [0x0000000000002000] [0x00000800] (CPF_Transient)
	float                                              BoneLinearSpring;                              // 0x009C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BoneLinearDamping;                             // 0x00A0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BoneAngularSpring;                             // 0x00A4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              BoneAngularDamping;                            // 0x00A8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              OverextensionThreshold;                        // 0x00AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CustomGravityFactor;                           // 0x00B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LastEffectPlayedTime;                          // 0x00B4 (0x0004) [0x0000000000002000] (CPF_Transient)
	class UPhysicalMaterial*                           PhysMaterialOverride;                          // 0x00B8 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ContactReportForceThreshold;                   // 0x00C0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              InstanceMassScale;                             // 0x00C4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              InstanceDampingScale;                          // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_BodyInstance");
		}

		return uClassPointer;
	};

	void SetNotifyCollision(bool bNotify);
	void UpdateDampingProperties();
	void UpdateMassProperties(class URB_BodySetup* Setup, const struct FVector& Scale);
	void SetContactReportForceThreshold(float Threshold);
	void EnableCollisionResponse(bool bEnableResponse);
	void SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial);
	void SetBlockRigidBody(bool bNewBlockRigidBody);
	void SetBoneSpringTarget(bool bTeleport, struct FMatrix& InBoneTarget);
	void SetBoneSpringParams(float InLinearSpring, float InLinearDamping, float InAngularSpring, float InAngularDamping);
	void EnableBoneSpring(bool bInEnableLinear, bool bInEnableAngular, struct FMatrix& InBoneTarget);
	struct FVector GetUnrealWorldVelocityAtPoint(const struct FVector& Point);
	struct FVector GetUnrealWorldAngularVelocity();
	struct FVector GetUnrealWorldVelocity();
	struct FMatrix GetUnrealWorldTM();
	class UPhysicsAssetInstance* GetPhysicsAssetInstance();
	bool IsValidBodyInstance();
	bool IsFixed();
	void SetFixed(bool bNewFixed);
	float GetBodyMass();
};

// Class Engine.RB_ConstraintInstance
// 0x0088 (0x0058 - 0x00E0)
class URB_ConstraintInstance : public UObject
{
public:
	class AActor*                                      Owner;                                         // 0x0058 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class UPrimitiveComponent*                         OwnerComponent;                                // 0x0060 (0x0008) [0x000000000408200A] (CPF_Const | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline)
	int32_t                                            ConstraintIndex;                               // 0x0068 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            SceneIndex;                                    // 0x006C (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)
	uint32_t                                           bInHardware : 1;                               // 0x0070 (0x0004) [0x0000000000001002] [0x00000001] (CPF_Const | CPF_Native)
	uint32_t                                           bLinearXPositionDrive : 1;                     // 0x0070 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           bLinearXVelocityDrive : 1;                     // 0x0070 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           bLinearYPositionDrive : 1;                     // 0x0070 (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           bLinearYVelocityDrive : 1;                     // 0x0070 (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	uint32_t                                           bLinearZPositionDrive : 1;                     // 0x0070 (0x0004) [0x0000000000000003] [0x00000020] (CPF_Edit | CPF_Const)
	uint32_t                                           bLinearZVelocityDrive : 1;                     // 0x0070 (0x0004) [0x0000000000000003] [0x00000040] (CPF_Edit | CPF_Const)
	uint32_t                                           bSwingPositionDrive : 1;                       // 0x0070 (0x0004) [0x0000000000000003] [0x00000080] (CPF_Edit | CPF_Const)
	uint32_t                                           bSwingVelocityDrive : 1;                       // 0x0070 (0x0004) [0x0000000000000003] [0x00000100] (CPF_Edit | CPF_Const)
	uint32_t                                           bTwistPositionDrive : 1;                       // 0x0070 (0x0004) [0x0000000000000003] [0x00000200] (CPF_Edit | CPF_Const)
	uint32_t                                           bTwistVelocityDrive : 1;                       // 0x0070 (0x0004) [0x0000000000000003] [0x00000400] (CPF_Edit | CPF_Const)
	uint32_t                                           bAngularSlerpDrive : 1;                        // 0x0070 (0x0004) [0x0000000000000003] [0x00000800] (CPF_Edit | CPF_Const)
	uint32_t                                           bTerminated : 1;                               // 0x0070 (0x0004) [0x0000000000000000] [0x00001000] 
	struct FPointer                                    ConstraintData;                                // 0x0078 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FPointer                                    PulleyJoint;                                   // 0x0080 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FVector                                     LinearPositionTarget;                          // 0x0088 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     LinearVelocityTarget;                          // 0x0094 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LinearDriveSpring;                             // 0x00A0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LinearDriveDamping;                            // 0x00A4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              LinearDriveForceLimit;                         // 0x00A8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FQuat                                       AngularPositionTarget;                         // 0x00B0 (0x0010) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     AngularVelocityTarget;                         // 0x00C0 (0x000C) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              AngularDriveSpring;                            // 0x00CC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              AngularDriveDamping;                           // 0x00D0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              AngularDriveForceLimit;                        // 0x00D4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FPointer                                    DummyKinActor;                                 // 0x00D8 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_ConstraintInstance");
		}

		return uClassPointer;
	};

	void MoveKinActorTransform(struct FMatrix& NewTM);
	void SetLinearLimitSize(float NewLimitSize);
	void SetAngularDOFLimitScale(float InSwing1LimitScale, float InSwing2LimitScale, float InTwistLimitScale, class URB_ConstraintSetup* InSetup);
	void SetAngularDriveTypeAndParams(bool bEnableSwingDrive, bool bEnableTwistDrive, EConstraintDriveChange PositionDriveState, EConstraintDriveChange VelocityDriveState, float InSpring, float InDamping, float InForceLimit, class UPhysicsAssetInstance* PhysInst);
	void SetAngularDriveParams(float InSpring, float InDamping, float InForceLimit);
	void SetAngularVelocityTarget(const struct FVector& InVelTarget);
	void SetAngularPositionTarget(struct FQuat& InPosTarget);
	void SetLinearDriveParams(float InSpring, float InDamping, float InForceLimit);
	void SetLinearVelocityTarget(const struct FVector& InVelTarget);
	void SetLinearPositionTarget(const struct FVector& InPosTarget);
	void SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive);
	void SetAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive);
	void SetLinearVelocityDrive(bool bEnableXDrive, bool bEnableYDrive, bool bEnableZDrive);
	void SetLinearPositionDrive(bool bEnableXDrive, bool bEnableYDrive, bool bEnableZDrive);
	struct FVector GetConstraintLocation();
	class UPhysicsAssetInstance* GetPhysicsAssetInstance();
	void TermConstraint();
	void InitConstraint(class UPrimitiveComponent* PrimComp1, class UPrimitiveComponent* PrimComp2, class URB_ConstraintSetup* Setup, float Bone1Scale, float Bone2Scale, class AActor* InOwner, class UPrimitiveComponent* InPrimComp, bool bMakeKinForBody1, class UPhysicsAssetInstance* PhysInst);
};

// Class Engine.RB_ConstraintSetup
// 0x00D8 (0x0058 - 0x0130)
class URB_ConstraintSetup : public UObject
{
public:
	struct FName                                       JointName;                                     // 0x0058 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bCanBeBroken : 1;                              // 0x0060 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableProjection : 1;                         // 0x0060 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bLinearLimitSoft : 1;                          // 0x0060 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bLinearBreakable : 1;                          // 0x0060 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bSwingLimited : 1;                             // 0x0060 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bTwistLimited : 1;                             // 0x0060 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bSwingLimitSoft : 1;                           // 0x0060 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bTwistLimitSoft : 1;                           // 0x0060 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bAngularBreakable : 1;                         // 0x0060 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bIsPulley : 1;                                 // 0x0060 (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bMaintainMinDistance : 1;                      // 0x0060 (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	float                                              Bone1JointMassScale;                           // 0x0064 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Bone2JointMassScale;                           // 0x0068 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       ConstraintBone1;                               // 0x006C (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       ConstraintBone2;                               // 0x0074 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     Pos1;                                          // 0x007C (0x000C) [0x0000000000000000]               
	struct FVector                                     PriAxis1;                                      // 0x0088 (0x000C) [0x0000000000000000]               
	struct FVector                                     SecAxis1;                                      // 0x0094 (0x000C) [0x0000000000000000]               
	struct FVector                                     Pos2;                                          // 0x00A0 (0x000C) [0x0000000000000000]               
	struct FVector                                     PriAxis2;                                      // 0x00AC (0x000C) [0x0000000000000000]               
	struct FVector                                     SecAxis2;                                      // 0x00B8 (0x000C) [0x0000000000000000]               
	struct FVector                                     PulleyPivot1;                                  // 0x00C4 (0x000C) [0x0000000000000000]               
	struct FVector                                     PulleyPivot2;                                  // 0x00D0 (0x000C) [0x0000000000000000]               
	float                                              LinearProjectionTolerance;                     // 0x00DC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AngularProjectionTolerance;                    // 0x00E0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FLinearDOFSetup                             LinearXSetup;                                  // 0x00E4 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FLinearDOFSetup                             LinearYSetup;                                  // 0x00EC (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FLinearDOFSetup                             LinearZSetup;                                  // 0x00F4 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              LinearLimitStiffness;                          // 0x00FC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LinearLimitDamping;                            // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LinearBreakThreshold;                          // 0x0104 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Swing1LimitAngle;                              // 0x0108 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Swing2LimitAngle;                              // 0x010C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TwistLimitAngle;                               // 0x0110 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SwingLimitStiffness;                           // 0x0114 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SwingLimitDamping;                             // 0x0118 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TwistLimitStiffness;                           // 0x011C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TwistLimitDamping;                             // 0x0120 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              AngularBreakThreshold;                         // 0x0124 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              PulleyRatio;                                   // 0x0128 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_ConstraintSetup");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_BSJointSetup
// 0x0000 (0x0130 - 0x0130)
class URB_BSJointSetup : public URB_ConstraintSetup
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_BSJointSetup");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_DistanceJointSetup
// 0x0000 (0x0130 - 0x0130)
class URB_DistanceJointSetup : public URB_ConstraintSetup
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_DistanceJointSetup");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_HingeSetup
// 0x0000 (0x0130 - 0x0130)
class URB_HingeSetup : public URB_ConstraintSetup
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_HingeSetup");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_PrismaticSetup
// 0x0000 (0x0130 - 0x0130)
class URB_PrismaticSetup : public URB_ConstraintSetup
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_PrismaticSetup");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_PulleyJointSetup
// 0x0000 (0x0130 - 0x0130)
class URB_PulleyJointSetup : public URB_ConstraintSetup
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_PulleyJointSetup");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_SkelJointSetup
// 0x0000 (0x0130 - 0x0130)
class URB_SkelJointSetup : public URB_ConstraintSetup
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_SkelJointSetup");
		}

		return uClassPointer;
	};

};

// Class Engine.RB_StayUprightSetup
// 0x0000 (0x0130 - 0x0130)
class URB_StayUprightSetup : public URB_ConstraintSetup
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RB_StayUprightSetup");
		}

		return uClassPointer;
	};

};

// Class Engine.ResourcePool
// 0x0118 (0x0058 - 0x0170)
class UResourcePool : public UObject
{
public:
	class UResourcePoolDefinition*                     Definition;                                    // 0x0058 (0x0008) [0x0000000000000000]               
	uint8_t                                            PoolGUID;                                      // 0x0060 (0x0001) [0x0000000000000000]               
	float                                              MinValue;                                      // 0x0064 (0x0004) [0x8000000000002000] (CPF_Transient)
	float                                              MinValueBaseValue;                             // 0x0068 (0x0004) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            MinValueModifierStack;                         // 0x0070 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              MaxValue;                                      // 0x0080 (0x0004) [0x8000000000002000] (CPF_Transient)
	float                                              MaxValueBaseValue;                             // 0x0084 (0x0004) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            MaxValueModifierStack;                         // 0x0088 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              CurrentValue;                                  // 0x0098 (0x0004) [0x6000000000000000]               
	float                                              NetRateOfChange;                               // 0x009C (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              ConsumptionRate;                               // 0x00A0 (0x0004) [0x8000000000002000] (CPF_Transient)
	float                                              ConsumptionRateBaseValue;                      // 0x00A4 (0x0004) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            ConsumptionRateModifierStack;                  // 0x00A8 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              ActiveRegenerationRate;                        // 0x00B8 (0x0004) [0x8000000000002000] (CPF_Transient)
	float                                              ActiveRegenerationRateBaseValue;               // 0x00BC (0x0004) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            ActiveRegenerationRateModifierStack;           // 0x00C0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              OnIdleRegenerationRate;                        // 0x00D0 (0x0004) [0x8000000000002000] (CPF_Transient)
	float                                              OnIdleRegenerationRateBaseValue;               // 0x00D4 (0x0004) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            OnIdleRegenerationRateModifierStack;           // 0x00D8 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              OnIdleRegenerationDelay;                       // 0x00E8 (0x0004) [0x8000000000002000] (CPF_Transient)
	float                                              OnIdleRegenerationDelayBaseValue;              // 0x00EC (0x0004) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            OnIdleRegenerationDelayModifierStack;          // 0x00F0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              PassiveRegenerationRate;                       // 0x0100 (0x0004) [0x8000000000002000] (CPF_Transient)
	float                                              PassiveRegenerationRateBaseValue;              // 0x0104 (0x0004) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            PassiveRegenerationRateModifierStack;          // 0x0108 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              LastMinValue;                                  // 0x0118 (0x0004) [0x0000000000000000]               
	float                                              LastMaxValue;                                  // 0x011C (0x0004) [0x0000000000000000]               
	float                                              LastCurrentValue;                              // 0x0120 (0x0004) [0x0000000000000000]               
	float                                              PoolIdleDelayStartTime;                        // 0x0124 (0x0004) [0x0000000000000000]               
	int32_t                                            RecentImpulseCount;                            // 0x0128 (0x0004) [0x4000000000000000]               
	int32_t                                            RegenerationDisabled;                          // 0x012C (0x0004) [0x8000000000002000] (CPF_Transient)
	int32_t                                            RegenerationDisabledBaseValue;                 // 0x0130 (0x0004) [0x4000000000000002] (CPF_Const)   
	class TArray<class UAttributeModifier*>            RegenerationDisabledModifierStack;             // 0x0138 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	float                                              ResetRecentImpulseCountTime;                   // 0x0148 (0x0004) [0x0000000000000000]               
	uint32_t                                           bIsAuthoritative : 1;                          // 0x014C (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bIsBeingInitialized : 1;                       // 0x014C (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bIntegerValue : 1;                             // 0x014C (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bHasPoolBeenFullSinceLastBeingDepleted : 1;    // 0x014C (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bDisallowReinitialization : 1;                 // 0x014C (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bHideHUDDisplay : 1;                           // 0x014C (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bCreatedAndNotModified : 1;                    // 0x014C (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           WasRegenerating : 1;                           // 0x014C (0x0004) [0x0000000000002000] [0x00000080] (CPF_Transient)
	uint32_t                                           bTriggerResourcePoolDepletedEvent : 1;         // 0x014C (0x0004) [0x0000000000002000] [0x00000100] (CPF_Transient)
	uint32_t                                           bTriggerResourcePoolOnFullEvent : 1;           // 0x014C (0x0004) [0x0000000000002000] [0x00000200] (CPF_Transient)
	class UObject*                                     AssociatedProvider;                            // 0x0150 (0x0008) [0x0000000000000000]               
	class UMaterialInstance*                           HUDMaterialInstance;                           // 0x0158 (0x0008) [0x0000000000000000]               
	class UResourcePool*                               RegenerationPool;                              // 0x0160 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            IsRegenerating;                                // 0x0168 (0x0004) [0x4000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ResourcePool");
		}

		return uClassPointer;
	};

	void DisableRegeneration(bool bDisabled);
	bool IsResourcePoolInState(EResourcePoolState ResourcePoolState);
	bool WasCreatedAndNotModified();
	bool IsAuthoritative();
	void SetAuthoritative(bool B);
	float GetTimeSeconds();
	class FString GetMinimalDebugText();
	void GetDebugText(class TArray<class FString>& DebugText);
	void RefillPercentage(float Percentage, float optionalMaxPercentage);
	bool HasIdleDelayPassed(float CurrentTime);
	void ResetIdleTimer();
	void UpdateCreatedAndNotModified();
	void UpdateLastValues();
	void SetMaxValueFromProfile(float Value);
	void PoolIsNowFull();
	float GetMinValue();
	float GetMaxValue(bool optionalBWantBaseValue);
	float GetTotalRegenRate();
	float GetCurrentPulseSpeed();
	float GetCurrentValue();
	void SetCurrentValueWithoutResettingIdleTimer(float Value);
	void SetCurrentValue(float Value);
	void AddCurrentValueImpulse(float Delta);
	bool IsResourcePoolForResourceDefinition(class UResourceDefinition* Resource);
	void UpdateCurrentValueOnExtremaChange(bool optionalBKeepLastValuesOnExtremaChange);
	void CalculateBaseValues(bool optionalBOnlyCalculateAttributeInitializedState, bool optionalBKeepLastValuesOnExtremaChange);
	void eventApplyUpgrades();
	bool SetUpgradeLevel(int32_t NewUpgradeLevel);
	int32_t GetUpgradeLevel();
	void eventReinitializeCurrentValue();
	void eventReinitialize();
	void ClearAttributeModifierStacks();
	void eventShutDown();
	void eventInitializeAuthoritative(class UResourcePoolDefinition* InDefinition, class UObject* ProviderToAssociatePoolWith);
};

// Class Engine.HealthResourcePool
// 0x0000 (0x0170 - 0x0170)
class UHealthResourcePool : public UResourcePool
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.HealthResourcePool");
		}

		return uClassPointer;
	};

};

// Class Engine.Sampler
// 0x0020 (0x0058 - 0x0078)
class USampler : public UObject
{
public:
	struct FRenderCommandFence_Mirror                  SamplerFence;                                  // 0x0058 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FPointer                                    SamplerResource;                               // 0x0060 (0x0008) [0x0000000000203002] (CPF_Const | CPF_Native | CPF_Transient)
	EMaterialTextureAddress                            AddressU;                                      // 0x0068 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EMaterialTextureAddress                            AddressV;                                      // 0x0069 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EMaterialTextureAddress                            AddressW;                                      // 0x006A (0x0001) [0x0000000000000001] (CPF_Edit)    
	EMaterialTextureFilter                             Filter;                                        // 0x006B (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                            Anisotropy;                                    // 0x006C (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              MipLODBias;                                    // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bUseUserControlledAnisotropy : 1;              // 0x0074 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Sampler");
		}

		return uClassPointer;
	};

};

// Class Engine.SaveDataManager
// 0x0098 (0x0058 - 0x00F0)
class USaveDataManager : public UObject
{
public:
	class TArray<struct FUserSaveDataUnity>            UserSaveDataInfo;                              // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FPointer                                    PlatformSaveDataManager;                       // 0x0068 (0x0008) [0x0000000000001000] (CPF_Native)  
	class FString                                      ProfileSaveFileName;                           // 0x0070 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class FString                                      ProfileSaveTitle;                              // 0x0080 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      ProfileSaveSubtitle;                           // 0x0090 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnWriteSaveDataComplete__Delegate;           // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReadSaveDataComplete__Delegate;            // 0x00B0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnDeleteSaveDataComplete__Delegate;          // 0x00C0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnListSaveDataComplete__Delegate;            // 0x00D0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnCheckSaveDataExistsComplete__Delegate;     // 0x00E0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SaveDataManager");
		}

		return uClassPointer;
	};

	void OnCheckSaveDataExistsComplete(const struct FPlatformUserId& UserId, ESaveDataOperationResult Result);
	void OnListSaveDataComplete(const struct FPlatformUserId& UserId, ESaveDataOperationResult Result);
	void OnDeleteSaveDataComplete(const struct FPlatformUserId& UserId, ESaveDataOperationResult Result);
	void OnReadSaveDataComplete(const struct FPlatformUserId& UserId, ESaveDataOperationResult Result);
	void OnWriteSaveDataComplete(const struct FPlatformUserId& UserId, ESaveDataOperationResult Result);
};

// Class Engine.SavedMove
// 0x00B8 (0x0058 - 0x0110)
class USavedMove : public UObject
{
public:
	class USavedMove*                                  NextMove;                                      // 0x0058 (0x0008) [0x0000000000000000]               
	float                                              TimeStamp;                                     // 0x0060 (0x0004) [0x0000000000000000]               
	float                                              Delta;                                         // 0x0064 (0x0004) [0x0000000000000000]               
	uint32_t                                           bRun : 1;                                      // 0x0068 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bDuck : 1;                                     // 0x0068 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bPressedJump : 1;                              // 0x0068 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bDoubleJump : 1;                               // 0x0068 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bPreciseDestination : 1;                       // 0x0068 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bForceRMVelocity : 1;                          // 0x0068 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bForceMaxAccel : 1;                            // 0x0068 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bRootMotionFromInterpCurve : 1;                // 0x0068 (0x0004) [0x0000000000000000] [0x00000080] 
	EDoubleClickDir                                    DoubleClickMove;                               // 0x006C (0x0001) [0x0000000000000000]               
	EPhysics                                           SavedPhysics;                                  // 0x006D (0x0001) [0x0000000000000000]               
	uint8_t                                            AnalogPct;                                     // 0x006E (0x0001) [0x0000000000000000]               
	ERootMotionMode                                    RootMotionMode;                                // 0x006F (0x0001) [0x0000000000000000]               
	struct FVector                                     StartLocation;                                 // 0x0070 (0x000C) [0x0000000000000000]               
	struct FVector                                     StartRelativeLocation;                         // 0x007C (0x000C) [0x0000000000000000]               
	struct FVector                                     StartVelocity;                                 // 0x0088 (0x000C) [0x0000000000000000]               
	struct FVector                                     StartFloor;                                    // 0x0094 (0x000C) [0x0000000000000000]               
	struct FVector                                     SavedLocation;                                 // 0x00A0 (0x000C) [0x0000000000000000]               
	struct FVector                                     SavedVelocity;                                 // 0x00AC (0x000C) [0x0000000000000000]               
	struct FVector                                     SavedRelativeLocation;                         // 0x00B8 (0x000C) [0x0000000000000000]               
	struct FVector                                     RMVelocity;                                    // 0x00C4 (0x000C) [0x0000000000000000]               
	struct FVector                                     Acceleration;                                  // 0x00D0 (0x000C) [0x0000000000000000]               
	struct FRotator                                    Rotation;                                      // 0x00DC (0x000C) [0x0000000000000000]               
	class AActor*                                      StartBase;                                     // 0x00E8 (0x0008) [0x0000000000000000]               
	class AActor*                                      EndBase;                                       // 0x00F0 (0x0008) [0x0000000000000000]               
	float                                              CustomTimeDilation;                            // 0x00F8 (0x0004) [0x0000000000000000]               
	float                                              AccelDotThreshold;                             // 0x00FC (0x0004) [0x0000000000000000]               
	float                                              RootMotionInterpCurrentTime;                   // 0x0100 (0x0004) [0x0000000000000000]               
	struct FVector                                     RootMotionInterpCurveLastValue;                // 0x0104 (0x000C) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SavedMove");
		}

		return uClassPointer;
	};

	class FString GetDebugString();
	static EDoubleClickDir SetFlags(uint8_t Flags, class APlayerController* PC);
	uint8_t CompressedFlags();
	void ResetMoveFor(class APawn* P);
	void PrepMoveFor(class APawn* P);
	void SetMoveFor(class APlayerController* P, float DeltaTime, const struct FVector& newAccel, EDoubleClickDir InDoubleClick, uint8_t InAnalogPct);
	bool CanCombineWith(class USavedMove* NewMove, class APawn* inPawn, float MaxDelta);
	void SetInitialPosition(class APawn* P);
	struct FVector GetStartLocation();
	bool IsImportantMove(const struct FVector& CompareAccel, uint8_t CompareAnalogPct);
	void PostUpdate(class APlayerController* P);
	void Clear();
};

// Class Engine.SaveGameSummary
// 0x0018 (0x0058 - 0x0070)
class USaveGameSummary : public UObject
{
public:
	struct FName                                       BaseLevel;                                     // 0x0058 (0x0008) [0x0000000000000000]               
	class FString                                      Description;                                   // 0x0060 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SaveGameSummary");
		}

		return uClassPointer;
	};

};

// Class Engine.Scene
// 0x0000 (0x0058 - 0x0058)
class UScene : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Scene");
		}

		return uClassPointer;
	};

};

// Class Engine.ScriptViewportClient
// 0x0008 (0x0058 - 0x0060)
class UScriptViewportClient : public UObject
{
public:
	struct FPointer                                    VfTable_FViewportClient;                       // 0x0058 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ScriptViewportClient");
		}

		return uClassPointer;
	};

};

// Class Engine.GameViewportClient
// 0x0168 (0x0060 - 0x01C8)
class UGameViewportClient : public UScriptViewportClient
{
public:
	struct FPointer                                    VfTable_FExec;                                 // 0x0060 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    Viewport;                                      // 0x0068 (0x0008) [0x0000000000000002] (CPF_Const)   
	struct FPointer                                    ViewportFrame;                                 // 0x0070 (0x0008) [0x0000000000000002] (CPF_Const)   
	class TArray<class UInteraction*>                  GlobalInteractions;                            // 0x0078 (0x0010) [0x0000000000500000] (CPF_NeedCtorLink)
	class UClass*                                      UIControllerClass;                             // 0x0088 (0x0008) [0x0000000000000000]               
	class UUIInteraction*                              UIController;                                  // 0x0090 (0x0008) [0x0000000000000000]               
	class UConsole*                                    ViewportConsole;                               // 0x0098 (0x0008) [0x0000000000000000]               
	struct FPointer                                    pShowFlags;                                    // 0x00A0 (0x0008) [0x0000000000000002] (CPF_Const)   
	int32_t                                            ViewMode;                                      // 0x00A8 (0x0004) [0x0000000000203000] (CPF_Native | CPF_Transient)
	class FString                                      LoadingMessage;                                // 0x00B0 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      SavingMessage;                                 // 0x00C0 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      ConnectingMessage;                             // 0x00D0 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      PausedMessage;                                 // 0x00E0 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	class FString                                      PrecachingMessage;                             // 0x00F0 (0x0010) [0x0000000000408002] (CPF_Const | CPF_Localized | CPF_NeedCtorLink)
	uint32_t                                           bShowTitleSafeZone : 1;                        // 0x0100 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bDisplayHardwareMouseCursor : 1;               // 0x0100 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	uint32_t                                           bOverrideDiffuseAndSpecular : 1;               // 0x0100 (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)
	uint32_t                                           bIsPlayInEditorViewport : 1;                   // 0x0100 (0x0004) [0x0000000000002000] [0x00000008] (CPF_Transient)
	uint32_t                                           bShowSystemMouseCursor : 1;                    // 0x0100 (0x0004) [0x0000000000002000] [0x00000010] (CPF_Transient)
	uint32_t                                           bDisableWorldRendering : 1;                    // 0x0100 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bDebugNoGFxUI : 1;                             // 0x0100 (0x0004) [0x0000000000004000] [0x00000040] (CPF_Config)
	uint32_t                                           bDebugDrawUserInfo : 1;                        // 0x0100 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bDownscaled : 1;                               // 0x0100 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bForceDownscale : 1;                           // 0x0100 (0x0004) [0x0000000000000000] [0x00000200] 
	struct FTitleSafeZoneArea                          TitleSafeZone;                                 // 0x0104 (0x0010) [0x0000000000000000]               
	class TArray<struct FSplitscreenData>              SplitscreenInfo;                               // 0x0118 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	ESplitScreenType                                   DesiredSplitscreenType;                        // 0x0128 (0x0001) [0x0000000000000000]               
	ESplitScreenType                                   ActiveSplitscreenType;                         // 0x0129 (0x0001) [0x0000000000000000]               
	ESplitScreenType                                   Default2PSplitType;                            // 0x012A (0x0001) [0x0000000000000002] (CPF_Const)   
	ESplitScreenType                                   Default3PSplitType;                            // 0x012B (0x0001) [0x0000000000000002] (CPF_Const)   
	class FString                                      ProgressMessage[0x2];                          // 0x0130 (0x0020) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              ProgressTimeOut;                               // 0x0150 (0x0004) [0x0000000000000000]               
	float                                              ProgressFadeTime;                              // 0x0154 (0x0004) [0x0000000000000000]               
	class TArray<struct FDebugDisplayProperty>         DebugProperties;                               // 0x0158 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FPointer                                    ScaleformInteraction;                          // 0x0168 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	class USaveDataManager*                            TheSaveDataManager;                            // 0x0170 (0x0008) [0x0000000000000000]               
	float                                              LastFrameGPUTimeMS;                            // 0x0178 (0x0004) [0x0000000000000000]               
	float                                              LastDownscaleTime;                             // 0x017C (0x0004) [0x0000000000000000]               
	float                                              DownscalingThresholdMS;                        // 0x0180 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              DownscalingRecoveryThresholdMS;                // 0x0184 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              MinDownscaleDurationSeconds;                   // 0x0188 (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              DownscalingRecoveryMinAngleChange;             // 0x018C (0x0004) [0x0000000000004000] (CPF_Config)  
	float                                              DownscalingRecoveryMinPositionChange;          // 0x0190 (0x0004) [0x0000000000004000] (CPF_Config)  
	struct FScriptDelegate                             __HandleInputKey__Delegate;                    // 0x0198 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __HandleInputAxis__Delegate;                   // 0x01A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __HandleInputChar__Delegate;                   // 0x01B8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GameViewportClient");
		}

		return uClassPointer;
	};

	void eventSetHardwareMouseCursorVisibility(bool bIsVisible);
	void DebugSetUISystemEnabled(bool bOldUISystemActive, bool bGFxUISystemActive);
	void BecomePrimaryPlayer(int32_t PlayerIndex);
	void FixupOwnerReferences(const class TArray<int32_t>& IDMappings);
	class ULocalPlayer* GetPlayerOwner(int32_t PlayerIndex);
	void ClearProgressMessages();
	void SetProgressTime(float T);
	void NotifyConnectionError(EProgressMessageType MessageType, const class FString& optionalMessage, const class FString& optionalTitle);
	void eventSetProgressMessage(EProgressMessageType MessageType, const class FString& Message, const class FString& optionalTitle, bool optionalBIgnoreFutureNetworkMessages);
	int32_t RemoveLocalPlayer(class ULocalPlayer* ExistingPlayer);
	int32_t AddLocalPlayer(class ULocalPlayer* NewPlayer);
	void NotifyPlayerRemoved(int32_t PlayerIndex, class ULocalPlayer* RemovedPlayer);
	void NotifyPlayerAdded(int32_t PlayerIndex, class ULocalPlayer* AddedPlayer);
	void DisplayProgressMessage(class UCanvas* Canvas);
	void eventPostRender(class UCanvas* Canvas);
	void DrawTitleSafeArea(class UCanvas* Canvas);
	void eventTick(float DeltaTime);
	bool CalculateDeadZoneForAllSides(class ULocalPlayer* LPlayer, class UCanvas* Canvas, bool optionalBUseMaxPercent, float& fTopSafeZone, float& fBottomSafeZone, float& fLeftSafeZone, float& fRightSafeZone);
	void CalculateSafeZoneValues(class UCanvas* Canvas, int32_t LocalPlayerIndex, bool bUseMaxPercent, float& out_Horizontal, float& out_Vertical);
	void GetPixelSizeOfScreen(class UCanvas* Canvas, int32_t LocalPlayerIndex, float& out_Width, float& out_Height);
	bool HasRightSafeZone(int32_t LocalPlayerIndex);
	bool HasLeftSafeZone(int32_t LocalPlayerIndex);
	bool HasBottomSafeZone(int32_t LocalPlayerIndex);
	bool HasTopSafeZone(int32_t LocalPlayerIndex);
	int32_t ConvertLocalPlayerToGamePlayerIndex(class ULocalPlayer* LPlayer);
	void eventGetSubtitleRegion(struct FVector2D& MinPos, struct FVector2D& MaxPos);
	void eventLayoutPlayers();
	void UpdateActiveSplitscreenType();
	void SetSplitscreenConfiguration(ESplitScreenType SplitType);
	void eventGameSessionEnded();
	int32_t eventInsertInteraction(class UInteraction* NewInteraction, int32_t optionalInIndex);
	struct FPlatformUserId GetDefaultPlatformUserId();
	bool CreateInitialPlayer(class FString& OutError);
	bool Init(class FString& OutError);
	void SetConsoleTarget(int32_t PlayerIndex);
	void ShowTitleSafeArea();
	void SetSplit(int32_t Mode);
	void SSSwapControllers();
	class ULocalPlayer* eventFindPlayerByUserId(const struct FPlatformUserId& UserId);
	bool RemovePlayer(class ULocalPlayer* ExPlayer);
	class ULocalPlayer* CreatePlayer(const struct FPlatformUserId& UserId, bool bSpawnActor, class FString& OutError);
	void NotifySplitscreenLayoutChanged();
	void SetCustomInteractionObject(class UInteraction* InInteraction);
	class UClass* GetCustomInteractionClass(int32_t InIndex);
	int32_t GetNumCustomInteractions();
	bool ShouldForceFullscreenViewport();
	bool IsFullScreenViewport();
	void GetViewportSize(struct FVector2D& out_ViewportSize);
	class FString ConsoleCommand(const class FString& Command);
	bool HandleInputChar(const struct FPlatformUserId& UserId, const class FString& Unicode);
	bool HandleInputAxis(const struct FPlatformUserId& UserId, const struct FName& Key, float Delta, float DeltaTime, bool bGamepad);
	bool HandleInputKey(const struct FPlatformUserId& UserId, const struct FName& Key, EInputEvent EventType, float AmountDepressed, bool optionalBGamepad);
	bool IsWidescreen();
	EAspectRatio GetAspectRatio();
};

// Class Engine.Selection
// 0x0030 (0x0058 - 0x0088)
class USelection : public UObject
{
public:
	uint8_t                                           UnknownData00[0x30];                           // 0x0058 (0x0030) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Selection");
		}

		return uClassPointer;
	};

};

// Class Engine.SequenceObject
// 0x0018 (0x0058 - 0x0070)
class USequenceObject : public UObject
{
public:
	int32_t                                            ObjInstanceVersion;                            // 0x0058 (0x0004) [0x0000000000000002] (CPF_Const)   
	class USequence*                                   ParentSequence;                                // 0x0060 (0x0008) [0x0000000001000002] (CPF_Const)   
	uint32_t                                           bDeletable : 1;                                // 0x0068 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bDrawFirst : 1;                                // 0x0068 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bDrawLast : 1;                                 // 0x0068 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bNotifyBeginPlay : 1;                          // 0x0068 (0x0004) [0x0000000000000000] [0x00000008] 
	uint32_t                                           bOutputObjCommentToScreen : 1;                 // 0x0068 (0x0004) [0x0000000800000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bSuppressAutoComment : 1;                      // 0x0068 (0x0004) [0x0000000800000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bShouldPersistWhenStreamedOut : 1;             // 0x0068 (0x0004) [0x0000000000020001] [0x00000040] (CPF_Edit | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SequenceObject");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
	bool eventIsPastingIntoLevelSequenceAllowed();
	bool eventIsValidLevelSequenceObject();
	class AWorldInfo* GetWorldInfo();
	void ScriptLog(const class FString& LogText, bool optionalBWarning);
};

// Class Engine.SequenceOp
// 0x0058 (0x0070 - 0x00C8)
class USequenceOp : public USequenceObject
{
public:
	uint32_t                                           bIsActivated : 1;                              // 0x0070 (0x0004) [0x0000000C01202000] [0x00000001] (CPF_Transient)
	uint32_t                                           bIsCurrentDebuggerOp : 1;                      // 0x0070 (0x0004) [0x0000000C01202000] [0x00000002] (CPF_Transient)
	uint32_t                                           bActive : 1;                                   // 0x0070 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bLatentExecution : 1;                          // 0x0070 (0x0004) [0x0000000000000002] [0x00000008] (CPF_Const)
	uint32_t                                           bSupportsMultipleActivations : 1;              // 0x0070 (0x0004) [0x0000000000000002] [0x00000010] (CPF_Const)
	uint32_t                                           bAutoActivateOutputLinks : 1;                  // 0x0070 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bHaveMovingVarConnector : 1;                   // 0x0070 (0x0004) [0x0000000800002000] [0x00000040] (CPF_Transient)
	uint32_t                                           bHaveMovingInputConnector : 1;                 // 0x0070 (0x0004) [0x0000000800002000] [0x00000080] (CPF_Transient)
	uint32_t                                           bHaveMovingOutputConnector : 1;                // 0x0070 (0x0004) [0x0000000800002000] [0x00000100] (CPF_Transient)
	uint32_t                                           bPendingVarConnectorRecalc : 1;                // 0x0070 (0x0004) [0x0000000800002000] [0x00000200] (CPF_Transient)
	uint32_t                                           bPendingInputConnectorRecalc : 1;              // 0x0070 (0x0004) [0x0000000800002000] [0x00000400] (CPF_Transient)
	uint32_t                                           bPendingOutputConnectorRecalc : 1;             // 0x0070 (0x0004) [0x0000000800002000] [0x00000800] (CPF_Transient)
	uint32_t                                           bIsBreakpointSet : 1;                          // 0x0070 (0x0004) [0x0000000800000000] [0x00001000] 
	uint32_t                                           bIsHiddenBreakpointSet : 1;                    // 0x0070 (0x0004) [0x0000000C01202000] [0x00002000] (CPF_Transient)
	uint32_t                                           bFlipWidgetVertical : 1;                       // 0x0070 (0x0004) [0x0000000800000001] [0x00004000] (CPF_Edit)
	class TArray<struct FSeqOpInputLink>               InputLinks;                                    // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FSeqOpOutputLink>              OutputLinks;                                   // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FSeqVarLink>                   VariableLinks;                                 // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FSeqEventLink>                 EventLinks;                                    // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            PlayerIndex;                                   // 0x00B8 (0x0004) [0x0000000001002000] (CPF_Transient)
	uint8_t                                            GamepadID;                                     // 0x00BC (0x0001) [0x0000000001002000] (CPF_Transient)
	int32_t                                            ActivateCount;                                 // 0x00C0 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            SearchTag;                                     // 0x00C4 (0x0004) [0x0000000000202002] (CPF_Const | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SequenceOp");
		}

		return uClassPointer;
	};

	void ForceActivateOutput(int32_t OutputIdx);
	void ForceActivateInput(int32_t InputIdx);
	class AController* GetController(class AActor* TheActor);
	class APawn* GetPawn(class AActor* TheActor);
	void Reset();
	void PublishLinkedVariableValues();
	void PopulateLinkedVariableValues();
	void eventVersionUpdated(int32_t OldVersion, int32_t NewVersion);
	void eventDeactivated();
	void eventActivated();
	bool ActivateNamedOutputLink(const class FString& LinkDesc);
	bool ActivateOutputLink(int32_t OutputIdx);
	void GetBoolVars(const class FString& optionalInDesc, class TArray<uint8_t>& boolVars);
	void GetInterpDataVars(const class FString& optionalInDesc, class TArray<class UInterpData*>& outIData);
	void GetObjectVarsW(const class FString& optionalInDesc, class TArray<class UObject*>& objVars);
	void GetLinkedObjects(class UClass* optionalObjectType, bool optionalBRecurse, class TArray<class USequenceObject*>& out_Objects);
	bool HasLinkedOps(bool optionalBConsiderInputLinks);
};

// Class Engine.SequenceEvent
// 0x0050 (0x00C8 - 0x0118)
class USequenceEvent : public USequenceOp
{
public:
	class TArray<class USequenceEvent*>                DuplicateEvts;                                 // 0x00C8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class AActor*                                      Originator;                                    // 0x00D8 (0x0008) [0x0000000000000000]               
	class AActor*                                      Instigator;                                    // 0x00E0 (0x0008) [0x0000000000000000]               
	float                                              ActivationTime;                                // 0x00E8 (0x0004) [0x0000000000000000]               
	int32_t                                            TriggerCount;                                  // 0x00EC (0x0004) [0x0000000000000000]               
	int32_t                                            MaxTriggerCount;                               // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ReTriggerDelay;                                // 0x00F4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bEnabled : 1;                                  // 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bPlayerOnly : 1;                               // 0x00F8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bExcludeBotPlayers : 1;                        // 0x00F8 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bAIOnly : 1;                                   // 0x00F8 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bRegistered : 1;                               // 0x00F8 (0x0004) [0x0000000000002000] [0x00000010] (CPF_Transient)
	uint32_t                                           bClientSideOnly : 1;                           // 0x00F8 (0x0004) [0x0000000000000003] [0x00000020] (CPF_Edit | CPF_Const)
	uint8_t                                            Priority;                                      // 0x00FC (0x0001) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MaxWidth;                                      // 0x0100 (0x0004) [0x0000000000000000]               
	class UPawnAllegiance*                             RequiredAllegiance;                            // 0x0108 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class USequenceEventCustomEnableCondition*         CustomEnableCondition;                         // 0x0110 (0x0008) [0x0000000004000003] (CPF_Edit | CPF_Const | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SequenceEvent");
		}

		return uClassPointer;
	};

	void eventToggled();
	void Reset();
	bool CheckActivate(class AActor* InOriginator, class AActor* InInstigator, bool optionalBTest, bool optionalBPushTop, class TArray<int32_t>& ActivateIndices);
	void eventRegisterEvent();
};

// Class Engine.SequenceEventCustomEnableCondition
// 0x0000 (0x0058 - 0x0058)
class USequenceEventCustomEnableCondition : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SequenceEventCustomEnableCondition");
		}

		return uClassPointer;
	};

};

// Class Engine.SequenceFrame
// 0x0018 (0x0070 - 0x0088)
class USequenceFrame : public USequenceObject
{
public:
	int32_t                                            SizeX;                                         // 0x0070 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            SizeY;                                         // 0x0074 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            BorderWidth;                                   // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDrawBox : 1;                                  // 0x007C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bFilled : 1;                                   // 0x007C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bTileFill : 1;                                 // 0x007C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	struct FColor                                      BorderColor;                                   // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FColor                                      FillColor;                                     // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SequenceFrame");
		}

		return uClassPointer;
	};

};

// Class Engine.SavingSequenceFrame
// 0x0000 (0x0088 - 0x0088)
class USavingSequenceFrame : public USequenceFrame
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SavingSequenceFrame");
		}

		return uClassPointer;
	};

};

// Class Engine.SequenceFrameWrapped
// 0x0000 (0x0088 - 0x0088)
class USequenceFrameWrapped : public USequenceFrame
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SequenceFrameWrapped");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqDef_Base
// 0x0008 (0x00C8 - 0x00D0)
class USeqDef_Base : public USequenceOp
{
public:
	class UGBXDefinition*                              Definition;                                    // 0x00C8 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqDef_Base");
		}

		return uClassPointer;
	};

};

// Class Engine.Sequence
// 0x0080 (0x00C8 - 0x0148)
class USequence : public USequenceOp
{
public:
	struct FPointer                                    LogFile;                                       // 0x00C8 (0x0008) [0x0000000000000002] (CPF_Const)   
	class TArray<class USequenceObject*>               SequenceObjects;                               // 0x00D0 (0x0010) [0x000000000040000A] (CPF_Const | CPF_ExportObject | CPF_NeedCtorLink)
	class TArray<class USequenceOp*>                   ActiveSequenceOps;                             // 0x00E0 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<class USequence*>                     NestedSequences;                               // 0x00F0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<class USequenceEvent*>                UnregisteredEvents;                            // 0x0100 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FActivateOp>                   DelayedActivatedOps;                           // 0x0110 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	uint32_t                                           bEnabled : 1;                                  // 0x0120 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class TArray<struct FQueuedActivationInfo>         QueuedActivations;                             // 0x0128 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            DefaultViewX;                                  // 0x0138 (0x0004) [0x0000000000000000]               
	int32_t                                            DefaultViewY;                                  // 0x013C (0x0004) [0x0000000000000000]               
	float                                              DefaultViewZoom;                               // 0x0140 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Sequence");
		}

		return uClassPointer;
	};

	void SetEnabled(bool bInEnabled);
	void Reset();
	void FindSeqObjectsByName(const class FString& SeqObjName, bool bCheckComment, bool optionalBRecursive, bool optionalBUseFullLevelName, class TArray<class USequenceObject*>& OutputObjects);
	void FindSeqObjectsByClass(class UClass* DesiredClass, bool bRecursive, class TArray<class USequenceObject*>& OutputObjects);
};

// Class Engine.PrefabSequence
// 0x0008 (0x0148 - 0x0150)
class UPrefabSequence : public USequence
{
public:
	class APrefabInstance*                             OwnerPrefab;                                   // 0x0148 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PrefabSequence");
		}

		return uClassPointer;
	};

	class APrefabInstance* GetOwnerPrefab();
	void SetOwnerPrefab(class APrefabInstance* InOwner);
};

// Class Engine.PrefabSequenceContainer
// 0x0000 (0x0148 - 0x0148)
class UPrefabSequenceContainer : public USequence
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PrefabSequenceContainer");
		}

		return uClassPointer;
	};

};

// Class Engine.SequenceDefinition
// 0x0000 (0x0148 - 0x0148)
class USequenceDefinition : public USequence
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SequenceDefinition");
		}

		return uClassPointer;
	};

};

// Class Engine.SequenceAction
// 0x0020 (0x00C8 - 0x00E8)
class USequenceAction : public USequenceOp
{
public:
	struct FName                                       HandlerName;                                   // 0x00C8 (0x0008) [0x0000000000000000]               
	uint32_t                                           bCallHandler : 1;                              // 0x00D0 (0x0004) [0x0000000000000000] [0x00000001] 
	class TArray<class UObject*>                       Targets;                                       // 0x00D8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SequenceAction");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ActivateRemoteEvent
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_ActivateRemoteEvent : public USequenceAction
{
public:
	class AActor*                                      Instigator;                                    // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       EventName;                                     // 0x00F0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bStatusIsOk : 1;                               // 0x00F8 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ActivateRemoteEvent");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_AndGate
// 0x0028 (0x00E8 - 0x0110)
class USeqAct_AndGate : public USequenceAction
{
public:
	uint32_t                                           bOpen : 1;                                     // 0x00E8 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)
	class TArray<uint32_t>                             LinkedOutputFiredStatus;                       // 0x00F0 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FPointer>                      LinkedOutputs;                                 // 0x0100 (0x0010) [0x0000000000003000] (CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_AndGate");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ApplyBehavior
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_ApplyBehavior : public USequenceAction
{
public:
	class TArray<class UBehaviorBase*>                 Behaviors;                                     // 0x00E8 (0x0010) [0x0000000004400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink | CPF_EditInline)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ApplyBehavior");
		}

		return uClassPointer;
	};

	void eventApplyBehaviors(class UObject* Context);
};

// Class Engine.SeqAct_AssignController
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_AssignController : public USequenceAction
{
public:
	class UClass*                                      ControllerClass;                               // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_AssignController");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_AttachToActor
// 0x0028 (0x00E8 - 0x0110)
class USeqAct_AttachToActor : public USequenceAction
{
public:
	uint32_t                                           bDetach : 1;                                   // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bHardAttach : 1;                               // 0x00E8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bUseRelativeOffset : 1;                        // 0x00E8 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bUseRelativeRotation : 1;                      // 0x00E8 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bUseConstructAttachment : 1;                   // 0x00E8 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	struct FName                                       BoneName;                                      // 0x00EC (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     RelativeOffset;                                // 0x00F4 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FRotator                                    RelativeRotation;                              // 0x0100 (0x000C) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_AttachToActor");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_AttachToEvent
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_AttachToEvent : public USequenceAction
{
public:
	uint32_t                                           bPreferController : 1;                         // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_AttachToEvent");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_CameraFade
// 0x0030 (0x00E8 - 0x0118)
class USeqAct_CameraFade : public USequenceAction
{
public:
	struct FColor                                      FadeColor;                                     // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   FadeAlpha;                                     // 0x00EC (0x0008) [0x0000000020000000]  CPF_Deprecated)
	float                                              FadeOpacity;                                   // 0x00F4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FadeTime;                                      // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bPersistFade : 1;                              // 0x00FC (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              FadeTimeRemaining;                             // 0x0100 (0x0004) [0x0000000000000000]               
	class TArray<class APlayerController*>             CachedPCs;                                     // 0x0108 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_CameraFade");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_CameraLookAt
// 0x0040 (0x00E8 - 0x0128)
class USeqAct_CameraLookAt : public USequenceAction
{
public:
	uint32_t                                           bAffectCamera : 1;                             // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAlwaysFocus : 1;                              // 0x00E8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bAdjustCamera : 1;                             // 0x00E8 (0x0004) [0x0000000020000000] [0x00000004]  CPF_Deprecated)
	uint32_t                                           bTurnInPlace : 1;                              // 0x00E8 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bIgnoreTrace : 1;                              // 0x00E8 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bAffectHead : 1;                               // 0x00E8 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bRotatePlayerWithCamera : 1;                   // 0x00E8 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bToggleGodMode : 1;                            // 0x00E8 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bLeaveCameraRotation : 1;                      // 0x00E8 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bDisableInput : 1;                             // 0x00E8 (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bUsedTimer : 1;                                // 0x00E8 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bCheckLineOfSight : 1;                         // 0x00E8 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	struct FVector2D                                   InterpSpeedRange;                              // 0x00EC (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector2D                                   InFocusFOV;                                    // 0x00F4 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       FocusBoneName;                                 // 0x00FC (0x0008) [0x0000000000000001] (CPF_Edit)    
	class FString                                      TextDisplay;                                   // 0x0108 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              TotalTime;                                     // 0x0118 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CameraFOV;                                     // 0x011C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              RemainingTime;                                 // 0x0120 (0x0004) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_CameraLookAt");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_ChangeCollision
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_ChangeCollision : public USequenceAction
{
public:
	uint32_t                                           bCollideActors : 1;                            // 0x00E8 (0x0004) [0x0000000000020003] [0x00000001] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bBlockActors : 1;                              // 0x00E8 (0x0004) [0x0000000000020003] [0x00000002] (CPF_Edit | CPF_Const | CPF_EditConst)
	uint32_t                                           bIgnoreEncroachers : 1;                        // 0x00E8 (0x0004) [0x0000000000020003] [0x00000004] (CPF_Edit | CPF_Const | CPF_EditConst)
	ECollisionType                                     CollisionType;                                 // 0x00EC (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ChangeCollision");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_CommitMapChange
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_CommitMapChange : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_CommitMapChange");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ConsoleCommand
// 0x0020 (0x00E8 - 0x0108)
class USeqAct_ConsoleCommand : public USequenceAction
{
public:
	class FString                                      Command;                                       // 0x00E8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<class FString>                        Commands;                                      // 0x00F8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ConsoleCommand");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
	void VersionUpdated(int32_t OldVersion, int32_t NewVersion);
};

// Class Engine.SeqAct_ControlMovieTexture
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_ControlMovieTexture : public USequenceAction
{
public:
	class UTextureMovie*                               MovieTexture;                                  // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ControlMovieTexture");
		}

		return uClassPointer;
	};

	void eventActivated();
};

// Class Engine.SeqAct_ConvertToString
// 0x0020 (0x00E8 - 0x0108)
class USeqAct_ConvertToString : public USequenceAction
{
public:
	uint32_t                                           bIncludeVarComment : 1;                        // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class FString                                      VarSeparator;                                  // 0x00F0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	int32_t                                            NumberOfInputs;                                // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ConvertToString");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_Destroy
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_Destroy : public USequenceAction
{
public:
	uint32_t                                           bDestroyBasedActors : 1;                       // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class TArray<class UClass*>                        IgnoreBasedClasses;                            // 0x00F0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Destroy");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_DrawText
// 0x0048 (0x00E8 - 0x0130)
class USeqAct_DrawText : public USequenceAction
{
public:
	float                                              DisplayTimeSeconds;                            // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDisplayOnObject : 1;                          // 0x00EC (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FKismetDrawTextInfo                         DrawTextInfo;                                  // 0x00F0 (0x0040) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_DrawText");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_FinishSequence
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_FinishSequence : public USequenceAction
{
public:
	class FString                                      OutputLabel;                                   // 0x00E8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_FinishSequence");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_FlyThroughHasEnded
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_FlyThroughHasEnded : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_FlyThroughHasEnded");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ForceFeedback
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_ForceFeedback : public USequenceAction
{
public:
	class UForceFeedbackWaveform*                      FFWaveform;                                    // 0x00E8 (0x0008) [0x0000000004000001] (CPF_Edit | CPF_EditInline)
	class UClass*                                      PredefinedWaveForm;                            // 0x00F0 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ForceFeedback");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_Gate
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_Gate : public USequenceAction
{
public:
	uint32_t                                           bOpen : 1;                                     // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	int32_t                                            AutoCloseCount;                                // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            CurrentCloseCount;                             // 0x00F0 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Gate");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_GetDistance
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_GetDistance : public USequenceAction
{
public:
	float                                              Distance;                                      // 0x00E8 (0x0004) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	EDistanceMethod                                    Method;                                        // 0x00EC (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_GetDistance");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_GetLocationAndRotation
// 0x0030 (0x00E8 - 0x0118)
class USeqAct_GetLocationAndRotation : public USequenceAction
{
public:
	struct FVector                                     Location;                                      // 0x00E8 (0x000C) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	struct FVector                                     RotationVector;                                // 0x00F4 (0x000C) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	struct FVector                                     Rotation;                                      // 0x0100 (0x000C) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	struct FName                                       SocketOrBoneName;                              // 0x010C (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_GetLocationAndRotation");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_GetProperty
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_GetProperty : public USequenceAction
{
public:
	struct FName                                       PropertyName;                                  // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_GetProperty");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_GetVectorComponents
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_GetVectorComponents : public USequenceAction
{
public:
	struct FVector                                     InVector;                                      // 0x00E8 (0x000C) [0x0000000000000000]               
	float                                              X;                                             // 0x00F4 (0x0004) [0x0000000000000000]               
	float                                              Y;                                             // 0x00F8 (0x0004) [0x0000000000000000]               
	float                                              Z;                                             // 0x00FC (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_GetVectorComponents");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_GetVelocity
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_GetVelocity : public USequenceAction
{
public:
	float                                              VelocityMag;                                   // 0x00E8 (0x0004) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	struct FVector                                     VelocityVect;                                  // 0x00EC (0x000C) [0x0000000000020001] (CPF_Edit | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_GetVelocity");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_HeadTrackingControl
// 0x00A8 (0x00E8 - 0x0190)
class USeqAct_HeadTrackingControl : public USequenceAction
{
public:
	class TArray<struct FName>                         TrackControllerName;                           // 0x00E8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              LookAtActorRadius;                             // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDisableBeyondLimit : 1;                       // 0x00FC (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bLookAtPawns : 1;                              // 0x00FC (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              MaxLookAtTime;                                 // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MinLookAtTime;                                 // 0x0104 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxInterestTime;                               // 0x0108 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<class UClass*>                        ActorClassesToLookAt;                          // 0x0110 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FName>                         TargetBoneNames;                               // 0x0120 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UObject*>                       LookAtTargets;                                 // 0x0130 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint8_t                                           UnknownData00[0x50];                           // 0x0140 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.SeqAct_HeadTrackingControl.ActorToComponentMap

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_HeadTrackingControl");
		}

		return uClassPointer;
	};

	void eventActivated();
	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_IsInObjectList
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_IsInObjectList : public USequenceAction
{
public:
	uint32_t                                           bCheckForAllObjects : 1;                       // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bObjectFound : 1;                              // 0x00E8 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_IsInObjectList");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_Latent
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_Latent : public USequenceAction
{
public:
	class TArray<class AActor*>                        LatentActors;                                  // 0x00E8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint32_t                                           bAborted : 1;                                  // 0x00F8 (0x0004) [0x0000000000000000] [0x00000001] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Latent");
		}

		return uClassPointer;
	};

	bool eventUpdate(float DeltaTime);
	void AbortFor(class AActor* latentActor);
};

// Class Engine.SeqAct_ActorFactory
// 0x0060 (0x0100 - 0x0160)
class USeqAct_ActorFactory : public USeqAct_Latent
{
public:
	uint32_t                                           bEnabled : 1;                                  // 0x0100 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bIsSpawning : 1;                               // 0x0100 (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bCheckSpawnCollision : 1;                      // 0x0100 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	class UActorFactory*                               Factory;                                       // 0x0108 (0x0008) [0x0000000004400009] (CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline)
	EPointSelection                                    PointSelection;                                // 0x0110 (0x0001) [0x0000000000000001] (CPF_Edit)    
	class TArray<class AActor*>                        SpawnPoints;                                   // 0x0118 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FVector>                       SpawnLocations;                                // 0x0128 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FVector>                       SpawnOrientations;                             // 0x0138 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	int32_t                                            SpawnCount;                                    // 0x0148 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SpawnDelay;                                    // 0x014C (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            LastSpawnIdx;                                  // 0x0150 (0x0004) [0x0000000000000000]               
	int32_t                                            SpawnedCount;                                  // 0x0154 (0x0004) [0x0000000000000000]               
	float                                              RemainingDelay;                                // 0x0158 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ActorFactory");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_ActorFactoryEx
// 0x0000 (0x0160 - 0x0160)
class USeqAct_ActorFactoryEx : public USeqAct_ActorFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ActorFactoryEx");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ProjectileFactory
// 0x0018 (0x0160 - 0x0178)
class USeqAct_ProjectileFactory : public USeqAct_ActorFactory
{
public:
	class UParticleSystem*                             PSTemplate;                                    // 0x0160 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       SocketName;                                    // 0x0168 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       BoneName;                                      // 0x0170 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ProjectileFactory");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_AIMoveToActor
// 0x0000 (0x0100 - 0x0100)
class USeqAct_AIMoveToActor : public USeqAct_Latent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_AIMoveToActor");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_Delay
// 0x0018 (0x0100 - 0x0118)
class USeqAct_Delay : public USeqAct_Latent
{
public:
	uint32_t                                           bDelayActive : 1;                              // 0x0100 (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)
	uint32_t                                           bStartWillRestart : 1;                         // 0x0100 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              DefaultDuration;                               // 0x0104 (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              Duration;                                      // 0x0108 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LastUpdateTime;                                // 0x010C (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              RemainingTime;                                 // 0x0110 (0x0004) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Delay");
		}

		return uClassPointer;
	};

	void ResetDelayActive();
	void Reset();
};

// Class Engine.SeqAct_DelaySwitch
// 0x0010 (0x0100 - 0x0110)
class USeqAct_DelaySwitch : public USeqAct_Latent
{
public:
	int32_t                                            LinkCount;                                     // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            CurrentIdx;                                    // 0x0104 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              SwitchDelay;                                   // 0x0108 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              NextLinkTime;                                  // 0x010C (0x0004) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_DelaySwitch");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ForceGarbageCollection
// 0x0000 (0x0100 - 0x0100)
class USeqAct_ForceGarbageCollection : public USeqAct_Latent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ForceGarbageCollection");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_Interp
// 0x0110 (0x0100 - 0x0210)
class USeqAct_Interp : public USeqAct_Latent
{
public:
	uint8_t                                           UnknownData00[0x50];                           // 0x0100 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.SeqAct_Interp.SavedActorTransforms
	uint8_t                                           UnknownData01[0x50];                           // 0x0150 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.SeqAct_Interp.SavedActorVisibilities
	float                                              PlayRate;                                      // 0x01A0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Position;                                      // 0x01A4 (0x0004) [0x0000000000000000]               
	float                                              ForceStartPosition;                            // 0x01A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bIsPlaying : 1;                                // 0x01AC (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bPaused : 1;                                   // 0x01AC (0x0004) [0x0000000000000000] [0x00000002] 
	uint32_t                                           bIsBeingEdited : 1;                            // 0x01AC (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)
	uint32_t                                           bLooping : 1;                                  // 0x01AC (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bRewindOnPlay : 1;                             // 0x01AC (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bNoResetOnRewind : 1;                          // 0x01AC (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bRewindIfAlreadyPlaying : 1;                   // 0x01AC (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bReversePlayback : 1;                          // 0x01AC (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bInterpForPathBuilding : 1;                    // 0x01AC (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bForceStartPos : 1;                            // 0x01AC (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bDisableRadioFilter : 1;                       // 0x01AC (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	uint32_t                                           bClientSideOnly : 1;                           // 0x01AC (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)
	uint32_t                                           bSkipUpdateIfNotVisible : 1;                   // 0x01AC (0x0004) [0x0000000000000001] [0x00001000] (CPF_Edit)
	uint32_t                                           bIsSkippable : 1;                              // 0x01AC (0x0004) [0x0000000000000001] [0x00002000] (CPF_Edit)
	uint32_t                                           bIsSkipped : 1;                                // 0x01AC (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bShouldShowGore : 1;                           // 0x01AC (0x0004) [0x0000000000002000] [0x00008000] (CPF_Transient)
	uint32_t                                           TestForInputActorsOnClient : 1;                // 0x01AC (0x0004) [0x0000000000000001] [0x00010000] (CPF_Edit)
	uint32_t                                           bFireEventsWhenJumpToLastFrame : 1;            // 0x01AC (0x0004) [0x0000000000000001] [0x00020000] (CPF_Edit)
	uint32_t                                           bFireCompleteEventWhenJumpToLastFrame : 1;     // 0x01AC (0x0004) [0x0000000000000001] [0x00040000] (CPF_Edit)
	uint32_t                                           bLastFrameEventFired : 1;                      // 0x01AC (0x0004) [0x0000000000002000] [0x00080000] (CPF_Transient)
	uint32_t                                           bSkipNextUpdate : 1;                           // 0x01AC (0x0004) [0x0000000000002000] [0x00100000] (CPF_Transient)
	uint32_t                                           bInitialReplication : 1;                       // 0x01AC (0x0004) [0x0000000000002000] [0x00200000] (CPF_Transient)
	uint8_t                                            PlayId;                                        // 0x01B0 (0x0001) [0x0000000000000000]               
	class TArray<class ACoverLink*>                    LinkedCover;                                   // 0x01B8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class UInterpData*                                 InterpData;                                    // 0x01C8 (0x0008) [0x0000000000000008] (CPF_ExportObject)
	class TArray<class UInterpGroupInst*>              GroupInst;                                     // 0x01D0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class UClass*                                      ReplicatedActorClass;                          // 0x01E0 (0x0008) [0x0000000000000002] (CPF_Const)   
	class AMatineeActor*                               ReplicatedActor;                               // 0x01E8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            PreferredSplitScreenNum;                       // 0x01F0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FCameraCutInfo>                CameraCuts;                                    // 0x01F8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	float                                              TerminationTime;                               // 0x0208 (0x0004) [0x0000000000000000]               
	struct FRenderingPerformanceOverrides              RenderingOverrides;                            // 0x020C (0x0004) [0x0000000000044001] (CPF_Edit | CPF_Config | CPF_GlobalConfig)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Interp");
		}

		return uClassPointer;
	};

	bool IsNetworkReady();
	static int32_t eventGetObjClassVersion();
	void Reset();
	void AddPlayerToDirectorTracks(class APlayerController* PC);
	void Stop();
	void SetPosition(float NewPosition, bool optionalBJump);
};

// Class Engine.SeqAct_LevelStreamingBase
// 0x0010 (0x0100 - 0x0110)
class USeqAct_LevelStreamingBase : public USeqAct_Latent
{
public:
	uint32_t                                           bMakeVisibleAfterLoad : 1;                     // 0x0100 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bShouldBlockOnLoad : 1;                        // 0x0100 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	class AActor*                                      Instigator;                                    // 0x0108 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_LevelStreamingBase");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_LevelStreaming
// 0x0018 (0x0110 - 0x0128)
class USeqAct_LevelStreaming : public USeqAct_LevelStreamingBase
{
public:
	class ULevelStreaming*                             Level;                                         // 0x0110 (0x0008) [0x0000000000000002] (CPF_Const)   
	struct FName                                       LevelName;                                     // 0x0118 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bStatusIsOk : 1;                               // 0x0120 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_LevelStreaming");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_MultiLevelStreaming
// 0x0018 (0x0110 - 0x0128)
class USeqAct_MultiLevelStreaming : public USeqAct_LevelStreamingBase
{
public:
	class TArray<struct FLevelStreamingNameCombo>      Levels;                                        // 0x0110 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bUnloadAllOtherLevels : 1;                     // 0x0120 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bStatusIsOk : 1;                               // 0x0120 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_MultiLevelStreaming");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_LevelVisibility
// 0x0018 (0x0100 - 0x0118)
class USeqAct_LevelVisibility : public USeqAct_Latent
{
public:
	class ULevelStreaming*                             Level;                                         // 0x0100 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       LevelName;                                     // 0x0108 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bStatusIsOk : 1;                               // 0x0110 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_LevelVisibility");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_PrepareMapChange
// 0x0020 (0x0100 - 0x0120)
class USeqAct_PrepareMapChange : public USeqAct_Latent
{
public:
	struct FName                                       MainLevelName;                                 // 0x0100 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FName>                         InitiallyLoadedSecondaryLevelNames;            // 0x0108 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bIsHighPriority : 1;                           // 0x0118 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bTransitionToFakeEntry : 1;                    // 0x0118 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bStatusIsOk : 1;                               // 0x0118 (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_PrepareMapChange");
		}

		return uClassPointer;
	};

	static void SetSavedLevels(const class TArray<struct FName>& SavedLevels);
};

// Class Engine.SeqAct_SetDOFParams
// 0x0058 (0x0100 - 0x0158)
class USeqAct_SetDOFParams : public USeqAct_Latent
{
public:
	float                                              FalloffExponent;                               // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlurKernelSize;                                // 0x0104 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxNearBlurAmount;                             // 0x0108 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MinBlurAmount;                                 // 0x010C (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MaxFarBlurAmount;                              // 0x0110 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FocusInnerRadius;                              // 0x0114 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FocusDistance;                                 // 0x0118 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     FocusPosition;                                 // 0x011C (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              InterpolateSeconds;                            // 0x0128 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              InterpolateElapsed;                            // 0x012C (0x0004) [0x0000000000000000]               
	float                                              OldFalloffExponent;                            // 0x0130 (0x0004) [0x0000000000000000]               
	float                                              OldBlurKernelSize;                             // 0x0134 (0x0004) [0x0000000000000000]               
	float                                              OldMaxNearBlurAmount;                          // 0x0138 (0x0004) [0x0000000000000000]               
	float                                              OldMinBlurAmount;                              // 0x013C (0x0004) [0x0000000000000000]               
	float                                              OldMaxFarBlurAmount;                           // 0x0140 (0x0004) [0x0000000000000000]               
	float                                              OldFocusInnerRadius;                           // 0x0144 (0x0004) [0x0000000000000000]               
	float                                              OldFocusDistance;                              // 0x0148 (0x0004) [0x0000000000000000]               
	struct FVector                                     OldFocusPosition;                              // 0x014C (0x000C) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetDOFParams");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_StreamInTextures
// 0x0048 (0x0100 - 0x0148)
class USeqAct_StreamInTextures : public USeqAct_Latent
{
public:
	uint32_t                                           bLocationBased : 1;                            // 0x0100 (0x0004) [0x0000000020000000] [0x00000001]  CPF_Deprecated)
	uint32_t                                           bStreamingActive : 1;                          // 0x0100 (0x0004) [0x0000000000000002] [0x00000002] (CPF_Const)
	uint32_t                                           bHasTriggeredAllLoaded : 1;                    // 0x0100 (0x0004) [0x0000000000000002] [0x00000004] (CPF_Const)
	float                                              Seconds;                                       // 0x0104 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              StreamingDistanceMultiplier;                   // 0x0108 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            NumWantingResourcesID;                         // 0x010C (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              StopTimestamp;                                 // 0x0110 (0x0004) [0x0000000000000002] (CPF_Const)   
	class TArray<class UObject*>                       LocationActors;                                // 0x0118 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UMaterialInterface*>            ForceMaterials;                                // 0x0128 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FTextureGroupContainer                      CinematicTextureGroups;                        // 0x0138 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FQWord                                      SelectedCinematicTextureGroups;                // 0x0140 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_StreamInTextures");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_WaitForLevelsVisible
// 0x0018 (0x0100 - 0x0118)
class USeqAct_WaitForLevelsVisible : public USeqAct_Latent
{
public:
	class TArray<struct FName>                         LevelNames;                                    // 0x0100 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bShouldBlockOnLoad : 1;                        // 0x0110 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_WaitForLevelsVisible");
		}

		return uClassPointer;
	};

	void eventActivated();
	bool CheckLevelsVisible();
};

// Class Engine.SeqAct_Log
// 0x0028 (0x00E8 - 0x0110)
class USeqAct_Log : public USequenceAction
{
public:
	uint32_t                                           bOutputToScreen : 1;                           // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bIncludeObjComment : 1;                        // 0x00E8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              TargetDuration;                                // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     TargetOffset;                                  // 0x00F0 (0x000C) [0x0000000000000001] (CPF_Edit)    
	class FString                                      LogMessage;                                    // 0x0100 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Log");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_ModifyHealth
// 0x0030 (0x00E8 - 0x0118)
class USeqAct_ModifyHealth : public USequenceAction
{
public:
	class UClass*                                      DamageType;                                    // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UDamageTypeDefinition*                       DamageTypeDefinition;                          // 0x00F0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UImpactDefinition*                           ImpactDefinition;                              // 0x00F8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              Momentum;                                      // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Amount;                                        // 0x0104 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Radius;                                        // 0x0108 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bHeal : 1;                                     // 0x010C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bRadial : 1;                                   // 0x010C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bFalloff : 1;                                  // 0x010C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	class AActor*                                      Instigator;                                    // 0x0110 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ModifyHealth");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_ParticleEventGenerator
// 0x0058 (0x00E8 - 0x0140)
class USeqAct_ParticleEventGenerator : public USequenceAction
{
public:
	uint32_t                                           bEnabled : 1;                                  // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseEmitterLocation : 1;                       // 0x00E8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	class AActor*                                      Instigator;                                    // 0x00F0 (0x0008) [0x0000000000000000]               
	class TArray<class FString>                        EventNames;                                    // 0x00F8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              EventTime;                                     // 0x0108 (0x0004) [0x0000000000000000]               
	struct FVector                                     EventLocation;                                 // 0x010C (0x000C) [0x0000000000000000]               
	struct FVector                                     EventDirection;                                // 0x0118 (0x000C) [0x0000000000000000]               
	struct FVector                                     EventVelocity;                                 // 0x0124 (0x000C) [0x0000000000000000]               
	struct FVector                                     EventNormal;                                   // 0x0130 (0x000C) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ParticleEventGenerator");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_PhysXSwitch
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_PhysXSwitch : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_PhysXSwitch");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_PlayCameraAnim
// 0x0028 (0x00E8 - 0x0110)
class USeqAct_PlayCameraAnim : public USequenceAction
{
public:
	class UCameraAnim*                                 CameraAnim;                                    // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bLoop : 1;                                     // 0x00F0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bRandomStartTime : 1;                          // 0x00F0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              BlendInTime;                                   // 0x00F4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              BlendOutTime;                                  // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Rate;                                          // 0x00FC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              IntensityScale;                                // 0x0100 (0x0004) [0x0000000000000001] (CPF_Edit)    
	ECameraAnimPlaySpace                               PlaySpace;                                     // 0x0104 (0x0001) [0x0000000000000001] (CPF_Edit)    
	class AActor*                                      UserDefinedSpaceActor;                         // 0x0108 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_PlayCameraAnim");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_PlayFaceFXAnim
// 0x0030 (0x00E8 - 0x0118)
class USeqAct_PlayFaceFXAnim : public USequenceAction
{
public:
	class UFaceFXAnimSet*                              FaceFXAnimSetRef;                              // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class FString                                      FaceFXGroupName;                               // 0x00F0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class FString                                      FaceFXAnimName;                                // 0x0100 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class UAkEvent*                                    AkEventToPlay;                                 // 0x0110 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_PlayFaceFXAnim");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_PlayMusicTrack
// 0x0028 (0x00E8 - 0x0110)
class USeqAct_PlayMusicTrack : public USequenceAction
{
public:
	struct FMusicTrackStruct                           MusicTrack;                                    // 0x00E8 (0x0028) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_PlayMusicTrack");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_Possess
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_Possess : public USequenceAction
{
public:
	class APawn*                                       PawnToPossess;                                 // 0x00E8 (0x0008) [0x0000000000002000] (CPF_Transient)
	uint32_t                                           bKillOldPawn : 1;                              // 0x00F0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bTryToLeaveVehicle : 1;                        // 0x00F0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bBypassVehicleEntryAnimation : 1;              // 0x00F0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Possess");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetApexClothingParam
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_SetApexClothingParam : public USequenceAction
{
public:
	uint32_t                                           bEnableApexClothingSimulation : 1;             // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetApexClothingParam");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetBlockRigidBody
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_SetBlockRigidBody : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetBlockRigidBody");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetCameraTarget
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_SetCameraTarget : public USequenceAction
{
public:
	class AActor*                                      CameraTarget;                                  // 0x00E8 (0x0008) [0x0000000000002000] (CPF_Transient)
	struct FViewTargetTransitionParams                 TransitionParams;                              // 0x00F0 (0x0010) [0x0000000000000003] (CPF_Edit | CPF_Const)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetCameraTarget");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_SetDamageInstigator
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_SetDamageInstigator : public USequenceAction
{
public:
	class AActor*                                      DamageInstigator;                              // 0x00E8 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetDamageInstigator");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetMaterial
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_SetMaterial : public USequenceAction
{
public:
	class UMaterialInterface*                          NewMaterial;                                   // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            MaterialIndex;                                 // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetMaterial");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetMatInstScalarParam
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_SetMatInstScalarParam : public USequenceAction
{
public:
	class UMaterialInstance*                           MatInst;                                       // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       ParamName;                                     // 0x00F0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              ScalarValue;                                   // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetMatInstScalarParam");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetMesh
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_SetMesh : public USequenceAction
{
public:
	class USkeletalMesh*                               NewSkeletalMesh;                               // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UStaticMesh*                                 NewStaticMesh;                                 // 0x00F0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	EMeshType                                          MeshType;                                      // 0x00F8 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bIsAllowedToMove : 1;                          // 0x00FC (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAllowDecalsToReattach : 1;                    // 0x00FC (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetMesh");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetMotionBlurParams
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_SetMotionBlurParams : public USequenceAction
{
public:
	float                                              MotionBlurScale;                               // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ZExtent;                                       // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              CameraVelocityScale;                           // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ObjectsVelocityScale;                          // 0x00F4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TranslucencyVelocityScale;                     // 0x00F8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetMotionBlurParams");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetParticleSysParam
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_SetParticleSysParam : public USequenceAction
{
public:
	class TArray<struct FParticleSysParam>             InstanceParameters;                            // 0x00E8 (0x0010) [0x0000000004480009] (CPF_Edit | CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline)
	uint32_t                                           bOverrideScalar : 1;                           // 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              ScalarValue;                                   // 0x00FC (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetParticleSysParam");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetPhysics
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_SetPhysics : public USequenceAction
{
public:
	EPhysics                                           newPhysics;                                    // 0x00E8 (0x0001) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetPhysics");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetRigidBodyIgnoreVehicles
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_SetRigidBodyIgnoreVehicles : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetRigidBodyIgnoreVehicles");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetSequenceVariable
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_SetSequenceVariable : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetSequenceVariable");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_AccessObjectList
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_AccessObjectList : public USeqAct_SetSequenceVariable
{
public:
	class UObject*                                     OutputObject;                                  // 0x00E8 (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	int32_t                                            ObjectIndex;                                   // 0x00F0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_AccessObjectList");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_AddFloat
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_AddFloat : public USeqAct_SetSequenceVariable
{
public:
	float                                              ValueA;                                        // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ValueB;                                        // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FloatResult;                                   // 0x00F0 (0x0004) [0x0000000000000000]               
	int32_t                                            IntResult;                                     // 0x00F4 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_AddFloat");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_AddInt
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_AddInt : public USeqAct_SetSequenceVariable
{
public:
	int32_t                                            ValueA;                                        // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            ValueB;                                        // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FloatResult;                                   // 0x00F0 (0x0004) [0x0000000000000000]               
	int32_t                                            IntResult;                                     // 0x00F4 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_AddInt");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_CastToFloat
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_CastToFloat : public USeqAct_SetSequenceVariable
{
public:
	int32_t                                            Value;                                         // 0x00E8 (0x0004) [0x0000000000000000]               
	float                                              FloatResult;                                   // 0x00EC (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_CastToFloat");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_CastToInt
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_CastToInt : public USeqAct_SetSequenceVariable
{
public:
	uint32_t                                           bTruncate : 1;                                 // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              Value;                                         // 0x00EC (0x0004) [0x0000000000000000]               
	int32_t                                            IntResult;                                     // 0x00F0 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_CastToInt");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_DivideFloat
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_DivideFloat : public USeqAct_SetSequenceVariable
{
public:
	float                                              ValueA;                                        // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ValueB;                                        // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FloatResult;                                   // 0x00F0 (0x0004) [0x0000000000000000]               
	int32_t                                            IntResult;                                     // 0x00F4 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_DivideFloat");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_DivideInt
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_DivideInt : public USeqAct_SetSequenceVariable
{
public:
	int32_t                                            ValueA;                                        // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            ValueB;                                        // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FloatResult;                                   // 0x00F0 (0x0004) [0x0000000000000000]               
	int32_t                                            IntResult;                                     // 0x00F4 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_DivideInt");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ModifyObjectList
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_ModifyObjectList : public USeqAct_SetSequenceVariable
{
public:
	int32_t                                            ListEntriesCount;                              // 0x00E8 (0x0004) [0x0000000000020001] (CPF_Edit | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ModifyObjectList");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_MultiplyFloat
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_MultiplyFloat : public USeqAct_SetSequenceVariable
{
public:
	float                                              ValueA;                                        // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ValueB;                                        // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FloatResult;                                   // 0x00F0 (0x0004) [0x0000000000000000]               
	int32_t                                            IntResult;                                     // 0x00F4 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_MultiplyFloat");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_MultiplyInt
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_MultiplyInt : public USeqAct_SetSequenceVariable
{
public:
	int32_t                                            ValueA;                                        // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            ValueB;                                        // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FloatResult;                                   // 0x00F0 (0x0004) [0x0000000000000000]               
	int32_t                                            IntResult;                                     // 0x00F4 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_MultiplyInt");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetBool
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_SetBool : public USeqAct_SetSequenceVariable
{
public:
	uint32_t                                           DefaultValue : 1;                              // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetBool");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetFloat
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_SetFloat : public USeqAct_SetSequenceVariable
{
public:
	float                                              Target;                                        // 0x00E8 (0x0004) [0x0000000000000000]               
	class TArray<float>                                Value;                                         // 0x00F0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetFloat");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_SetInt
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_SetInt : public USeqAct_SetSequenceVariable
{
public:
	int32_t                                            Target;                                        // 0x00E8 (0x0004) [0x0000000000000000]               
	class TArray<int32_t>                              Value;                                         // 0x00F0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetInt");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_SetLocation
// 0x0028 (0x00E8 - 0x0110)
class USeqAct_SetLocation : public USeqAct_SetSequenceVariable
{
public:
	uint32_t                                           bSetLocation : 1;                              // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bSetRotation : 1;                              // 0x00E8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	struct FVector                                     LocationValue;                                 // 0x00EC (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FRotator                                    RotationValue;                                 // 0x00F8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	class UObject*                                     Target;                                        // 0x0108 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetLocation");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_SetObject
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_SetObject : public USeqAct_SetSequenceVariable
{
public:
	class UObject*                                     DefaultValue;                                  // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UObject*                                     Value;                                         // 0x00F0 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetObject");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_SetString
// 0x0020 (0x00E8 - 0x0108)
class USeqAct_SetString : public USeqAct_SetSequenceVariable
{
public:
	class FString                                      Target;                                        // 0x00E8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      Value;                                         // 0x00F8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetString");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_SetVector
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_SetVector : public USeqAct_SetSequenceVariable
{
public:
	struct FVector                                     DefaultValue;                                  // 0x00E8 (0x000C) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetVector");
		}

		return uClassPointer;
	};

	void eventActivated();
};

// Class Engine.SeqAct_SubtractFloat
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_SubtractFloat : public USeqAct_SetSequenceVariable
{
public:
	float                                              ValueA;                                        // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ValueB;                                        // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FloatResult;                                   // 0x00F0 (0x0004) [0x0000000000000000]               
	int32_t                                            IntResult;                                     // 0x00F4 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SubtractFloat");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SubtractInt
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_SubtractInt : public USeqAct_SetSequenceVariable
{
public:
	int32_t                                            ValueA;                                        // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            ValueB;                                        // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FloatResult;                                   // 0x00F0 (0x0004) [0x0000000000000000]               
	int32_t                                            IntResult;                                     // 0x00F4 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SubtractInt");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetSkelControlTarget
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_SetSkelControlTarget : public USequenceAction
{
public:
	struct FName                                       SkelControlName;                               // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class TArray<class UObject*>                       TargetActors;                                  // 0x00F0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetSkelControlTarget");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetVectorComponents
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_SetVectorComponents : public USequenceAction
{
public:
	struct FVector                                     OutVector;                                     // 0x00E8 (0x000C) [0x0000000000000000]               
	float                                              X;                                             // 0x00F4 (0x0004) [0x0000000000000000]               
	float                                              Y;                                             // 0x00F8 (0x0004) [0x0000000000000000]               
	float                                              Z;                                             // 0x00FC (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetVectorComponents");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_SetVelocity
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_SetVelocity : public USequenceAction
{
public:
	struct FVector                                     VelocityDir;                                   // 0x00E8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              VelocityMag;                                   // 0x00F4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bVelocityRelativeToActorRotation : 1;          // 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_SetVelocity");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_Switch
// 0x0020 (0x00E8 - 0x0108)
class USeqAct_Switch : public USequenceAction
{
public:
	int32_t                                            LinkCount;                                     // 0x00E8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            IncrementAmount;                               // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bLooping : 1;                                  // 0x00F0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bAutoDisableLinks : 1;                         // 0x00F0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	class TArray<int32_t>                              Indices;                                       // 0x00F8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Switch");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_RandomSwitch
// 0x0010 (0x0108 - 0x0118)
class USeqAct_RandomSwitch : public USeqAct_Switch
{
public:
	class TArray<int32_t>                              AutoDisabledIndices;                           // 0x0108 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_RandomSwitch");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_Teleport
// 0x0028 (0x00E8 - 0x0110)
class USeqAct_Teleport : public USequenceAction
{
public:
	uint32_t                                           bUpdateRotation : 1;                           // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bCheckOverlap : 1;                             // 0x00E8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bSkipHoldingCell : 1;                          // 0x00E8 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bTurnOffCinematicModeAfterTeleport : 1;        // 0x00E8 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bHideTeleportEffect : 1;                       // 0x00E8 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bPreserveVerticalMomentum : 1;                 // 0x00E8 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	float                                              TeleportDistance;                              // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<class AVolume*>                       TeleportVolumes;                               // 0x00F0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class UObject*                                     Source;                                        // 0x0100 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class AActor*                                      ResurrectStation;                              // 0x0108 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Teleport");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
	class AActor* GetFirstValidActorFromObjectInput(const class FString& InputName);
	class AActor* GetTeleportHoldingCell();
	class AActor* GetTeleportDestination();
	static bool ShouldTeleport(class AActor* TestActor, const struct FVector& TeleportLocation, float optionalTeleportDist, const class TArray<class AVolume*>& optionalVolumes);
};

// Class Engine.SeqAct_Timer
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_Timer : public USequenceAction
{
public:
	float                                              ActivationTime;                                // 0x00E8 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              Time;                                          // 0x00EC (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Timer");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_Toggle
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_Toggle : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Toggle");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ToggleHidden
// 0x0018 (0x00E8 - 0x0100)
class USeqAct_ToggleHidden : public USeqAct_Toggle
{
public:
	uint32_t                                           bToggleBasedActors : 1;                        // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class TArray<class UClass*>                        IgnoreBasedClasses;                            // 0x00F0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ToggleHidden");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ToggleInput
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_ToggleInput : public USeqAct_Toggle
{
public:
	uint32_t                                           bToggleMovement : 1;                           // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bToggleTurning : 1;                            // 0x00E8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ToggleInput");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ToggleCinematicMode
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_ToggleCinematicMode : public USequenceAction
{
public:
	class UCinematicModeDefinition*                    ModeDefinition;                                // 0x00E8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	ECinematicModeApplication                          ApplicationMode;                               // 0x00F0 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bDisableMovement : 1;                          // 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bDisableTurning : 1;                           // 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bHidePlayer : 1;                               // 0x00F4 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bDisableInput : 1;                             // 0x00F4 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bHideHUD : 1;                                  // 0x00F4 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bEnableGodMode : 1;                            // 0x00F4 (0x0004) [0x0000000000000001] [0x00000020] (CPF_Edit)
	uint32_t                                           bEnableNoTarget : 1;                           // 0x00F4 (0x0004) [0x0000000000000001] [0x00000040] (CPF_Edit)
	uint32_t                                           bAffectsAudio : 1;                             // 0x00F4 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	uint32_t                                           bCinematicSplitScreen : 1;                     // 0x00F4 (0x0004) [0x0000000000000001] [0x00000100] (CPF_Edit)
	uint32_t                                           bHideOutlines : 1;                             // 0x00F4 (0x0004) [0x0000000000000001] [0x00000200] (CPF_Edit)
	uint32_t                                           bDisableSkills : 1;                            // 0x00F4 (0x0004) [0x0000000000000001] [0x00000400] (CPF_Edit)
	uint32_t                                           bDisableScreenParticles : 1;                   // 0x00F4 (0x0004) [0x0000000000000001] [0x00000800] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ToggleCinematicMode");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ToggleConstraintDrive
// 0x0008 (0x00E8 - 0x00F0)
class USeqAct_ToggleConstraintDrive : public USequenceAction
{
public:
	uint32_t                                           bEnableAngularPositionDrive : 1;               // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bEnableAngularVelocityDrive : 1;               // 0x00E8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bEnableLinearPositionDrive : 1;                // 0x00E8 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bEnableLinearvelocityDrive : 1;                // 0x00E8 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ToggleConstraintDrive");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ToggleGodMode
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_ToggleGodMode : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ToggleGodMode");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ToggleHUD
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_ToggleHUD : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ToggleHUD");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_Trace
// 0x0040 (0x00E8 - 0x0128)
class USeqAct_Trace : public USequenceAction
{
public:
	uint32_t                                           bTraceActors : 1;                              // 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bTraceWorld : 1;                               // 0x00E8 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	struct FVector                                     TraceExtent;                                   // 0x00EC (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     StartOffset;                                   // 0x00F8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     EndOffset;                                     // 0x0104 (0x000C) [0x0000000000000001] (CPF_Edit)    
	class UObject*                                     HitObject;                                     // 0x0110 (0x0008) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	float                                              Distance;                                      // 0x0118 (0x0004) [0x0000000000020001] (CPF_Edit | CPF_EditConst)
	struct FVector                                     HitLocation;                                   // 0x011C (0x000C) [0x0000000000020001] (CPF_Edit | CPF_EditConst)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_Trace");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqAct_UpdatePhysBonesFromAnim
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_UpdatePhysBonesFromAnim : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_UpdatePhysBonesFromAnim");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SequenceCondition
// 0x0000 (0x00C8 - 0x00C8)
class USequenceCondition : public USequenceOp
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SequenceCondition");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_CompareBool
// 0x0008 (0x00C8 - 0x00D0)
class USeqCond_CompareBool : public USequenceCondition
{
public:
	uint32_t                                           bResult : 1;                                   // 0x00C8 (0x0004) [0x0000000000000000] [0x00000001] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_CompareBool");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqCond_CompareFloat
// 0x0008 (0x00C8 - 0x00D0)
class USeqCond_CompareFloat : public USequenceCondition
{
public:
	float                                              ValueA;                                        // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ValueB;                                        // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_CompareFloat");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_CompareInt
// 0x0008 (0x00C8 - 0x00D0)
class USeqCond_CompareInt : public USequenceCondition
{
public:
	int32_t                                            ValueA;                                        // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            ValueB;                                        // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_CompareInt");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_CompareObject
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_CompareObject : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_CompareObject");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_GetServerType
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_GetServerType : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_GetServerType");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqCond_Increment
// 0x0010 (0x00C8 - 0x00D8)
class USeqCond_Increment : public USequenceCondition
{
public:
	int32_t                                            IncrementAmount;                               // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            ValueA;                                        // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            ValueB;                                        // 0x00D0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_Increment");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_IncrementFloat
// 0x0010 (0x00C8 - 0x00D8)
class USeqCond_IncrementFloat : public USequenceCondition
{
public:
	float                                              IncrementAmount;                               // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ValueA;                                        // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ValueB;                                        // 0x00D0 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_IncrementFloat");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_IsAlive
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_IsAlive : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_IsAlive");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_IsBenchmarking
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_IsBenchmarking : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_IsBenchmarking");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqCond_IsConsole
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_IsConsole : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_IsConsole");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_IsInCombat
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_IsInCombat : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_IsInCombat");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_IsLoggedIn
// 0x0008 (0x00C8 - 0x00D0)
class USeqCond_IsLoggedIn : public USequenceCondition
{
public:
	int32_t                                            NumNeededLoggedIn;                             // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_IsLoggedIn");
		}

		return uClassPointer;
	};

	bool eventCheckLogins();
};

// Class Engine.SeqCond_IsPIE
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_IsPIE : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_IsPIE");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqCond_IsSameTeam
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_IsSameTeam : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_IsSameTeam");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_MatureLanguage
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_MatureLanguage : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_MatureLanguage");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_ShowGore
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_ShowGore : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_ShowGore");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqCond_SwitchBase
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_SwitchBase : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_SwitchBase");
		}

		return uClassPointer;
	};

	void eventRemoveValueEntry(int32_t RemoveIndex);
	void eventInsertValueEntry(int32_t InsertIndex);
	bool eventIsFallThruEnabled(int32_t ValueIndex);
	void eventVerifyDefaultCaseValue();
};

// Class Engine.SeqCond_SwitchClass
// 0x0010 (0x00C8 - 0x00D8)
class USeqCond_SwitchClass : public USeqCond_SwitchBase
{
public:
	class TArray<struct FSwitchClassInfo>              ClassArray;                                    // 0x00C8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_SwitchClass");
		}

		return uClassPointer;
	};

	void eventRemoveValueEntry(int32_t RemoveIndex);
	void eventInsertValueEntry(int32_t InsertIndex);
	bool eventIsFallThruEnabled(int32_t ValueIndex);
	void eventVerifyDefaultCaseValue();
};

// Class Engine.SeqCond_SwitchObject
// 0x0010 (0x00C8 - 0x00D8)
class USeqCond_SwitchObject : public USeqCond_SwitchBase
{
public:
	class TArray<struct FSwitchObjectCase>             SupportedValues;                               // 0x00C8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_SwitchObject");
		}

		return uClassPointer;
	};

	void eventRemoveValueEntry(int32_t RemoveIndex);
	void eventInsertValueEntry(int32_t InsertIndex);
	bool eventIsFallThruEnabled(int32_t ValueIndex);
	void eventVerifyDefaultCaseValue();
};

// Class Engine.SeqCond_SwitchPlatform
// 0x0000 (0x00C8 - 0x00C8)
class USeqCond_SwitchPlatform : public USequenceCondition
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqCond_SwitchPlatform");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_AISeeEnemy
// 0x0008 (0x0118 - 0x0120)
class USeqEvent_AISeeEnemy : public USequenceEvent
{
public:
	float                                              MaxSightDistance;                              // 0x0118 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_AISeeEnemy");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_AnimNotify
// 0x0008 (0x0118 - 0x0120)
class USeqEvent_AnimNotify : public USequenceEvent
{
public:
	struct FName                                       NotifyName;                                    // 0x0118 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_AnimNotify");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_Console
// 0x0018 (0x0118 - 0x0130)
class USeqEvent_Console : public USequenceEvent
{
public:
	struct FName                                       ConsoleEventName;                              // 0x0118 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class FString                                      EventDesc;                                     // 0x0120 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_Console");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_ConstraintBroken
// 0x0000 (0x0118 - 0x0118)
class USeqEvent_ConstraintBroken : public USequenceEvent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_ConstraintBroken");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_Death
// 0x0000 (0x0118 - 0x0118)
class USeqEvent_Death : public USequenceEvent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_Death");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_Destroyed
// 0x0000 (0x0118 - 0x0118)
class USeqEvent_Destroyed : public USequenceEvent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_Destroyed");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_HitWall
// 0x0000 (0x0118 - 0x0118)
class USeqEvent_HitWall : public USequenceEvent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_HitWall");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_LevelLoaded
// 0x0000 (0x0118 - 0x0118)
class USeqEvent_LevelLoaded : public USequenceEvent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_LevelLoaded");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqEvent_LOS
// 0x0010 (0x0118 - 0x0128)
class USeqEvent_LOS : public USequenceEvent
{
public:
	float                                              ScreenCenterDistance;                          // 0x0118 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              TriggerDistance;                               // 0x011C (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bCheckForObstructions : 1;                     // 0x0120 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_LOS");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqEvent_Mover
// 0x0008 (0x0118 - 0x0120)
class USeqEvent_Mover : public USequenceEvent
{
public:
	float                                              StayOpenTime;                                  // 0x0118 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_Mover");
		}

		return uClassPointer;
	};

	void NotifyFinishedOpen();
	void NotifyDetached(class AActor* Other);
	void NotifyAttached(class AActor* Other);
	void NotifyEncroachingOn(class AActor* Hit);
	void eventRegisterEvent();
};

// Class Engine.SeqEvent_ParticleEvent
// 0x0038 (0x0118 - 0x0150)
class USeqEvent_ParticleEvent : public USequenceEvent
{
public:
	EParticleEventOutputType                           EventType;                                     // 0x0118 (0x0001) [0x0000000000000000]               
	struct FVector                                     EventPosition;                                 // 0x011C (0x000C) [0x0000000000000000]               
	float                                              EventEmitterTime;                              // 0x0128 (0x0004) [0x0000000000000000]               
	struct FVector                                     EventVelocity;                                 // 0x012C (0x000C) [0x0000000000000000]               
	float                                              EventParticleTime;                             // 0x0138 (0x0004) [0x0000000000000000]               
	struct FVector                                     EventNormal;                                   // 0x013C (0x000C) [0x0000000000000000]               
	uint32_t                                           UseRelfectedImpactVector : 1;                  // 0x0148 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_ParticleEvent");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqEvent_PickupStatusChange
// 0x0000 (0x0118 - 0x0118)
class USeqEvent_PickupStatusChange : public USequenceEvent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_PickupStatusChange");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_PlayerSpawned
// 0x0008 (0x0118 - 0x0120)
class USeqEvent_PlayerSpawned : public USequenceEvent
{
public:
	class UObject*                                     SpawnPoint;                                    // 0x0118 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_PlayerSpawned");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_ProjectileLanded
// 0x0008 (0x0118 - 0x0120)
class USeqEvent_ProjectileLanded : public USequenceEvent
{
public:
	float                                              MaxDistance;                                   // 0x0118 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_ProjectileLanded");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_RemoteEvent
// 0x0010 (0x0118 - 0x0128)
class USeqEvent_RemoteEvent : public USequenceEvent
{
public:
	struct FName                                       EventName;                                     // 0x0118 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bStatusIsOk : 1;                               // 0x0120 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_RemoteEvent");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
};

// Class Engine.SeqEvent_RigidBodyCollision
// 0x0008 (0x0118 - 0x0120)
class USeqEvent_RigidBodyCollision : public USequenceEvent
{
public:
	float                                              MinCollisionVelocity;                          // 0x0118 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_RigidBodyCollision");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_SeeDeath
// 0x0000 (0x0118 - 0x0118)
class USeqEvent_SeeDeath : public USequenceEvent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_SeeDeath");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_SequenceActivated
// 0x0010 (0x0118 - 0x0128)
class USeqEvent_SequenceActivated : public USequenceEvent
{
public:
	class FString                                      InputLabel;                                    // 0x0118 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_SequenceActivated");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_TakeDamage
// 0x0050 (0x0118 - 0x0168)
class USeqEvent_TakeDamage : public USequenceEvent
{
public:
	float                                              MinDamageAmount;                               // 0x0118 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              DamageThreshold;                               // 0x011C (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<class UClass*>                        DamageTypes;                                   // 0x0120 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UDamageTypeDefinition*>         DamageTypeDefinitions;                         // 0x0130 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UClass*>                        IgnoreDamageTypes;                             // 0x0140 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UDamageTypeDefinition*>         IgnoreDamageTypeDefinitions;                   // 0x0150 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	float                                              CurrentDamage;                                 // 0x0160 (0x0004) [0x0000000000000000]               
	uint32_t                                           bResetDamageOnToggle : 1;                      // 0x0164 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_TakeDamage");
		}

		return uClassPointer;
	};

	void eventToggled();
	static int32_t eventGetObjClassVersion();
	void Reset();
	void eventHandleDamage(class AActor* InOriginator, class AActor* InInstigator, class UClass* inDamageType, class UDamageTypeDefinition* inDamageTypeDefinition, float inAmount);
	bool IsValidDamageTypeDefinition(class UDamageTypeDefinition* inDamageTypeDefinition);
	bool IsValidDamageType(class UClass* inDamageType);
};

// Class Engine.SeqEvent_Touch
// 0x0048 (0x0118 - 0x0160)
class USeqEvent_Touch : public USequenceEvent
{
public:
	class TArray<class UClass*>                        ClassProximityTypes;                           // 0x0118 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class AActor*>                        ArchetypeFilter;                               // 0x0128 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UClass*>                        IgnoredClassProximityTypes;                    // 0x0138 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bForceOverlapping : 1;                         // 0x0148 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseInstigator : 1;                            // 0x0148 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bAllowDeadPawns : 1;                           // 0x0148 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	class TArray<class AActor*>                        TouchedList;                                   // 0x0150 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_Touch");
		}

		return uClassPointer;
	};

	static int32_t eventGetObjClassVersion();
	void NotifyTouchingPawnDied(class APawn* P);
	void eventToggled();
	bool CheckUnTouchActivate(class AActor* InOriginator, class AActor* InInstigator, bool optionalBTest);
	bool CheckTouchActivate(class AActor* InOriginator, class AActor* InInstigator, bool optionalBTest);
};

// Class Engine.SeqEvent_Used
// 0x0040 (0x0118 - 0x0158)
class USeqEvent_Used : public USequenceEvent
{
public:
	uint32_t                                           bAimToInteract : 1;                            // 0x0118 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseInteractDistance : 1;                      // 0x0118 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	float                                              InteractDistance;                              // 0x011C (0x0004) [0x0000000000000001] (CPF_Edit)    
	class FString                                      InteractText;                                  // 0x0120 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class UTexture2D*                                  InteractIcon;                                  // 0x0130 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class TArray<class UClass*>                        ClassProximityTypes;                           // 0x0138 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<class UClass*>                        IgnoredClassProximityTypes;                    // 0x0148 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_Used");
		}

		return uClassPointer;
	};

};

// Class Engine.SequenceVariable
// 0x0018 (0x0070 - 0x0088)
class USequenceVariable : public USequenceObject
{
public:
	struct FName                                       VarName;                                       // 0x0070 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bLinkToAttribute : 1;                          // 0x0078 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class UAttributeDefinition*                        OptionalAttributeDefinition;                   // 0x0080 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SequenceVariable");
		}

		return uClassPointer;
	};

};

// Class Engine.InterpData
// 0x0048 (0x0088 - 0x00D0)
class UInterpData : public USequenceVariable
{
public:
	float                                              InterpLength;                                  // 0x0088 (0x0004) [0x0000000000000000]               
	float                                              PathBuildTime;                                 // 0x008C (0x0004) [0x0000000000000000]               
	class TArray<class UInterpGroup*>                  InterpGroups;                                  // 0x0090 (0x0010) [0x0000000000400008] (CPF_ExportObject | CPF_NeedCtorLink)
	class UInterpCurveEdSetup*                         CurveEdSetup;                                  // 0x00A0 (0x0008) [0x0000000000000008] (CPF_ExportObject)
	float                                              EdSectionStart;                                // 0x00A8 (0x0004) [0x0000000000000000]               
	float                                              EdSectionEnd;                                  // 0x00AC (0x0004) [0x0000000000000000]               
	uint32_t                                           bShouldBakeAndPrune : 1;                       // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class TArray<struct FAnimSetBakeAndPruneStatus>    BakeAndPruneStatus;                            // 0x00B8 (0x0010) [0x0000000000400041] (CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink)
	class UInterpGroupDirector*                        CachedDirectorGroup;                           // 0x00C8 (0x0008) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InterpData");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_Bool
// 0x0008 (0x0088 - 0x0090)
class USeqVar_Bool : public USequenceVariable
{
public:
	int32_t                                            bValue;                                        // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Bool");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_External
// 0x0018 (0x0088 - 0x00A0)
class USeqVar_External : public USequenceVariable
{
public:
	class UClass*                                      ExpectedType;                                  // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class FString                                      VariableLabel;                                 // 0x0090 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_External");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_Float
// 0x0008 (0x0088 - 0x0090)
class USeqVar_Float : public USequenceVariable
{
public:
	float                                              FloatValue;                                    // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Float");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_RandomFloat
// 0x0008 (0x0090 - 0x0098)
class USeqVar_RandomFloat : public USeqVar_Float
{
public:
	float                                              Min;                                           // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              Max;                                           // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_RandomFloat");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_Int
// 0x0008 (0x0088 - 0x0090)
class USeqVar_Int : public USequenceVariable
{
public:
	int32_t                                            IntValue;                                      // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Int");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_RandomInt
// 0x0008 (0x0090 - 0x0098)
class USeqVar_RandomInt : public USeqVar_Int
{
public:
	int32_t                                            Min;                                           // 0x0090 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            Max;                                           // 0x0094 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_RandomInt");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_Named
// 0x0018 (0x0088 - 0x00A0)
class USeqVar_Named : public USequenceVariable
{
public:
	class UClass*                                      ExpectedType;                                  // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       FindVarName;                                   // 0x0090 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bStatusIsOk : 1;                               // 0x0098 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Named");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_Object
// 0x0018 (0x0088 - 0x00A0)
class USeqVar_Object : public USequenceVariable
{
public:
	class UObject*                                     ObjValue;                                      // 0x0088 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     ActorLocation;                                 // 0x0090 (0x000C) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Object");
		}

		return uClassPointer;
	};

	void SetObjectValue(class UObject* NewValue);
	class UObject* GetObjectValueW();
};

// Class Engine.SeqVar_Character
// 0x0008 (0x00A0 - 0x00A8)
class USeqVar_Character : public USeqVar_Object
{
public:
	class UClass*                                      PawnClass;                                     // 0x00A0 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Character");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_Group
// 0x0020 (0x00A0 - 0x00C0)
class USeqVar_Group : public USeqVar_Object
{
public:
	struct FName                                       GroupName;                                     // 0x00A0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bCachedList : 1;                               // 0x00A8 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)
	class TArray<class UObject*>                       Actors;                                        // 0x00B0 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Group");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_ObjectList
// 0x0010 (0x00A0 - 0x00B0)
class USeqVar_ObjectList : public USeqVar_Object
{
public:
	class TArray<class UObject*>                       ObjList;                                       // 0x00A0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_ObjectList");
		}

		return uClassPointer;
	};

	void SetObjectValue(class UObject* NewValue);
	class UObject* GetObjectValueW();
};

// Class Engine.SeqVar_ObjectVolume
// 0x0030 (0x00A0 - 0x00D0)
class USeqVar_ObjectVolume : public USeqVar_Object
{
public:
	float                                              LastUpdateTime;                                // 0x00A0 (0x0004) [0x0000000000000000]               
	class TArray<class UObject*>                       ContainedObjects;                              // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<class UClass*>                        ExcludeClassList;                              // 0x00B8 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	uint32_t                                           bCollidingOnly : 1;                            // 0x00C8 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_ObjectVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_Player
// 0x0018 (0x00A0 - 0x00B8)
class USeqVar_Player : public USeqVar_Object
{
public:
	class TArray<class UObject*>                       Players;                                       // 0x00A0 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	uint32_t                                           bAllPlayers : 1;                               // 0x00B0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	int32_t                                            PlayerIdx;                                     // 0x00B4 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Player");
		}

		return uClassPointer;
	};

	class UObject* GetObjectValueW();
	void UpdatePlayersList();
};

// Class Engine.SeqVar_String
// 0x0010 (0x0088 - 0x0098)
class USeqVar_String : public USequenceVariable
{
public:
	class FString                                      StrValue;                                      // 0x0088 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_String");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_Vector
// 0x0010 (0x0088 - 0x0098)
class USeqVar_Vector : public USequenceVariable
{
public:
	struct FVector                                     VectValue;                                     // 0x0088 (0x000C) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Vector");
		}

		return uClassPointer;
	};

};

// Class Engine.ServerCommandlet
// 0x0000 (0x00B0 - 0x00B0)
class UServerCommandlet : public UCommandlet
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ServerCommandlet");
		}

		return uClassPointer;
	};

};

// Class Engine.ServerPingObject
// 0x0058 (0x0058 - 0x00B0)
class UServerPingObject : public UObject
{
public:
	struct FPointer                                    VfTable_FNetworkNotify;                        // 0x0058 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_FTickableObject;                       // 0x0060 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    NetDriver;                                     // 0x0068 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)
	uint32_t                                           bSentPing : 1;                                 // 0x0070 (0x0004) [0x0000000000000000] [0x00000001] 
	class FString                                      ConnectionError;                               // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	float                                              ConnectionTimeout;                             // 0x0088 (0x0004) [0x0000000000000000]               
	class FString                                      ZeppelinTicket;                                // 0x0090 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnPingComplete__Delegate;                    // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ServerPingObject");
		}

		return uClassPointer;
	};

	void OnPingComplete(bool bWasSuccessful, int32_t PongData);
};

// Class Engine.Settings
// 0x0040 (0x0058 - 0x0098)
class USettings : public UObject
{
public:
	class TArray<struct FLocalizedStringSetting>       LocalizedSettings;                             // 0x0058 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FSettingsProperty>             Properties;                                    // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FLocalizedStringSettingMetaData> LocalizedSettingsMappings;                     // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FSettingsPropertyPropertyMetaData> PropertyMappings;                              // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Settings");
		}

		return uClassPointer;
	};

	void UpdateFromURL(class AGameInfo* Game, class FString& URL);
	void BuildURL(class FString& URL);
	void AppendContextsToURL(class FString& URL);
	void AppendPropertiesToURL(class FString& URL);
	void AppendDataBindingsToURL(class FString& URL);
	void GetQoSAdvertisedStringSettings(class TArray<struct FLocalizedStringSetting>& QoSSettings);
	void GetQoSAdvertisedProperties(class TArray<struct FSettingsProperty>& QoSProps);
	bool GetRangedPropertyValue(int32_t PropertyId, float& OutValue);
	bool SetRangedPropertyValue(int32_t PropertyId, float NewValue);
	bool GetPropertyRange(int32_t PropertyId, float& OutMinValue, float& OutMaxValue, float& RangeIncrement, uint8_t& bFormatAsInt);
	bool GetPropertyMappingType(int32_t PropertyId, EPropertyValueMappingType& OutType);
	bool HasStringSetting(int32_t SettingId);
	bool HasProperty(int32_t PropertyId);
	void UpdateProperties(bool optionalBShouldAddIfMissing, class TArray<struct FSettingsProperty>& Props);
	void UpdateStringSettings(bool optionalBShouldAddIfMissing, class TArray<struct FLocalizedStringSetting>& Settings);
	ESettingsDataType GetPropertyType(int32_t PropertyId);
	bool GetPropertyValueId(int32_t PropertyId, int32_t& ValueId);
	bool SetPropertyValueId(int32_t PropertyId, int32_t ValueId);
	bool GetByteProperty(int32_t PropertyId, uint8_t& Value);
	void SetByteProperty(int32_t PropertyId, uint8_t Value);
	bool GetStringProperty(int32_t PropertyId, class FString& Value);
	void SetStringProperty(int32_t PropertyId, const class FString& Value);
	bool GetIntProperty(int32_t PropertyId, int32_t& Value);
	void SetIntProperty(int32_t PropertyId, int32_t Value);
	bool GetFloatProperty(int32_t PropertyId, float& Value);
	void SetFloatProperty(int32_t PropertyId, float Value);
	bool SetPropertyFromStringByName(const struct FName& PropertyName, class FString& NewValue);
	class FString GetPropertyAsStringByName(const struct FName& PropertyName);
	class FString GetPropertyAsString(int32_t PropertyId);
	class FString GetPropertyColumnHeader(int32_t PropertyId);
	struct FName GetPropertyName(int32_t PropertyId);
	bool GetPropertyId(const struct FName& PropertyName, int32_t& PropertyId);
	bool SetStringSettingValueFromStringByName(const struct FName& StringSettingName, class FString& NewValue);
	struct FName GetStringSettingValueNameByName(const struct FName& StringSettingName);
	struct FName GetStringSettingValueName(int32_t StringSettingId, int32_t ValueIndex);
	bool IsWildcardStringSetting(int32_t StringSettingId);
	class FString GetStringSettingColumnHeader(int32_t StringSettingId);
	struct FName GetStringSettingName(int32_t StringSettingId);
	bool GetStringSettingId(const struct FName& StringSettingName, int32_t& StringSettingId);
	bool GetStringSettingValueByName(const struct FName& StringSettingName, int32_t& ValueIndex);
	void SetStringSettingValueByName(const struct FName& StringSettingName, int32_t ValueIndex, bool bShouldAutoAdd);
	bool GetStringSettingValueNames(int32_t StringSettingId, class TArray<struct FIdToStringMapping>& Values);
	bool IncrementStringSettingValue(int32_t StringSettingId, int32_t Direction, bool bShouldWrap);
	bool GetStringSettingValue(int32_t StringSettingId, int32_t& ValueIndex);
	void SetStringSettingValue(int32_t StringSettingId, int32_t ValueIndex, bool optionalBShouldAutoAdd);
	static void GetSettingsDataDateTime(struct FSettingsData& Data, int32_t& OutInt1, int32_t& OutInt2);
	static void GetSettingsDataBlob(struct FSettingsData& Data, class TArray<uint8_t>& OutBlob);
	static int32_t GetSettingsDataInt(struct FSettingsData& Data);
	static float GetSettingsDataFloat(struct FSettingsData& Data);
	static class FString GetSettingsDataString(struct FSettingsData& Data);
	static void EmptySettingsData(struct FSettingsData& Data);
	static void SetSettingsData(struct FSettingsData& Data, struct FSettingsData& Data2Copy);
	static void SetSettingsDataBlob(struct FSettingsData& Data, class TArray<uint8_t>& InBlob);
	static void SetSettingsDataDateTime(int32_t InInt1, int32_t InInt2, struct FSettingsData& Data);
	static void SetSettingsDataInt(int32_t InInt, struct FSettingsData& Data);
	static void SetSettingsDataFloat(float InFloat, struct FSettingsData& Data);
	static void SetSettingsDataString(const class FString& InString, struct FSettingsData& Data);
};

struct FLocalizedStringSetting {
	char UnknownData[0xC];
};

// Class Engine.OnlineGameSearch
// 0x00C0 (0x0098 - 0x0158)
class UOnlineGameSearch : public USettings
{
public:
	int32_t                                            MaxSearchResults;                              // 0x0098 (0x0004) [0x0000000000004000] (CPF_Config)  
	struct FLocalizedStringSetting                     Query;                                         // 0x009C (0x000C) [0x0000000000000000]               
	uint32_t                                           bIsLanQuery : 1;                               // 0x00A8 (0x0004) [0x0000000040000000] [0x00000001] (CPF_EditInlineNotify)
	uint32_t                                           bIsSearchInProgress : 1;                       // 0x00A8 (0x0004) [0x0000000000000002] [0x00000002] (CPF_Const)
	class UClass*                                      GameSettingsClass;                             // 0x00B0 (0x0008) [0x0000000000000000]               
	class TArray<struct FOnlineGameSearchResult>       Results;                                       // 0x00B8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FOverrideSkill                              ManualSkillOverride;                           // 0x00C8 (0x0038) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FNamedObjectProperty>          NamedProperties;                               // 0x0100 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FOnlineGameSearchQuery                      FilterQuery;                                   // 0x0110 (0x0020) [0x0000000000400000] (CPF_NeedCtorLink)
	class FString                                      AdditionalSearchCriteria;                      // 0x0130 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            PingBucketSize;                                // 0x0140 (0x0004) [0x0000000000000000]               
	int32_t                                            NumPingProbes;                                 // 0x0144 (0x0004) [0x0000000000000000]               
	int32_t                                            MaxPingBytes;                                  // 0x0148 (0x0004) [0x0000000000000000]               
	int32_t                                            NumSearchUsers;                                // 0x014C (0x0004) [0x0000000000000000]               
	int32_t                                            WorldIndex;                                    // 0x0150 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineGameSearch");
		}

		return uClassPointer;
	};

	void eventSortSearchResults();
	void SetSkillOverride(int32_t LeaderboardId, class TArray<struct FUniqueNetId>& Players);
};

// Class Engine.OnlineGameSettings
// 0x00F8 (0x0098 - 0x0190)
class UOnlineGameSettings : public USettings
{
public:
	int32_t                                            NumPublicConnections;                          // 0x0098 (0x0004) [0x0000000040000000] (CPF_EditInlineNotify)
	int32_t                                            NumOpenPublicConnections;                      // 0x009C (0x0004) [0x0000000040000000] (CPF_EditInlineNotify)
	uint32_t                                           bShouldAdvertise : 1;                          // 0x00A0 (0x0004) [0x0000000040000000] [0x00000001] (CPF_EditInlineNotify)
	uint32_t                                           bIsLanMatch : 1;                               // 0x00A0 (0x0004) [0x0000000040000000] [0x00000002] (CPF_EditInlineNotify)
	uint32_t                                           bUsesStats : 1;                                // 0x00A0 (0x0004) [0x0000000040000000] [0x00000004] (CPF_EditInlineNotify)
	uint32_t                                           bAllowJoinInProgress : 1;                      // 0x00A0 (0x0004) [0x0000000040000000] [0x00000008] (CPF_EditInlineNotify)
	uint32_t                                           bAllowInvites : 1;                             // 0x00A0 (0x0004) [0x0000000040000000] [0x00000010] (CPF_EditInlineNotify)
	uint32_t                                           bUsesPresence : 1;                             // 0x00A0 (0x0004) [0x0000000040000000] [0x00000020] (CPF_EditInlineNotify)
	uint32_t                                           bAllowJoinViaPresence : 1;                     // 0x00A0 (0x0004) [0x0000000040000000] [0x00000040] (CPF_EditInlineNotify)
	uint32_t                                           bAllowJoinViaPresenceFriendsOnly : 1;          // 0x00A0 (0x0004) [0x0000000040000000] [0x00000080] (CPF_EditInlineNotify)
	uint32_t                                           bAntiCheatProtected : 1;                       // 0x00A0 (0x0004) [0x0000000040000000] [0x00000100] (CPF_EditInlineNotify)
	uint32_t                                           bIsDedicated : 1;                              // 0x00A0 (0x0004) [0x0000000040000000] [0x00000200] (CPF_EditInlineNotify)
	class FString                                      OwningPlayerName;                              // 0x00A8 (0x0010) [0x0000000040400000] (CPF_NeedCtorLink | CPF_EditInlineNotify)
	struct FUniqueNetId                                OwningPlayerId;                                // 0x00B8 (0x0014) [0x0000000000000000]               
	int32_t                                            PingInMs;                                      // 0x00CC (0x0004) [0x0000000040000000] (CPF_EditInlineNotify)
	EOnlineGameState                                   GameState;                                     // 0x00D0 (0x0001) [0x0000000040000002] (CPF_Const | CPF_EditInlineNotify)
	int32_t                                            BuildUniqueId;                                 // 0x00D4 (0x0004) [0x0000000000000002] (CPF_Const)   
	class FString                                      BuildUniqueString;                             // 0x00D8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class FString                                      SessionTemplateName;                           // 0x00E8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            WorldIndex;                                    // 0x00F8 (0x0004) [0x0000000000000002] (CPF_Const)   
	struct FLocKey                                     SessionName;                                   // 0x0100 (0x0030) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FLocKey                                     SessionStatus;                                 // 0x0130 (0x0030) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FLocKey                                     SessionPlayedWith;                             // 0x0160 (0x0030) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineGameSettings");
		}

		return uClassPointer;
	};

};

// Class Engine.ShaderCache
// 0x0100 (0x0058 - 0x0158)
class UShaderCache : public UObject
{
public:
	uint8_t                                           UnknownData00[0x100];                          // 0x0058 (0x0100) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ShaderCache");
		}

		return uClassPointer;
	};

};

// Class Engine.ShadowMap1D
// 0x0068 (0x0058 - 0x00C0)
class UShadowMap1D : public UObject
{
public:
	uint8_t                                           UnknownData00[0x68];                           // 0x0058 (0x0068) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ShadowMap1D");
		}

		return uClassPointer;
	};

};

// Class Engine.ShadowMap2D
// 0x0030 (0x0058 - 0x0088)
class UShadowMap2D : public UObject
{
public:
	class UShadowMapTexture2D*                         Texture;                                       // 0x0058 (0x0008) [0x0000000000000002] (CPF_Const)   
	struct FVector2D                                   CoordinateScale;                               // 0x0060 (0x0008) [0x0000000000000002] (CPF_Const)   
	struct FVector2D                                   CoordinateBias;                                // 0x0068 (0x0008) [0x0000000000000002] (CPF_Const)   
	struct FGuid                                       LightGuid;                                     // 0x0070 (0x0010) [0x0000000000000002] (CPF_Const)   
	int32_t                                            InstanceIndex;                                 // 0x0080 (0x0004) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ShadowMap2D");
		}

		return uClassPointer;
	};

};

// Class Engine.SkeletalMesh
// 0x0498 (0x0058 - 0x04F0)
class USkeletalMesh : public UObject
{
public:
	struct FBoxSphereBounds                            Bounds;                                        // 0x0058 (0x001C) [0x0000000000001003] (CPF_Edit | CPF_Const | CPF_Native)
	class TArray<class UMaterialInterface*>            Materials;                                     // 0x0078 (0x0010) [0x0000000000001003] (CPF_Edit | CPF_Const | CPF_Native)
	class TArray<class UApexClothingAsset*>            ClothingAssets;                                // 0x0088 (0x0010) [0x0000000000400041] (CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink)
	class TArray<struct FApexClothingAssetInfo>        ClothingLodMap;                                // 0x0098 (0x0010) [0x0000000000400041] (CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink)
	struct FVector                                     Origin;                                        // 0x00A8 (0x000C) [0x0000000000001003] (CPF_Edit | CPF_Const | CPF_Native)
	struct FRotator                                    RotOrigin;                                     // 0x00B4 (0x000C) [0x0000000000001003] (CPF_Edit | CPF_Const | CPF_Native)
	class TArray<int32_t>                              RefSkeleton;                                   // 0x00C0 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	int32_t                                            SkeletalDepth;                                 // 0x00D0 (0x0004) [0x0000000000001002] (CPF_Const | CPF_Native)
	uint8_t                                           UnknownData00[0x50];                           // 0x00D8 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.SkeletalMesh.NameIndexMap
	struct FIndirectArray_Mirror                       LODModels;                                     // 0x0128 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<struct FBoneAtom>                     RefBasesInvMatrix;                             // 0x0138 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FBoxSphereBounds                            ReferencePoseBounds;                           // 0x0148 (0x001C) [0x0000000000000002] (CPF_Const)   
	class TArray<struct FBoneMirrorInfo>               SkelMirrorTable;                               // 0x0168 (0x0010) [0x0000000000400041] (CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink)
	EAxis                                              SkelMirrorAxis;                                // 0x0178 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EAxis                                              SkelMirrorFlipAxis;                            // 0x0179 (0x0001) [0x0000000000000001] (CPF_Edit)    
	class TArray<class USkeletalMeshSocket*>           Sockets;                                       // 0x0180 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<class FString>                        BoneBreakNames;                                // 0x0190 (0x0010) [0x0000000000021003] (CPF_Edit | CPF_Const | CPF_Native | CPF_EditConst)
	class TArray<EBoneBreakOption>                     BoneBreakOptions;                              // 0x01A0 (0x0010) [0x0000000000001003] (CPF_Edit | CPF_Const | CPF_Native)
	class TArray<struct FSkeletalMeshLODInfo>          LODInfo;                                       // 0x01B0 (0x0010) [0x0000000000400041] (CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink)
	class TArray<struct FName>                         PerPolyCollisionBones;                         // 0x01C0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<struct FName>                         AddToParentPerPolyCollisionBone;               // 0x01D0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<int32_t>                              PerPolyBoneKDOPs;                              // 0x01E0 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	uint32_t                                           bPerPolyUseSoftWeighting : 1;                  // 0x01F0 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUseSimpleLineCollision : 1;                   // 0x01F0 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bUseSimpleBoxCollision : 1;                    // 0x01F0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bForceCPUSkinning : 1;                         // 0x01F0 (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           bUseFullPrecisionUVs : 1;                      // 0x01F0 (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	class UFaceFXAsset*                                FaceFXAsset;                                   // 0x01F8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            LODBiasPC;                                     // 0x0200 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            LODBiasOrbis;                                  // 0x0204 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            LODBiasDurango;                                // 0x0208 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FPointer>                      ClothMesh;                                     // 0x0210 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<float>                                ClothMeshScale;                                // 0x0220 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<int32_t>                              ClothToGraphicsVertMap;                        // 0x0230 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<float>                                ClothMovementScale;                            // 0x0240 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	EClothMovementScaleGen                             ClothMovementScaleGenMode;                     // 0x0250 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              ClothToAnimMeshMaxDist;                        // 0x0254 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bLimitClothToAnimMesh : 1;                     // 0x0258 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	class TArray<int32_t>                              ClothWeldingMap;                               // 0x0260 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	int32_t                                            ClothWeldingDomain;                            // 0x0270 (0x0004) [0x0000000000000002] (CPF_Const)   
	class TArray<int32_t>                              ClothWeldedIndices;                            // 0x0278 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	uint32_t                                           bForceNoWelding : 1;                           // 0x0288 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	int32_t                                            NumFreeClothVerts;                             // 0x028C (0x0004) [0x0000000000000002] (CPF_Const)   
	class TArray<int32_t>                              ClothIndexBuffer;                              // 0x0290 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FName>                         ClothBones;                                    // 0x02A0 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	int32_t                                            ClothHierarchyLevels;                          // 0x02B0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableClothBendConstraints : 1;               // 0x02B4 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableClothDamping : 1;                       // 0x02B4 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           bUseClothCOMDamping : 1;                       // 0x02B4 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	float                                              ClothStretchStiffness;                         // 0x02B8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothBendStiffness;                            // 0x02BC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothDensity;                                  // 0x02C0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothThickness;                                // 0x02C4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothDamping;                                  // 0x02C8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            ClothIterations;                               // 0x02CC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            ClothHierarchicalIterations;                   // 0x02D0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothFriction;                                 // 0x02D4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothRelativeGridSpacing;                      // 0x02D8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothPressure;                                 // 0x02DC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothCollisionResponseCoefficient;             // 0x02E0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothAttachmentResponseCoefficient;            // 0x02E4 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothAttachmentTearFactor;                     // 0x02E8 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothSleepLinearVelocity;                      // 0x02EC (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              HardStretchLimitFactor;                        // 0x02F0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bHardStretchLimit : 1;                         // 0x02F4 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableClothOrthoBendConstraints : 1;          // 0x02F4 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableClothSelfCollision : 1;                 // 0x02F4 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableClothPressure : 1;                      // 0x02F4 (0x0004) [0x0000000000000003] [0x00000008] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableClothTwoWayCollision : 1;               // 0x02F4 (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	class TArray<struct FClothSpecialBoneInfo>         ClothSpecialBones;                             // 0x02F8 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	uint32_t                                           bEnableClothLineChecks : 1;                    // 0x0308 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bClothMetal : 1;                               // 0x0308 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	float                                              ClothMetalImpulseThreshold;                    // 0x030C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothMetalPenetrationDepth;                    // 0x0310 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              ClothMetalMaxDeformationDistance;              // 0x0314 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableClothTearing : 1;                       // 0x0318 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	float                                              ClothTearFactor;                               // 0x031C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            ClothTearReserve;                              // 0x0320 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableValidBounds : 1;                        // 0x0324 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	struct FVector                                     ValidBoundsMin;                                // 0x0328 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     ValidBoundsMax;                                // 0x0334 (0x000C) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FSphere>                       ClothCollisionSpheres;                         // 0x0340 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	class TArray<int32_t>                              ClothCollisionCapsuleIndices;                  // 0x0350 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FMap_Mirror                                 ClothTornTriMap;                               // 0x0360 (0x0050) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<int32_t>                              SoftBodySurfaceToGraphicsVertMap;              // 0x03B0 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<int32_t>                              SoftBodySurfaceIndices;                        // 0x03C0 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FVector>                       SoftBodyTetraVertsUnscaled;                    // 0x03D0 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<int32_t>                              SoftBodyTetraIndices;                          // 0x03E0 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FSoftBodyTetraLink>            SoftBodyTetraLinks;                            // 0x03F0 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FPointer>                      CachedSoftBodyMeshes;                          // 0x0400 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<float>                                CachedSoftBodyMeshScales;                      // 0x0410 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<struct FName>                         SoftBodyBones;                                 // 0x0420 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FSoftBodySpecialBoneInfo>      SoftBodySpecialBones;                          // 0x0430 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	float                                              SoftBodyVolumeStiffness;                       // 0x0440 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SoftBodyStretchingStiffness;                   // 0x0444 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SoftBodyDensity;                               // 0x0448 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SoftBodyParticleRadius;                        // 0x044C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SoftBodyDamping;                               // 0x0450 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            SoftBodySolverIterations;                      // 0x0454 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SoftBodyFriction;                              // 0x0458 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SoftBodyRelativeGridSpacing;                   // 0x045C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SoftBodySleepLinearVelocity;                   // 0x0460 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableSoftBodySelfCollision : 1;              // 0x0464 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	float                                              SoftBodyAttachmentResponse;                    // 0x0468 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SoftBodyCollisionResponse;                     // 0x046C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	float                                              SoftBodyDetailLevel;                           // 0x0470 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            SoftBodySubdivisionLevel;                      // 0x0474 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bSoftBodyIsoSurface : 1;                       // 0x0478 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableSoftBodyDamping : 1;                    // 0x0478 (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	uint32_t                                           bUseSoftBodyCOMDamping : 1;                    // 0x0478 (0x0004) [0x0000000000000003] [0x00000004] (CPF_Edit | CPF_Const)
	float                                              SoftBodyAttachmentThreshold;                   // 0x047C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableSoftBodyTwoWayCollision : 1;            // 0x0480 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	float                                              SoftBodyAttachmentTearFactor;                  // 0x0484 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bEnableSoftBodyLineChecks : 1;                 // 0x0488 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	uint32_t                                           bHasVertexColors : 1;                          // 0x0488 (0x0004) [0x0000000000000000] [0x00000002] 
	class TArray<uint32_t>                             GraphicsIndexIsCloth;                          // 0x0490 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<float>                                CachedStreamingTextureFactors;                 // 0x04A0 (0x0010) [0x0000000000001002] (CPF_Const | CPF_Native)
	float                                              StreamingDistanceMultiplier;                   // 0x04B0 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            ReleaseResourcesFence;                         // 0x04B4 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FQWord                                      SkelMeshRUID;                                  // 0x04B8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	uint32_t                                           bUseClothingAssetMaterial : 1;                 // 0x04C0 (0x0004) [0x0000000000000003] [0x00000001] (CPF_Edit | CPF_Const)
	class TArray<struct FBoneAtom>                     CachedRefBoneAtoms;                            // 0x04C8 (0x0010) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FName                                       CachedAnimSetLinkupName;                       // 0x04D8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              MotionBlurScale;                               // 0x04E0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           bAlwaysAllowForwardDynamicsSimulation : 1;     // 0x04E4 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	int32_t                                            PartialRagdollLoDLevelDisable;                 // 0x04E8 (0x0004) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkeletalMesh");
		}

		return uClassPointer;
	};

};

// Class Engine.SkeletalMeshSocket
// 0x0038 (0x0058 - 0x0090)
class USkeletalMeshSocket : public UObject
{
public:
	struct FName                                       SocketName;                                    // 0x0058 (0x0008) [0x0000000000020003] (CPF_Edit | CPF_Const | CPF_EditConst)
	struct FName                                       BoneName;                                      // 0x0060 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	struct FVector                                     RelativeLocation;                              // 0x0068 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FRotator                                    RelativeRotation;                              // 0x0074 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     RelativeScale;                                 // 0x0080 (0x000C) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SkeletalMeshSocket");
		}

		return uClassPointer;
	};

};

// Class Engine.SmokeTestCommandlet
// 0x0000 (0x00B0 - 0x00B0)
class USmokeTestCommandlet : public UCommandlet
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SmokeTestCommandlet");
		}

		return uClassPointer;
	};

};

// Class Engine.SnapshotInterface
// 0x0008 (0x0058 - 0x0060)
class USnapshotInterface : public UObject
{
public:
	uint32_t                                           bEnableInMultiplayer : 1;                      // 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bTracked : 1;                                  // 0x0058 (0x0004) [0x0000000000000000] [0x00000002] 

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SnapshotInterface");
		}

		return uClassPointer;
	};

};

// Class Engine.SpeedTree
// 0x0000 (0x0058 - 0x0058)
class USpeedTree : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpeedTree");
		}

		return uClassPointer;
	};

};

// Class Engine.StaticMesh
// 0x0118 (0x0058 - 0x0170)
class UStaticMesh : public UObject
{
public:
	uint8_t                                           UnknownData00[0x18];                           // 0x0058 (0x0018) MISSED OFFSET
	class TArray<struct FStaticMeshLODInfo>            LODInfo;                                       // 0x0070 (0x0010) [0x0000000000001041] (CPF_Edit | CPF_EditConstArray | CPF_Native)
	float                                              LODDistanceRatio;                              // 0x0080 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LODMaxRange;                                   // 0x0084 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            LightMapResolution;                            // 0x0088 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            LightMapCoordinateIndex;                       // 0x008C (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData01[0x40];                           // 0x0090 (0x0040) MISSED OFFSET
	class URB_BodySetup*                               BodySetup;                                     // 0x00D0 (0x0008) [0x0000000004000001] (CPF_Edit | CPF_EditInline)
	uint8_t                                           UnknownData02[0x58];                           // 0x00D8 (0x0058) MISSED OFFSET
	uint32_t                                           UseSimpleLineCollision : 1;                    // 0x0130 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           UseSimpleBoxCollision : 1;                     // 0x0134 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           UseSimpleRigidBodyCollision : 1;               // 0x0138 (0x0004) [0x0000000000020001] [0x00000001] (CPF_Edit | CPF_EditConst)
	uint32_t                                           ForceComplexRigidBodyCollisionPhysX : 1;       // 0x013C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           UseFullPrecisionUVs : 1;                       // 0x0140 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bUsedForInstancing : 1;                        // 0x0144 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	float                                              StreamingDistanceMultiplier;                   // 0x014C (0x0004) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData03[0x14];                           // 0x0150 (0x0014) MISSED OFFSET
	ELODEnumTemplates                                  LODTemplate;                                   // 0x0164 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint8_t                                           UnknownData04[0xB];                            // 0x0165 (0x000B) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.StaticMesh");
		}

		return uClassPointer;
	};

};

// Class Engine.Surface
// 0x0000 (0x0058 - 0x0058)
class USurface : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Surface");
		}

		return uClassPointer;
	};

	float GetSurfaceHeight();
	float GetSurfaceWidth();
};

// Class Engine.MaterialInterface
// 0x0020 (0x0058 - 0x0078)
class UMaterialInterface : public USurface
{
public:
	struct FPointer                                    VfTable_IIParameterBehavior;                   // 0x0058 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FRenderCommandFence_Mirror                  ParentRefFence;                                // 0x0060 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint32_t                                           TwoSided : 1;                                  // 0x0064 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bReversePolygonCullMode : 1;                   // 0x0064 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           Wireframe : 1;                                 // 0x0064 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bDisableDepthTest : 1;                         // 0x0064 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bDisableDepthWrites : 1;                       // 0x0064 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           NeedsPostPostLoad : 1;                         // 0x0064 (0x0004) [0x0000000000002000] [0x00000020] (CPF_Transient)
	struct FLightmassMaterialInterfaceSettings         LightmassSettings;                             // 0x0068 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       SkinId;                                        // 0x0070 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialInterface");
		}

		return uClassPointer;
	};

	void SetForceMipLevelsToBeResident(bool OverrideForceMiplevelsToBeResident, bool bForceMiplevelsToBeResidentValue, float ForceDuration, const struct FQWord& CinematicTextureGroups);
	void Behavior_SetColorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FLinearColor& Value);
	void Behavior_SetFloatParameterValue(int32_t& SectionIndex, struct FName& ParameterName, float& Value);
	void Behavior_SetObjectParameterValue(class UObject* Value, int32_t& SectionIndex, struct FName& ParameterName);
	void Behavior_SetVectorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FVector& Value);
	bool Behavior_GetColorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FLinearColor& OutValue);
	bool Behavior_GetFloatParameterValue(int32_t& SectionIndex, struct FName& ParameterName, float& OutValue);
	bool Behavior_GetObjectParameterValueW(int32_t& SectionIndex, struct FName& ParameterName, class UObject*& OutValue);
	bool Behavior_GetVectorParameterValue(int32_t& SectionIndex, struct FName& ParameterName, struct FVector& OutValue);
	bool GetIntParameterValue(const struct FName& ParameterName, int32_t& OutValue);
	bool GetBoolParameterValue(const struct FName& ParameterName, int32_t& OutValue);
	bool GetFloat4ParameterValue(const struct FName& ParameterName, struct FFloat4& OutValue);
	bool GetVectorParameterValue(const struct FName& ParameterName, struct FLinearColor& OutValue);
	bool GetSamplerParameterValue(const struct FName& ParameterName, class USampler*& OutValue);
	bool GetTextureParameterValue(const struct FName& ParameterName, class UTexture*& OutValue);
	bool GetScalarParameterValue(const struct FName& ParameterName, float& OutValue);
	bool GetFontParameterValue(const struct FName& ParameterName, class UFont*& OutFontValue, int32_t& OutFontPage);
	bool GetParameterDesc(const struct FName& ParameterName, class FString& OutDesc);
	class UPhysicalMaterial* GetPhysicalMaterial();
	class UMaterial* GetMaterial();
};

// Class Engine.FracturedStaticMesh
// 0x00E0 (0x0170 - 0x0250)
class UFracturedStaticMesh : public UStaticMesh
{
public:
	uint8_t                                           UnknownData00[0xE0];                           // 0x0170 (0x00E0) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FracturedStaticMesh");
		}

		return uClassPointer;
	};

};

// Class Engine.StaticMeshLODTemplates
// 0x0018 (0x0058 - 0x0070)
class UStaticMeshLODTemplates : public UObject
{
public:
	class TArray<struct FStaticMeshLODTemplateEntry>   StaticMeshLODTemplateList;                     // 0x0058 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	struct FPointer                                    LODTemplateEnum;                               // 0x0068 (0x0008) [0x0000000000003000] (CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.StaticMeshLODTemplates");
		}

		return uClassPointer;
	};

};

// Class Engine.Material
// 0x0648 (0x0078 - 0x06C0)
class UMaterial : public UMaterialInterface
{
public:
	struct FMaterialInput                              DiffuseColor;                                  // 0x0078 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              DiffusePower;                                  // 0x00C0 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              SpecularColor;                                 // 0x0108 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              SpecularPower;                                 // 0x0150 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              Normal;                                        // 0x0198 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              EmissiveColor;                                 // 0x01E0 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              AdditiveColor;                                 // 0x0228 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              Opacity;                                       // 0x0270 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              OpacityMask;                                   // 0x02B8 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              ClipMaskRefValue;                              // 0x0300 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              Distortion;                                    // 0x0348 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              TwoSidedLightingMask;                          // 0x0390 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              TwoSidedLightingColor;                         // 0x03D8 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              AnisotropicDirection;                          // 0x0420 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              WorldPositionOffset;                           // 0x0468 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              VertexColor;                                   // 0x04B0 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              CustomLighting;                                // 0x04F8 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FMaterialInput                              CustomSkylightDiffuse;                         // 0x0540 (0x0048) [0x0000000000400000] (CPF_NeedCtorLink)
	class UPhysicalMaterial*                           PhysMaterial;                                  // 0x0588 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UClass*                                      PhysicalMaterial;                              // 0x0590 (0x0008) [0x0000000000000000]               
	float                                              OpacityMaskClipValue;                          // 0x0598 (0x0004) [0x0000000020000000]  CPF_Deprecated)
	uint32_t                                           bNeedsShadowDepthBias : 1;                     // 0x059C (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bSceneTextureRenderBehindTranslucency : 1;     // 0x059C (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bAllowFog : 1;                                 // 0x059C (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bSplashMaterial : 1;                           // 0x059C (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bUsedAsLightFunction : 1;                      // 0x059C (0x0004) [0x0000000000000003] [0x00000010] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithFogVolumes : 1;                       // 0x059C (0x0004) [0x0000000000000003] [0x00000020] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedAsSpecialEngineMaterial : 1;              // 0x059C (0x0004) [0x0000000000200002] [0x00000040] (CPF_Const)
	uint32_t                                           bUsedWithSkeletalMesh : 1;                     // 0x059C (0x0004) [0x0000000000000003] [0x00000080] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithTerrain : 1;                          // 0x059C (0x0004) [0x0000000000000003] [0x00000100] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithParticleSprites : 1;                  // 0x059C (0x0004) [0x0000000000000003] [0x00000200] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithBeamTrails : 1;                       // 0x059C (0x0004) [0x0000000000000003] [0x00000400] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithParticleSubUV : 1;                    // 0x059C (0x0004) [0x0000000000000003] [0x00000800] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithFoliage : 1;                          // 0x059C (0x0004) [0x0000000000000003] [0x00001000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithStaticLighting : 1;                   // 0x059C (0x0004) [0x0000000000000003] [0x00002000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithLensFlare : 1;                        // 0x059C (0x0004) [0x0000000000000003] [0x00004000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithInstancedMeshParticles : 1;           // 0x059C (0x0004) [0x0000000000000003] [0x00008000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithDecals : 1;                           // 0x059C (0x0004) [0x0000000000000003] [0x00010000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithMaterialEffect : 1;                   // 0x059C (0x0004) [0x0000000000000003] [0x00020000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithMorphTargets : 1;                     // 0x059C (0x0004) [0x0000000000000003] [0x00040000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithRadialBlur : 1;                       // 0x059C (0x0004) [0x0000000000000003] [0x00080000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithInstancedMeshes : 1;                  // 0x059C (0x0004) [0x0000000000000003] [0x00100000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithSplineMeshes : 1;                     // 0x059C (0x0004) [0x0000000000000003] [0x00200000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithAPEXMeshes : 1;                       // 0x059C (0x0004) [0x0000000000000003] [0x00400000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithSPHFluid : 1;                         // 0x059C (0x0004) [0x0000000000000003] [0x00800000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithWires : 1;                            // 0x059C (0x0004) [0x0000000000000003] [0x01000000] (CPF_Edit | CPF_Const)
	uint32_t                                           bUsedWithRealtimeShatter : 1;                  // 0x059C (0x0004) [0x0000000000000003] [0x02000000] (CPF_Edit | CPF_Const)
	uint32_t                                           bPerPixelCameraVector : 1;                     // 0x059C (0x0004) [0x0000000000000001] [0x04000000] (CPF_Edit)
	uint32_t                                           bAllowLightmapSpecular : 1;                    // 0x059C (0x0004) [0x0000000000000001] [0x08000000] (CPF_Edit)
	uint32_t                                           bNoDraw : 1;                                   // 0x059C (0x0004) [0x0000000000000001] [0x10000000] (CPF_Edit)
	uint32_t                                           bFullResTransConsole : 1;                      // 0x059C (0x0004) [0x0000000000000001] [0x20000000] (CPF_Edit)
	uint32_t                                           bUsesDistortion : 1;                           // 0x059C (0x0004) [0x0000000000000000] [0x40000000] 
	uint32_t                                           bIsPreviewMaterial : 1;                        // 0x059C (0x0004) [0x0000000000202000] [0x80000000] (CPF_Transient)
	uint32_t                                           PostPostLoadCompleted : 1;                     // 0x05A0 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)
	uint32_t                                           PackageVersionChanged : 1;                     // 0x05A0 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	uint32_t                                           bCheckUniqueExpressionGUIDs : 1;               // 0x05A0 (0x0004) [0x0000000000002000] [0x00000004] (CPF_Transient)
	uint32_t                                           Importing : 1;                                 // 0x05A0 (0x0004) [0x0000000000002000] [0x00000008] (CPF_Transient)
	EBlendMode                                         BlendMode;                                     // 0x05A4 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EDecalMode                                         DecalMode;                                     // 0x05A5 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EMaterialLightingModel                             LightingModel;                                 // 0x05A6 (0x0001) [0x0000000000000001] (CPF_Edit)    
	EParticleDownsampling                              ParticleDownsampling;                          // 0x05A7 (0x0001) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     WorldPositionOffsetLimit;                      // 0x05A8 (0x000C) [0x0000000000000001] (CPF_Edit)    
	struct FPointer                                    MaterialResource;                              // 0x05B8 (0x0008) [0x0000000000201002] (CPF_Const | CPF_Native)
	struct FPointer                                    MyMaterialRenderProxy;                         // 0x05C0 (0x0008) [0x0000000000201002] (CPF_Const | CPF_Native)
	struct FRenderCommandFence_Mirror                  MaterialFence;                                 // 0x05C8 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            EditorX;                                       // 0x05CC (0x0004) [0x0000000000000000]               
	int32_t                                            EditorY;                                       // 0x05D0 (0x0004) [0x0000000000000000]               
	int32_t                                            EditorPitch;                                   // 0x05D4 (0x0004) [0x0000000000000000]               
	int32_t                                            EditorYaw;                                     // 0x05D8 (0x0004) [0x0000000000000000]               
	class TArray<class UClass*>                        ConstantBuffers;                               // 0x05E0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<class UMaterialExpression*>           Expressions;                                   // 0x05F0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	class TArray<struct FMaterialFunctionInfo>         MaterialFunctionInfos;                         // 0x0600 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	uint8_t                                           UnknownData00[0x50];                           // 0x0610 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.Material.EditorParameters
	class TArray<class UTexture*>                      ReferencedTextures;                            // 0x0660 (0x0010) [0x0000000020400002] (CPF_Const | CPF_NeedCtorLink | CPF_Deprecated)
	uint8_t                                           UnknownData01[0x50];                           // 0x0670 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.Material.ExpressionReplacementMap

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Material");
		}

		return uClassPointer;
	};

};

// Class Engine.DecalMaterial
// 0x0000 (0x06C0 - 0x06C0)
class UDecalMaterial : public UMaterial
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DecalMaterial");
		}

		return uClassPointer;
	};

};

// Class Engine.MaterialInstance
// 0x00F8 (0x0078 - 0x0170)
class UMaterialInstance : public UMaterialInterface
{
public:
	class TArray<struct FFontParameterValue>           FontParameterValues;                           // 0x0078 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FTextureParameterValue>        TextureParameterValues;                        // 0x0088 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FSamplerParameterValue>        SamplerParameterValues;                        // 0x0098 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FScalarParameterValue>         ScalarParameterValues;                         // 0x00A8 (0x0010) [0x0000000020400002] (CPF_Const | CPF_NeedCtorLink | CPF_Deprecated)
	class TArray<struct FVectorParameterValue>         VectorParameterValues;                         // 0x00B8 (0x0010) [0x0000000020400002] (CPF_Const | CPF_NeedCtorLink | CPF_Deprecated)
	class TArray<struct FFloat4ParameterValue>         Float4ParameterValues;                         // 0x00C8 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FIntParameterValue>            IntParameterValues;                            // 0x00D8 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FBoolParameterValue>           BoolParameterValues;                           // 0x00E8 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)
	class UPhysicalMaterial*                           PhysMaterial;                                  // 0x00F8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UMaterialInterface*                          Parent;                                        // 0x0100 (0x0008) [0x0000000000000003] (CPF_Edit | CPF_Const)
	uint32_t                                           bHasStaticPermutationResource : 1;             // 0x0108 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bStaticPermutationDirty : 1;                   // 0x0108 (0x0004) [0x0000000000003000] [0x00000002] (CPF_Native | CPF_Transient)
	uint32_t                                           ReentrantFlag : 1;                             // 0x0108 (0x0004) [0x0000000000001002] [0x00000004] (CPF_Const | CPF_Native)
	struct FGuid                                       LastKnownParentMaterialId;                     // 0x010C (0x0010) [0x0000000000020002] (CPF_Const | CPF_EditConst)
	struct FGuid                                       MaterialInstanceId;                            // 0x011C (0x0010) [0x0000000000020002] (CPF_Const | CPF_EditConst)
	struct FPointer                                    StaticParameters;                              // 0x0130 (0x0008) [0x0000000000201002] (CPF_Const | CPF_Native)
	struct FPointer                                    MaterialResource;                              // 0x0138 (0x0008) [0x0000000000201002] (CPF_Const | CPF_Native)
	struct FPointer                                    MyMaterialRenderProxy;                         // 0x0140 (0x0008) [0x0000000000201002] (CPF_Const | CPF_Native)
	struct FRenderCommandFence_Mirror                  MaterialFence;                                 // 0x0148 (0x0004) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	class TArray<class UTexture*>                      ReferencedTextures;                            // 0x0150 (0x0010) [0x0000000020400002] (CPF_Const | CPF_NeedCtorLink | CPF_Deprecated)
	struct FGuid                                       ParentLightingGuid;                            // 0x0160 (0x0010) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MaterialInstance");
		}

		return uClassPointer;
	};

	void Behavior_SetObjectParameterValue(class UObject* Value, int32_t& Section, struct FName& ParameterName);
	void Behavior_SetFloatParameterValue(int32_t& Section, struct FName& ParameterName, float& Value);
	void Behavior_SetColorParameterValue(int32_t& Section, struct FName& ParameterName, struct FLinearColor& Value);
	void Behavior_SetVectorParameterValue(int32_t& Section, struct FName& ParameterName, struct FVector& Value);
	bool Behavior_GetColorParameterValue(int32_t& Section, struct FName& ParameterName, struct FLinearColor& OutValue);
	bool Behavior_GetVectorParameterValue(int32_t& Section, struct FName& ParameterName, struct FVector& OutValue);
	bool Behavior_GetFloatParameterValue(int32_t& Section, struct FName& ParameterName, float& OutValue);
	bool Behavior_GetObjectParameterValueW(int32_t& Section, struct FName& ParameterName, class UObject*& OutValue);
	bool HasParentChanged();
	bool IsInMapOrTransientPackage();
	void ClearParameterValues();
	void SetFontParameterValue(const struct FName& ParameterName, class UFont* FontValue, int32_t FontPage);
	void SetSamplerParameterValue(const struct FName& ParameterName, class USampler* Value);
	void SetTextureParameterValue(const struct FName& ParameterName, class UTexture* Value);
	void SetIntParameterValue(const struct FName& ParameterName, int32_t Value);
	void SetBoolParameterValue(const struct FName& ParameterName, int32_t Value);
	void SetFloat4ParameterValue(const struct FName& ParameterName, struct FFloat4& Value);
	void SetVectorParameterValue(const struct FName& ParameterName, struct FLinearColor& Value);
	void SetScalarParameterValue(const struct FName& ParameterName, float Value);
	void SetParent(class UMaterialInterface* NewParent);
};

// Class Engine.Texture
// 0x0018 (0x0058 - 0x0070)
class UTexture : public USurface
{
public:
	struct FPointer                                    Resource;                                      // 0x0058 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)
	ETextureMipGenSettings                             MipGenSettings;                                // 0x0060 (0x0001) [0x0000000020000000]  CPF_Deprecated)
	ETextureCompressionSettings                        CompressionSettings;                           // 0x0061 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ETextureGroup                                      LODGroup;                                      // 0x0062 (0x0001) [0x0000000000000001] (CPF_Edit)    
	uint32_t                                           SRGB : 1;                                      // 0x0064 (0x0004) [0x0000000020000000] [0x00000001]  CPF_Deprecated)
	uint32_t                                           RGBE : 1;                                      // 0x0064 (0x0004) [0x0000000020000000] [0x00000002]  CPF_Deprecated)
	uint32_t                                           bIsSourceArtUncompressed : 1;                  // 0x0064 (0x0004) [0x0000000020000000] [0x00000004]  CPF_Deprecated)
	uint32_t                                           bSourceArtDDS : 1;                             // 0x0064 (0x0004) [0x0000000020000000] [0x00000008]  CPF_Deprecated)
	uint32_t                                           bSourceArtGIB : 1;                             // 0x0064 (0x0004) [0x0000000020000000] [0x00000010]  CPF_Deprecated)
	uint32_t                                           CompressionNoAlpha : 1;                        // 0x0064 (0x0004) [0x0000000020000000] [0x00000020]  CPF_Deprecated)
	uint32_t                                           CompressionNone : 1;                           // 0x0064 (0x0004) [0x0000000020000000] [0x00000040]  CPF_Deprecated)
	uint32_t                                           CompressionNoMipmaps : 1;                      // 0x0064 (0x0004) [0x0000000020000000] [0x00000080]  CPF_Deprecated)
	uint32_t                                           NeverStream : 1;                               // 0x0064 (0x0004) [0x0000000020000000] [0x00000100]  CPF_Deprecated)
	uint32_t                                           bDitherMipMapAlpha : 1;                        // 0x0064 (0x0004) [0x0000000020000000] [0x00000200]  CPF_Deprecated)
	uint32_t                                           bPreserveBorderR : 1;                          // 0x0064 (0x0004) [0x0000000020000000] [0x00000400]  CPF_Deprecated)
	uint32_t                                           bPreserveBorderG : 1;                          // 0x0064 (0x0004) [0x0000000020000000] [0x00000800]  CPF_Deprecated)
	uint32_t                                           bPreserveBorderB : 1;                          // 0x0064 (0x0004) [0x0000000020000000] [0x00001000]  CPF_Deprecated)
	uint32_t                                           bPreserveBorderA : 1;                          // 0x0064 (0x0004) [0x0000000020000000] [0x00002000]  CPF_Deprecated)
	int32_t                                            LODBias;                                       // 0x0068 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            CachedCombinedLODBias;                         // 0x006C (0x0004) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Texture");
		}

		return uClassPointer;
	};

};

// Class Engine.Texture2DComposite
// 0x0000 (0x0070 - 0x0070)
class UTexture2DComposite : public UTexture
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Texture2DComposite");
		}

		return uClassPointer;
	};

};

// Class Engine.Texture2DDynamic
// 0x0018 (0x0070 - 0x0088)
class UTexture2DDynamic : public UTexture
{
public:
	int32_t                                            SizeX;                                         // 0x0070 (0x0004) [0x0000000000003000] (CPF_Native | CPF_Transient)
	int32_t                                            SizeY;                                         // 0x0074 (0x0004) [0x0000000000003000] (CPF_Native | CPF_Transient)
	int32_t                                            TextureFormat;                                 // 0x0078 (0x0004) [0x0000000000003000] (CPF_Native | CPF_Transient)
	int32_t                                            NumMips;                                       // 0x007C (0x0004) [0x0000000000003000] (CPF_Native | CPF_Transient)
	uint32_t                                           bIsResolveTarget : 1;                          // 0x0080 (0x0004) [0x0000000000003000] [0x00000001] (CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Texture2DDynamic");
		}

		return uClassPointer;
	};

	static class UTexture2DDynamic* Create(int32_t InSizeX, int32_t InSizeY, int32_t optionalInFormat, bool optionalInIsResolveTarget);
	void Init(int32_t InSizeX, int32_t InSizeY, int32_t optionalInFormat, bool optionalInIsResolveTarget);
};

// Class Engine.TextureBaseGBX
// 0x0048 (0x0070 - 0x00B8)
class UTextureBaseGBX : public UTexture
{
public:
	struct FIndirectArray_Mirror                       TextureArray;                                  // 0x0070 (0x0010) [0x0000000020001002] (CPF_Const | CPF_Native | CPF_Deprecated)
	struct FSharedPtr_Mirror                           ResourceInterface;                             // 0x0080 (0x0010) [0x0000000000201002] (CPF_Const | CPF_Native)
	int32_t                                            SizeX;                                         // 0x0090 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            SizeY;                                         // 0x0094 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            SizeZ;                                         // 0x0098 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            OriginalSizeX;                                 // 0x009C (0x0004) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	int32_t                                            OriginalSizeY;                                 // 0x00A0 (0x0004) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	EPixelFormat                                       Format;                                        // 0x00A4 (0x0001) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	ETextureAddress                                    AddressX;                                      // 0x00A5 (0x0001) [0x0000000000000000]               
	ETextureAddress                                    AddressY;                                      // 0x00A6 (0x0001) [0x0000000000000000]               
	ETextureAddress                                    AddressZ;                                      // 0x00A7 (0x0001) [0x0000000000000000]               
	int32_t                                            TextureFormat;                                 // 0x00A8 (0x0004) [0x0000000000000002] (CPF_Const)   
	uint32_t                                           bForceMiplevelsToBeResident : 1;               // 0x00AC (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)
	uint32_t                                           bGlobalForceMipLevelsToBeResident : 1;         // 0x00AC (0x0004) [0x0000000000000003] [0x00000002] (CPF_Edit | CPF_Const)
	float                                              ForceMipLevelsToBeResidentTimestamp;           // 0x00B0 (0x0004) [0x0000000000002000] (CPF_Transient)
	int32_t                                            StreamingIndex;                                // 0x00B4 (0x0004) [0x0000000000202002] (CPF_Const | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TextureBaseGBX");
		}

		return uClassPointer;
	};

	void SetForceMipLevelsToBeResident(float Seconds, const struct FQWord& CinematicTextureGroups);
};

// Class Engine.Texture2D
// 0x0000 (0x00B8 - 0x00B8)
class UTexture2D : public UTextureBaseGBX
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Texture2D");
		}

		return uClassPointer;
	};

};

// Class Engine.LightMapTexture2D
// 0x0008 (0x00B8 - 0x00C0)
class ULightMapTexture2D : public UTexture2D
{
public:
	uint8_t                                           UnknownData00[0x8];                            // 0x00B8 (0x0008) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LightMapTexture2D");
		}

		return uClassPointer;
	};

};

// Class Engine.ShadowMapTexture2D
// 0x0008 (0x00B8 - 0x00C0)
class UShadowMapTexture2D : public UTexture2D
{
public:
	int32_t                                            ShadowmapFlags;                                // 0x00B8 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ShadowMapTexture2D");
		}

		return uClassPointer;
	};

};

// Class Engine.TerrainWeightMapTexture
// 0x0000 (0x00B8 - 0x00B8)
class UTerrainWeightMapTexture : public UTexture2D
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TerrainWeightMapTexture");
		}

		return uClassPointer;
	};

};

// Class Engine.TextureFlipBook
// 0x0048 (0x00B8 - 0x0100)
class UTextureFlipBook : public UTexture2D
{
public:
	struct FPointer                                    VfTable_FTickableObject;                       // 0x00B8 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	float                                              TimeIntoMovie;                                 // 0x00C0 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              TimeSinceLastFrame;                            // 0x00C4 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              HorizontalScale;                               // 0x00C8 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              VerticalScale;                                 // 0x00CC (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	uint32_t                                           bPaused : 1;                                   // 0x00D0 (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)
	uint32_t                                           bStopped : 1;                                  // 0x00D0 (0x0004) [0x0000000000000002] [0x00000002] (CPF_Const)
	uint32_t                                           bLooping : 1;                                  // 0x00D0 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bAutoPlay : 1;                                 // 0x00D0 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	int32_t                                            HorizontalImages;                              // 0x00D4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            VerticalImages;                                // 0x00D8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	ETextureFlipBookMethod                             FBMethod;                                      // 0x00DC (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              FrameRate;                                     // 0x00E0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              FrameTime;                                     // 0x00E4 (0x0004) [0x0000000000000000]               
	int32_t                                            CurrentRow;                                    // 0x00E8 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            CurrentColumn;                                 // 0x00EC (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              RenderOffsetU;                                 // 0x00F0 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	float                                              RenderOffsetV;                                 // 0x00F4 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FPointer                                    ReleaseResourcesFence;                         // 0x00F8 (0x0008) [0x0000000000001002] (CPF_Const | CPF_Native)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TextureFlipBook");
		}

		return uClassPointer;
	};

	void SetCurrentFrame(int32_t Row, int32_t Col);
	void Stop();
	void Pause();
	void Play();
};

// Class Engine.Texture3D
// 0x0000 (0x00B8 - 0x00B8)
class UTexture3D : public UTextureBaseGBX
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Texture3D");
		}

		return uClassPointer;
	};

};

// Class Engine.TextureCube
// 0x0038 (0x00B8 - 0x00F0)
class UTextureCube : public UTextureBaseGBX
{
public:
	class UTexture2D*                                  FacePosX;                                      // 0x00B8 (0x0008) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	class UTexture2D*                                  FaceNegX;                                      // 0x00C0 (0x0008) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	class UTexture2D*                                  FacePosY;                                      // 0x00C8 (0x0008) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	class UTexture2D*                                  FaceNegY;                                      // 0x00D0 (0x0008) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	class UTexture2D*                                  FacePosZ;                                      // 0x00D8 (0x0008) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	class UTexture2D*                                  FaceNegZ;                                      // 0x00E0 (0x0008) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	uint32_t                                           bFacePosXDirty : 1;                            // 0x00E8 (0x0004) [0x0000000020022002] [0x00000001] (CPF_Const | CPF_Transient | CPF_EditConst | CPF_Deprecated)
	uint32_t                                           bFaceNegXDirty : 1;                            // 0x00E8 (0x0004) [0x0000000020022002] [0x00000002] (CPF_Const | CPF_Transient | CPF_EditConst | CPF_Deprecated)
	uint32_t                                           bFacePosYDirty : 1;                            // 0x00E8 (0x0004) [0x0000000020022002] [0x00000004] (CPF_Const | CPF_Transient | CPF_EditConst | CPF_Deprecated)
	uint32_t                                           bFaceNegYDirty : 1;                            // 0x00E8 (0x0004) [0x0000000020022002] [0x00000008] (CPF_Const | CPF_Transient | CPF_EditConst | CPF_Deprecated)
	uint32_t                                           bFacePosZDirty : 1;                            // 0x00E8 (0x0004) [0x0000000020022002] [0x00000010] (CPF_Const | CPF_Transient | CPF_EditConst | CPF_Deprecated)
	uint32_t                                           bFaceNegZDirty : 1;                            // 0x00E8 (0x0004) [0x0000000020022002] [0x00000020] (CPF_Const | CPF_Transient | CPF_EditConst | CPF_Deprecated)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TextureCube");
		}

		return uClassPointer;
	};

};

// Class Engine.TextureMovie
// 0x0088 (0x0070 - 0x00F8)
class UTextureMovie : public UTexture
{
public:
	int32_t                                            SizeX;                                         // 0x0070 (0x0004) [0x0000000000000002] (CPF_Const)   
	int32_t                                            SizeY;                                         // 0x0074 (0x0004) [0x0000000000000002] (CPF_Const)   
	EPixelFormat                                       Format;                                        // 0x0078 (0x0001) [0x0000000020000002] (CPF_Const | CPF_Deprecated)
	ETextureAddress                                    AddressX;                                      // 0x0079 (0x0001) [0x0000000000000001] (CPF_Edit)    
	ETextureAddress                                    AddressY;                                      // 0x007A (0x0001) [0x0000000000000001] (CPF_Edit)    
	EMovieStreamSource                                 MovieStreamSource;                             // 0x007B (0x0001) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            TextureFormat;                                 // 0x007C (0x0004) [0x0000000000000002] (CPF_Const)   
	class UClass*                                      DecoderClass;                                  // 0x0080 (0x0008) [0x0000000000000002] (CPF_Const)   
	class UCodecMovie*                                 Decoder;                                       // 0x0088 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	uint32_t                                           Paused : 1;                                    // 0x0090 (0x0004) [0x0000000000002002] [0x00000001] (CPF_Const | CPF_Transient)
	uint32_t                                           Stopped : 1;                                   // 0x0090 (0x0004) [0x0000000000002002] [0x00000002] (CPF_Const | CPF_Transient)
	uint32_t                                           GamePaused : 1;                                // 0x0090 (0x0004) [0x0000000000002002] [0x00000004] (CPF_Const | CPF_Transient)
	uint32_t                                           Looping : 1;                                   // 0x0090 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           ResetOnLastFrame : 1;                          // 0x0090 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           AutoPlay : 1;                                  // 0x0090 (0x0004) [0x0000000000002001] [0x00000020] (CPF_Edit | CPF_Transient)
	class FString                                      MovieName;                                     // 0x0098 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)
	struct FUntypedBulkData_Mirror                     Data;                                          // 0x00A8 (0x0048) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FPointer                                    ReleaseCodecFence;                             // 0x00F0 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TextureMovie");
		}

		return uClassPointer;
	};

	void Stop();
	void Pause(bool optionalBIsGamePaused);
	void Play(bool optionalBUnpauseGamePaused);
};

// Class Engine.TextureRenderTarget
// 0x0008 (0x0070 - 0x0078)
class UTextureRenderTarget : public UTexture
{
public:
	uint32_t                                           bUpdateImmediate : 1;                          // 0x0070 (0x0004) [0x0000000020002000] [0x00000001] (CPF_Transient | CPF_Deprecated)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TextureRenderTarget");
		}

		return uClassPointer;
	};

};

// Class Engine.TextureRenderTarget2D
// 0x0010 (0x0078 - 0x0088)
class UTextureRenderTarget2D : public UTextureRenderTarget
{
public:
	int32_t                                            SizeX;                                         // 0x0078 (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            SizeY;                                         // 0x007C (0x0004) [0x0000000000000003] (CPF_Edit | CPF_Const)
	int32_t                                            TextureFormat;                                 // 0x0080 (0x0004) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TextureRenderTarget2D");
		}

		return uClassPointer;
	};

	static class UTextureRenderTarget2D* Create(int32_t InSizeX, int32_t InSizeY, int32_t optionalInFormat);
};

// Class Engine.ScriptedTexture
// 0x0018 (0x0088 - 0x00A0)
class UScriptedTexture : public UTextureRenderTarget2D
{
public:
	uint32_t                                           bNeedsUpdate : 1;                              // 0x0088 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)
	uint32_t                                           bSkipNextClear : 1;                            // 0x0088 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	struct FScriptDelegate                             __Render__Delegate;                            // 0x0090 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ScriptedTexture");
		}

		return uClassPointer;
	};

	void Render(class UCanvas* C);
};

// Class Engine.TextureRenderTargetCube
// 0x0008 (0x0078 - 0x0080)
class UTextureRenderTargetCube : public UTextureRenderTarget
{
public:
	int32_t                                            SizeX;                                         // 0x0078 (0x0004) [0x0000000000000001] (CPF_Edit)    
	int32_t                                            TextureFormat;                                 // 0x007C (0x0004) [0x0000000000000002] (CPF_Const)   

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TextureRenderTargetCube");
		}

		return uClassPointer;
	};

};

// Class Engine.SVehicleWheel
// 0x0100 (0x0068 - 0x0168)
class USVehicleWheel : public UComponent
{
public:
	float                                              Steer;                                         // 0x0068 (0x0004) [0x0000000000000000]               
	float                                              MotorTorque;                                   // 0x006C (0x0004) [0x0000000000000000]               
	float                                              BrakeTorque;                                   // 0x0070 (0x0004) [0x0000000000000000]               
	float                                              ChassisTorque;                                 // 0x0074 (0x0004) [0x0000000000000000]               
	uint32_t                                           bPoweredWheel : 1;                             // 0x0078 (0x0004) [0x0000000000000001] [0x00000001] (CPF_Edit)
	uint32_t                                           bHoverWheel : 1;                               // 0x0078 (0x0004) [0x0000000000000001] [0x00000002] (CPF_Edit)
	uint32_t                                           bNoContactWheel : 1;                           // 0x0078 (0x0004) [0x0000000000000001] [0x00000004] (CPF_Edit)
	uint32_t                                           bCollidesVehicles : 1;                         // 0x0078 (0x0004) [0x0000000000000001] [0x00000008] (CPF_Edit)
	uint32_t                                           bCollidesPawns : 1;                            // 0x0078 (0x0004) [0x0000000000000001] [0x00000010] (CPF_Edit)
	uint32_t                                           bIsSquealing : 1;                              // 0x0078 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bWheelOnGround : 1;                            // 0x0078 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bForceWantsParticleComponent : 1;              // 0x0078 (0x0004) [0x0000000000000001] [0x00000080] (CPF_Edit)
	float                                              SteerFactor;                                   // 0x007C (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FName                                       SkelControlName;                               // 0x0080 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class USkelControlWheel*                           WheelControl;                                  // 0x0088 (0x0008) [0x0000000000000000]               
	struct FName                                       BoneName;                                      // 0x0090 (0x0008) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     BoneOffset;                                    // 0x0098 (0x000C) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelRadius;                                   // 0x00A4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              WheelWidth;                                    // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SuspensionTravel;                              // 0x00AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              SuspensionSpeed;                               // 0x00B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UParticleSystem*                             WheelParticleSystem;                           // 0x00B8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	EWheelSide                                         Side;                                          // 0x00C0 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              LongSlipFactor;                                // 0x00C4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              LatSlipFactor;                                 // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              HandbrakeLongSlipFactor;                       // 0x00CC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              HandbrakeLatSlipFactor;                        // 0x00D0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ParkedSlipFactorLat;                           // 0x00D4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              ParkedSlipFactorLong;                          // 0x00D8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	struct FVector                                     WheelPosition;                                 // 0x00DC (0x000C) [0x0000000000000000]               
	float                                              SpinVel;                                       // 0x00E8 (0x0004) [0x0000000000000000]               
	float                                              LongSlipRatio;                                 // 0x00EC (0x0004) [0x0000000000000000]               
	float                                              LatSlipAngle;                                  // 0x00F0 (0x0004) [0x0000000000000000]               
	struct FVector                                     ContactNormal;                                 // 0x00F4 (0x000C) [0x0000000000000000]               
	struct FVector                                     LongDirection;                                 // 0x0100 (0x000C) [0x0000000000000000]               
	struct FVector                                     LatDirection;                                  // 0x010C (0x000C) [0x0000000000000000]               
	float                                              ContactForce;                                  // 0x0118 (0x0004) [0x0000000000000000]               
	float                                              LongImpulse;                                   // 0x011C (0x0004) [0x0000000000000000]               
	float                                              LatImpulse;                                    // 0x0120 (0x0004) [0x0000000000000000]               
	class UPhysicalMaterial*                           ContactPhysMat;                                // 0x0128 (0x0008) [0x0000000000000000]               
	float                                              WaterContactZOffset;                           // 0x0130 (0x0004) [0x0000000000000000]               
	float                                              DesiredSuspensionPosition;                     // 0x0134 (0x0004) [0x0000000000000000]               
	float                                              SuspensionPosition;                            // 0x0138 (0x0004) [0x0000000000000000]               
	float                                              CurrentRotation;                               // 0x013C (0x0004) [0x0000000000000000]               
	struct FPointer                                    WheelShape;                                    // 0x0140 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	int32_t                                            WheelMaterialIndex;                            // 0x0148 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class UClass*                                      WheelPSCClass;                                 // 0x0150 (0x0008) [0x0000000000000000]               
	class UParticleSystemComponent*                    WheelParticleComp;                             // 0x0158 (0x0008) [0x0000000004080008] (CPF_ExportObject | CPF_Component | CPF_EditInline)
	struct FName                                       SlipParticleParamName;                         // 0x0160 (0x0008) [0x0000000000000001] (CPF_Edit)    

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SVehicleWheel");
		}

		return uClassPointer;
	};

};

// Class Engine.TargetableList
// 0x0060 (0x0058 - 0x00B8)
class UTargetableList : public UObject
{
public:
	struct FMultiMap_Mirror                            TargetableAllegianceMap;                       // 0x0058 (0x0050) [0x0000000000001002] (CPF_Const | CPF_Native)
	class TArray<class UITargetable*>                  FullTargetableList;                            // 0x00A8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TargetableList");
		}

		return uClassPointer;
	};

	void GetDebugInfo(class TArray<class FString>& DebugInfo);
	static void ResetAllegiance(class UITargetable* Subject);
	class UITargetable* GetNext(struct FSearchState& out_State);
	class UITargetable* StartSearch(class UITargetable* Subject, ETargetableListSearchType Type, struct FSearchState& out_State);
	void UnRegisterTargetable(class UITargetable* Targetable);
	void RegisterTargetable(class UITargetable* Targetable);
};

// Class Engine.TerrainLayerSetup
// 0x0010 (0x0058 - 0x0068)
class UTerrainLayerSetup : public UObject
{
public:
	class TArray<struct FTerrainFilteredMaterial>      Materials;                                     // 0x0058 (0x0010) [0x0000000000400003] (CPF_Edit | CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TerrainLayerSetup");
		}

		return uClassPointer;
	};

	void PostBeginPlay();
};

// Class Engine.TerrainMaterial
// 0x0088 (0x0058 - 0x00E0)
class UTerrainMaterial : public UObject
{
public:
	uint8_t                                           UnknownData00[0x8];                            // 0x0058 (0x0008) MISSED OFFSET
	struct FMatrix                                     LocalToMapping;                                // 0x0060 (0x0040) [0x0000000000000000]               
	ETerrainMappingType                                MappingType;                                   // 0x00A0 (0x0001) [0x0000000000000001] (CPF_Edit)    
	float                                              MappingScale;                                  // 0x00A4 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MappingRotation;                               // 0x00A8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MappingPanU;                                   // 0x00AC (0x0004) [0x0000000000000001] (CPF_Edit)    
	float                                              MappingPanV;                                   // 0x00B0 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class UMaterialInterface*                          Material;                                      // 0x00B8 (0x0008) [0x0000000000000001] (CPF_Edit)    
	class UTexture2D*                                  DisplacementMap;                               // 0x00C0 (0x0008) [0x0000000000000001] (CPF_Edit)    
	float                                              DisplacementScale;                             // 0x00C8 (0x0004) [0x0000000000000001] (CPF_Edit)    
	class TArray<struct FTerrainFoliageMesh>           FoliageMeshes;                                 // 0x00D0 (0x0010) [0x0000000000400001] (CPF_Edit | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TerrainMaterial");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStoreSubscriber
// 0x0000 (0x0058 - 0x0058)
class UUIDataStoreSubscriber : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStoreSubscriber");
		}

		return uClassPointer;
	};

	void ClearBoundDataStores();
	void GetBoundDataStores(class TArray<class UUIDataStore*>& out_BoundDataStores);
	void NotifyDataStoreValueUpdated(class UUIDataStore* SourceDataStore, bool bValuesInvalidated, const struct FName& PropertyTag, class UUIDataProvider* SourceProvider, int32_t ArrayIndex);
	bool RefreshSubscriberValue(int32_t optionalBindingIndex);
	class FString GetDataStoreBinding(int32_t optionalBindingIndex);
	void SetDataStoreBinding(const class FString& MarkupText, int32_t optionalBindingIndex);
};

// Class Engine.UIDataStorePublisher
// 0x0000 (0x0058 - 0x0058)
class UUIDataStorePublisher : public UUIDataStoreSubscriber
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStorePublisher");
		}

		return uClassPointer;
	};

	bool SaveSubscriberValue(int32_t optionalBindingIndex, class TArray<class UUIDataStore*>& out_BoundDataStores);
};

// Class Engine.UIListElementCellProvider
// 0x0000 (0x0058 - 0x0058)
class UUIListElementCellProvider : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIListElementCellProvider");
		}

		return uClassPointer;
	};

};

// Class Engine.UIListElementProvider
// 0x0000 (0x0058 - 0x0058)
class UUIListElementProvider : public UInterface
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIListElementProvider");
		}

		return uClassPointer;
	};

};

// Class Engine.UIRoot
// 0x0010 (0x0058 - 0x0068)
class UUIRoot : public UObject
{
public:
	class TArray<class FString>                        BadCapsLocContexts;                            // 0x0058 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIRoot");
		}

		return uClassPointer;
	};

	static class FString SafeCaps(const class FString& StringToCap);
	static class UOnlinePlayerInterfaceEx* GetOnlinePlayerInterfaceEx();
	static class UOnlinePlayerInterface* GetOnlinePlayerInterface();
	static class UOnlineGameInterface* GetOnlineGameInterface();
	static class UUIDataStore* StaticResolveDataStore(const struct FName& DataStoreTag, class ULocalPlayer* optionalInPlayerOwner);
	static class UGameUISceneClient* GetSceneClient();
	static class UUIInteraction* GetCurrentUIController();
};

// Class Engine.Interaction
// 0x0040 (0x0068 - 0x00A8)
class UInteraction : public UUIRoot
{
public:
	struct FScriptDelegate                             __OnReceivedNativeInputKey__Delegate;          // 0x0068 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReceivedNativeInputAxis__Delegate;         // 0x0078 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnReceivedNativeInputChar__Delegate;         // 0x0088 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnInitialize__Delegate;                      // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Interaction");
		}

		return uClassPointer;
	};

	void NotifyPlayerRemoved(int32_t PlayerIndex, class ULocalPlayer* RemovedPlayer);
	void NotifyPlayerAdded(int32_t PlayerIndex, class ULocalPlayer* AddedPlayer);
	void NotifyGameSessionEnded();
	void Initialized();
	void OnInitialize();
	void Init();
	void eventPostRender(class UCanvas* Canvas);
	void eventTick(float DeltaTime);
	bool OnReceivedNativeInputChar(const struct FPlatformUserId& UserId, const class FString& Unicode);
	bool OnReceivedNativeInputAxis(const struct FPlatformUserId& UserId, const struct FName& Key, float Delta, float DeltaTime, bool optionalBGamepad);
	bool OnReceivedNativeInputKey(const struct FPlatformUserId& UserId, const struct FName& Key, EInputEvent EventType, float optionalAmountDepressed, bool optionalBGamepad);
};

// Class Engine.UIInteraction
// 0x0178 (0x00A8 - 0x0220)
class UUIInteraction : public UInteraction
{
public:
	struct FPointer                                    VfTable_FExec;                                 // 0x00A8 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_FGlobalDataStoreClientManager;         // 0x00B0 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_FCallbackEventDevice;                  // 0x00B8 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class UUIManager*                                  UIManager;                                     // 0x00C0 (0x0008) [0x0000000000000000]               
	class UClass*                                      UIManagerClass;                                // 0x00C8 (0x0008) [0x0000000000000000]               
	class UClass*                                      SceneClientClass;                              // 0x00D0 (0x0008) [0x0000000000000000]               
	class UGameUISceneClient*                          SceneClient;                                   // 0x00D8 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class TArray<struct FName>                         SupportedDoubleClickKeys;                      // 0x00E0 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class UDataStoreClient*                            DataStoreManager;                              // 0x00F0 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	uint8_t                                           UnknownData00[0x50];                           // 0x00F8 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.UIInteraction.bProcessInput
	float                                              UIJoystickDeadZone;                            // 0x0148 (0x0004) [0x0000000000004002] (CPF_Const | CPF_Config)
	float                                              UIAxisMultiplier;                              // 0x014C (0x0004) [0x0000000000004002] (CPF_Const | CPF_Config)
	float                                              AxisRepeatDelay;                               // 0x0150 (0x0004) [0x0000000000004002] (CPF_Const | CPF_Config)
	float                                              MouseButtonRepeatDelay;                        // 0x0154 (0x0004) [0x0000000000004002] (CPF_Const | CPF_Config)
	float                                              DoubleClickTriggerSeconds;                     // 0x0158 (0x0004) [0x0000000000004002] (CPF_Const | CPF_Config)
	int32_t                                            DoubleClickPixelTolerance;                     // 0x015C (0x0004) [0x0000000000004002] (CPF_Const | CPF_Config)
	struct FUIKeyRepeatData                            MouseButtonRepeatInfo;                         // 0x0160 (0x0010) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class TArray<struct FUIAxisEmulationDefinition>    ConfiguredAxisEmulationDefinitions;            // 0x0170 (0x0010) [0x0000000000404002] (CPF_Const | CPF_Config | CPF_NeedCtorLink)
	uint8_t                                           UnknownData01[0x50];                           // 0x0180 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.UIInteraction.AxisEmulationDefinitions
	uint8_t                                           UnknownData02[0x50];                           // 0x01D0 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.UIInteraction.AxisInputEmulation

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIInteraction");
		}

		return uClassPointer;
	};

	void NotifyGameSessionEnded();
	void NotifyPlayerRemoved(int32_t PlayerIndex, class ULocalPlayer* RemovedPlayer);
	void NotifyPlayerAdded(int32_t PlayerIndex, class ULocalPlayer* AddedPlayer);
};

// Class Engine.UIManager
// 0x0000 (0x0058 - 0x0058)
class UUIManager : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIManager");
		}

		return uClassPointer;
	};

	void NotifyPlayerRemoved(int32_t PlayerIndex, class ULocalPlayer* RemovedPlayer);
	void NotifyPlayerAdded(int32_t PlayerIndex, class ULocalPlayer* AddedPlayer);
	void eventPauseGame(bool bDesiredPauseState, int32_t optionalPlayerIndex);
	bool CanUnpauseInternalUI();
	static class UUIManager* GetUIManager();
};

// Class Engine.DataStoreClient
// 0x0050 (0x0068 - 0x00B8)
class UDataStoreClient : public UUIRoot
{
public:
	class TArray<class FString>                        GlobalDataStoreClasses;                        // 0x0068 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class TArray<class UUIDataStore*>                  GlobalDataStores;                              // 0x0078 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<class FString>                        PlayerDataStoreClassNames;                     // 0x0088 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class TArray<class UClass*>                        PlayerDataStoreClasses;                        // 0x0098 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	class TArray<struct FPlayerDataStoreGroup>         PlayerDataStores;                              // 0x00A8 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DataStoreClient");
		}

		return uClassPointer;
	};

	void DebugDumpDataStoreInfo(bool bVerbose);
	void eventNotifyGameSessionEnded();
	class UClass* FindDataStoreClass(class UClass* RequiredMetaClass);
	void GetPlayerDataStoreClasses(class TArray<class UClass*>& out_DataStoreClasses);
	int32_t FindPlayerDataStoreIndex(class ULocalPlayer* PlayerOwner);
	bool UnregisterDataStore(class UUIDataStore* DataStore);
	bool RegisterDataStore(class UUIDataStore* DataStore, class ULocalPlayer* optionalPlayerOwner);
	class UUIDataStore* CreateDataStore(class UClass* DataStoreClass);
	class UUIDataStore* FindDataStore(const struct FName& DataStoreTag, class ULocalPlayer* optionalPlayerOwner);
};

// Class Engine.Console
// 0x01D8 (0x00A8 - 0x0280)
class UConsole : public UInteraction
{
public:
	class ULocalPlayer*                                ConsoleTargetPlayer;                           // 0x00A8 (0x0008) [0x0000000000000000]               
	class UTexture2D*                                  DefaultTexture_Black;                          // 0x00B0 (0x0008) [0x0000000000000000]               
	class UTexture2D*                                  DefaultTexture_White;                          // 0x00B8 (0x0008) [0x0000000000000000]               
	struct FName                                       ConsoleKey;                                    // 0x00C0 (0x0008) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	struct FName                                       TypeKey;                                       // 0x00C8 (0x0008) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	int32_t                                            MaxScrollbackSize;                             // 0x00D0 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	class TArray<class FString>                        Scrollback;                                    // 0x00D8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            SBHead;                                        // 0x00E8 (0x0004) [0x0000000000000000]               
	int32_t                                            SBPos;                                         // 0x00EC (0x0004) [0x0000000000000000]               
	int32_t                                            HistoryTop;                                    // 0x00F0 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            HistoryBot;                                    // 0x00F4 (0x0004) [0x0000000000004000] (CPF_Config)  
	int32_t                                            HistoryCur;                                    // 0x00F8 (0x0004) [0x0000000000004000] (CPF_Config)  
	class FString                                      History[0x10];                                 // 0x0100 (0x0100) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	uint32_t                                           bNavigatingHistory : 1;                        // 0x0200 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)
	uint32_t                                           bCaptureKeyInput : 1;                          // 0x0200 (0x0004) [0x0000000000002000] [0x00000002] (CPF_Transient)
	uint32_t                                           bCtrl : 1;                                     // 0x0200 (0x0004) [0x0000000000000000] [0x00000004] 
	uint32_t                                           bEnableUI : 1;                                 // 0x0200 (0x0004) [0x0000000000004000] [0x00000008] (CPF_Config)
	uint32_t                                           bAutoCompleteLocked : 1;                       // 0x0200 (0x0004) [0x0000000000002000] [0x00000010] (CPF_Transient)
	uint32_t                                           bRequireCtrlToNavigateAutoComplete : 1;        // 0x0200 (0x0004) [0x0000000000004000] [0x00000020] (CPF_Config)
	uint32_t                                           bIsRuntimeAutoCompleteUpToDate : 1;            // 0x0200 (0x0004) [0x0000000000002000] [0x00000040] (CPF_Transient)
	class FString                                      TypedStr;                                      // 0x0208 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	int32_t                                            TypedStrPos;                                   // 0x0218 (0x0004) [0x0000000000000000]               
	class TArray<struct FAutoCompleteCommand>          ManualAutoCompleteList;                        // 0x0220 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class TArray<struct FAutoCompleteCommand>          AutoCompleteList;                              // 0x0230 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	int32_t                                            AutoCompleteIndex;                             // 0x0240 (0x0004) [0x0000000000002000] (CPF_Transient)
	struct FAutoCompleteNode                           AutoCompleteTree;                              // 0x0248 (0x0028) [0x0000000000003000] (CPF_Native | CPF_Transient)
	class TArray<int32_t>                              AutoCompleteIndices;                           // 0x0270 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Console");
		}

		return uClassPointer;
	};

	void UpdateCompleteIndices();
	void BuildRuntimeAutoCompleteList(bool optionalBForce);
	void AppendInputText(const class FString& Text);
	bool ProcessControlKey(const struct FName& Key, EInputEvent Event);
	void FlushPlayerInput();
	bool InputChar(const struct FPlatformUserId& UserId, const class FString& Unicode);
	bool InputKey(const struct FPlatformUserId& UserId, const struct FName& Key, EInputEvent Event, float optionalAmountDepressed, bool optionalBGamepad);
	void PostRender_Console(class UCanvas* Canvas);
	void StartTyping(const class FString& Text);
	void eventOutputText(const class FString& Text);
	void OutputTextLine(const class FString& Text);
	void ClearOutput();
	void eventConsoleCommand(const class FString& Command);
	void ShippingConsoleCommand(const class FString& Command);
	void PurgeCommandFromHistory(const class FString& Command);
	void SetCursorPos(int32_t Position);
	void SetInputText(const class FString& Text);
	void Initialized();
};

// Class Engine.Input
// 0x0090 (0x00A8 - 0x0138)
class UInput : public UInteraction
{
public:
	class TArray<struct FKeyBind>                      Bindings;                                      // 0x00A8 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	class TArray<struct FName>                         PressedKeys;                                   // 0x00B8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	EInputEvent                                        CurrentEvent;                                  // 0x00C8 (0x0001) [0x0000000000000002] (CPF_Const)   
	float                                              CurrentDelta;                                  // 0x00CC (0x0004) [0x0000000000000002] (CPF_Const)   
	float                                              CurrentDeltaTime;                              // 0x00D0 (0x0004) [0x0000000000000002] (CPF_Const)   
	uint8_t                                           UnknownData00[0x50];                           // 0x00D8 (0x0050) UNKNOWN PROPERTY: MapProperty Engine.Input.NameToPtr
	class TArray<struct FPointer>                      AxisArray;                                     // 0x0128 (0x0010) [0x0000000000101002] (CPF_Const | CPF_Native)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Input");
		}

		return uClassPointer;
	};

	void SetBind(const class FString& Command, struct FName& BindName);
	class FString GetBind(struct FName& Key);
	void ResetInput();
};

// Class Engine.PlayerInput
// 0x00B0 (0x0138 - 0x01E8)
class UPlayerInput : public UInput
{
public:
	uint32_t                                           bUsingGamepad : 1;                             // 0x0138 (0x0004) [0x0000000000000002] [0x00000001] (CPF_Const)
	uint32_t                                           bInvertGamepad : 1;                            // 0x0138 (0x0004) [0x0000000000044000] [0x00000002] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bInvertMouse : 1;                              // 0x0138 (0x0004) [0x0000000000044000] [0x00000004] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bInvertTurn : 1;                               // 0x0138 (0x0004) [0x0000000000044000] [0x00000008] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bInvertGamepadTurn : 1;                        // 0x0138 (0x0004) [0x0000000000000000] [0x00000010] 
	uint32_t                                           bInvertGamepadMove : 1;                        // 0x0138 (0x0004) [0x0000000000000000] [0x00000020] 
	uint32_t                                           bInvertGamepadStrafe : 1;                      // 0x0138 (0x0004) [0x0000000000000000] [0x00000040] 
	uint32_t                                           bWasForward : 1;                               // 0x0138 (0x0004) [0x0000000000000000] [0x00000080] 
	uint32_t                                           bWasBack : 1;                                  // 0x0138 (0x0004) [0x0000000000000000] [0x00000100] 
	uint32_t                                           bWasLeft : 1;                                  // 0x0138 (0x0004) [0x0000000000000000] [0x00000200] 
	uint32_t                                           bWasRight : 1;                                 // 0x0138 (0x0004) [0x0000000000000000] [0x00000400] 
	uint32_t                                           bEdgeForward : 1;                              // 0x0138 (0x0004) [0x0000000000000000] [0x00000800] 
	uint32_t                                           bEdgeBack : 1;                                 // 0x0138 (0x0004) [0x0000000000000000] [0x00001000] 
	uint32_t                                           bEdgeLeft : 1;                                 // 0x0138 (0x0004) [0x0000000000000000] [0x00002000] 
	uint32_t                                           bEdgeRight : 1;                                // 0x0138 (0x0004) [0x0000000000000000] [0x00004000] 
	uint32_t                                           bEnableMouseSmoothing : 1;                     // 0x0138 (0x0004) [0x0000000000044000] [0x00008000] (CPF_Config | CPF_GlobalConfig)
	uint32_t                                           bEnableFOVScaling : 1;                         // 0x0138 (0x0004) [0x0000000000000000] [0x00010000] 
	uint32_t                                           bLockTurnUntilRelease : 1;                     // 0x0138 (0x0004) [0x0000000000002000] [0x00020000] (CPF_Transient)
	struct FName                                       LastAxisKeyName;                               // 0x013C (0x0008) [0x0000000000000002] (CPF_Const)   
	float                                              DoubleClickTimer;                              // 0x0144 (0x0004) [0x0000000000000000]               
	float                                              DoubleClickTime;                               // 0x0148 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MouseSensitivityX;                             // 0x014C (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              MouseSensitivityY;                             // 0x0150 (0x0004) [0x0000000000044000] (CPF_Config | CPF_GlobalConfig)
	float                                              aBaseX;                                        // 0x0154 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aBaseY;                                        // 0x0158 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aBaseZ;                                        // 0x015C (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aMouseX;                                       // 0x0160 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aMouseY;                                       // 0x0164 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aForward;                                      // 0x0168 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aTurn;                                         // 0x016C (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aStrafe;                                       // 0x0170 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aUp;                                           // 0x0174 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aLookUp;                                       // 0x0178 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aRightAnalogTrigger;                           // 0x017C (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aLeftAnalogTrigger;                            // 0x0180 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aPS3AccelX;                                    // 0x0184 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aPS3AccelY;                                    // 0x0188 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aPS3AccelZ;                                    // 0x018C (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              aPS3Gyro;                                      // 0x0190 (0x0004) [0x0000000000000004] (CPF_Input)   
	float                                              RawJoyUp;                                      // 0x0194 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              RawJoyRight;                                   // 0x0198 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              RawJoyLookRight;                               // 0x019C (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              RawJoyLookUp;                                  // 0x01A0 (0x0004) [0x0000000000002000] (CPF_Transient)
	float                                              MoveForwardSpeed;                              // 0x01A4 (0x0004) [0x0000000000004001] (CPF_Edit | CPF_Config)
	float                                              MoveStrafeSpeed;                               // 0x01A8 (0x0004) [0x0000000000004001] (CPF_Edit | CPF_Config)
	float                                              LookRightScale;                                // 0x01AC (0x0004) [0x0000000000004001] (CPF_Edit | CPF_Config)
	float                                              LookUpScale;                                   // 0x01B0 (0x0004) [0x0000000000004001] (CPF_Edit | CPF_Config)
	uint8_t                                            bStrafe;                                       // 0x01B4 (0x0001) [0x0000000000000004] (CPF_Input)   
	uint8_t                                            bXAxis;                                        // 0x01B5 (0x0001) [0x0000000000000004] (CPF_Input)   
	uint8_t                                            bYAxis;                                        // 0x01B6 (0x0001) [0x0000000000000004] (CPF_Input)   
	float                                              ZeroTime[0x2];                                 // 0x01B8 (0x0008) [0x0000000000000000]               
	float                                              SmoothedMouse[0x2];                            // 0x01C0 (0x0008) [0x0000000000000000]               
	int32_t                                            MouseSamples;                                  // 0x01C8 (0x0004) [0x0000000000000000]               
	float                                              MouseSamplingTotal;                            // 0x01CC (0x0004) [0x0000000000000000]               
	float                                              AutoUnlockTurnTime;                            // 0x01D0 (0x0004) [0x0000000000002000] (CPF_Transient)
	class TArray<class UIPlayerInputObserver*>         PlayerInputObservers;                          // 0x01D8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PlayerInput");
		}

		return uClassPointer;
	};

	void PreClientTravel(const class FString& PendingURL, ETravelType TravelType, bool bIsSeamlessTravel);
	void ClientInitInputSystem();
	void InitInputSystem();
	float SmoothMouse(float aMouse, float DeltaTime, int32_t Index, uint8_t& SampleCount);
	void ClearSmoothing();
	void SmartJump();
	void Jump();
	void ProcessInputMatching(float DeltaTime);
	EDoubleClickDir CheckForDoubleClickMove(float DeltaTime);
	void CatchDoubleClickInput();
	void eventPlayerInput(float DeltaTime);
	void PostProcessInput(float DeltaTime);
	void PreProcessInput(float DeltaTime);
	void DrawHUD(class AHUD* H);
	void SetSensitivity(float X, float Y);
	bool InvertTurn();
	bool InvertGamepad();
	bool InvertMouse();
	void UnregisterObserver(class UIPlayerInputObserver* PlayerInputObserver);
	void RegisterObserver(class UIPlayerInputObserver* PlayerInputObserver);
	void NotifyObserversUsingGamepadChanged();
};

// Class Engine.DebugCameraInput
// 0x0000 (0x01E8 - 0x01E8)
class UDebugCameraInput : public UPlayerInput
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DebugCameraInput");
		}

		return uClassPointer;
	};

	bool InputKey(const struct FPlatformUserId& UserId, const struct FName& Key, EInputEvent Event, float optionalAmountDepressed, bool optionalBGamepad);
};

// Class Engine.PlayerManagerInteraction
// 0x0000 (0x00A8 - 0x00A8)
class UPlayerManagerInteraction : public UInteraction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PlayerManagerInteraction");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataProvider
// 0x0028 (0x0068 - 0x0090)
class UUIDataProvider : public UUIRoot
{
public:
	EProviderAccessType                                WriteAccessType;                               // 0x0068 (0x0001) [0x0000000000000000]               
	class TArray<struct FScriptDelegate>               ProviderChangedNotifies;                       // 0x0070 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnDataProviderPropertyChange__Delegate;      // 0x0080 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataProvider");
		}

		return uClassPointer;
	};

	int32_t ParseTagArrayDelimiter(struct FName& FieldName);
	bool RemovePropertyNotificationChangeRequest(const struct FScriptDelegate& InDelegate);
	bool AddPropertyNotificationChangeRequest(const struct FScriptDelegate& InDelegate, bool optionalBAllowDuplicates);
	void eventNotifyPropertyChanged(const struct FName& optionalPropTag);
	bool eventIsCollectionDataType(EUIDataProviderFieldType FieldType);
	bool eventIsProviderDisabled();
	class FString eventGenerateFillerData(const class FString& DataTag);
	class FString eventGenerateScriptMarkupString(const struct FName& DataTag);
	void eventGetSupportedScriptFields(class TArray<struct FUIDataProviderField>& out_Fields);
	void OnDataProviderPropertyChange(class UUIDataProvider* SourceProvider, const struct FName& optionalPropTag);
};

// Class Engine.UIConfigProvider
// 0x0000 (0x0090 - 0x0090)
class UUIConfigProvider : public UUIDataProvider
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIConfigProvider");
		}

		return uClassPointer;
	};

};

// Class Engine.UIConfigFileProvider
// 0x0020 (0x0090 - 0x00B0)
class UUIConfigFileProvider : public UUIConfigProvider
{
public:
	class TArray<class UUIConfigSectionProvider*>      Sections;                                      // 0x0090 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)
	class FString                                      ConfigFileName;                                // 0x00A0 (0x0010) [0x0000000000C02000] (CPF_Transient | CPF_NeedCtorLink | CPF_NoExport)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIConfigFileProvider");
		}

		return uClassPointer;
	};

};

// Class Engine.UIConfigSectionProvider
// 0x0010 (0x0090 - 0x00A0)
class UUIConfigSectionProvider : public UUIConfigProvider
{
public:
	class FString                                      SectionName;                                   // 0x0090 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIConfigSectionProvider");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore
// 0x0028 (0x0090 - 0x00B8)
class UUIDataStore : public UUIDataProvider
{
public:
	struct FName                                       Tag;                                           // 0x0090 (0x0008) [0x0000000000000000]               
	class TArray<struct FScriptDelegate>               RefreshSubscriberNotifies;                     // 0x0098 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)
	struct FScriptDelegate                             __OnDataStoreValueUpdated__Delegate;           // 0x00A8 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore");
		}

		return uClassPointer;
	};

	class UDataStoreClient* GetDataStoreClient();
	void OnCommit();
	void eventRefreshSubscribers(const struct FName& optionalPropertyTag, bool optionalBInvalidateValues, class UUIDataProvider* optionalSourceProvider, int32_t optionalArrayIndex);
	bool NotifyGameSessionEnded();
	void eventSubscriberDetached(class UUIDataStoreSubscriber* Subscriber);
	void eventSubscriberAttached(class UUIDataStoreSubscriber* Subscriber);
	void eventUnregistered(class ULocalPlayer* PlayerOwner);
	void eventRegistered(class ULocalPlayer* PlayerOwner);
	void OnDataStoreValueUpdated(class UUIDataStore* SourceDataStore, bool bValuesInvalidated, const struct FName& PropertyTag, class UUIDataProvider* SourceProvider, int32_t ArrayIndex);
};

// Class Engine.UIDataStore_StringBase
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_StringBase : public UUIDataStore
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_StringBase");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_StringAliasMap
// 0x0068 (0x00B8 - 0x0120)
class UUIDataStore_StringAliasMap : public UUIDataStore_StringBase
{
public:
	class TArray<struct FUIMenuInputMap>               MenuInputMapArray;                             // 0x00B8 (0x0010) [0x0000000000404000] (CPF_Config | CPF_NeedCtorLink)
	struct FMap_Mirror                                 MenuInputSets;                                 // 0x00C8 (0x0050) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	int32_t                                            PlayerIndex;                                   // 0x0118 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_StringAliasMap");
		}

		return uClassPointer;
	};

	class ULocalPlayer* GetPlayerOwner();
};

// Class Engine.UIDataStore_Strings
// 0x0010 (0x00B8 - 0x00C8)
class UUIDataStore_Strings : public UUIDataStore_StringBase
{
public:
	class TArray<class UUIConfigFileProvider*>         LocFileProviders;                              // 0x00B8 (0x0010) [0x0000000000402000] (CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_Strings");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDynamicFieldProvider
// 0x00C0 (0x0090 - 0x0150)
class UUIDynamicFieldProvider : public UUIDataProvider
{
public:
	class TArray<struct FUIProviderScriptFieldValue>   PersistentDataFields;                          // 0x0090 (0x0010) [0x0000000000404001] (CPF_Edit | CPF_Config | CPF_NeedCtorLink)
	class TArray<struct FUIProviderScriptFieldValue>   RuntimeDataFields;                             // 0x00A0 (0x0010) [0x0000000000402001] (CPF_Edit | CPF_Transient | CPF_NeedCtorLink)
	struct FMap_Mirror                                 PersistentCollectionData;                      // 0x00B0 (0x0050) [0x0000000000001002] (CPF_Const | CPF_Native)
	struct FMap_Mirror                                 RuntimeCollectionData;                         // 0x0100 (0x0050) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDynamicFieldProvider");
		}

		return uClassPointer;
	};

	int32_t FindCollectionValueIndex(const struct FName& FieldName, bool optionalBPersistent, const struct FName& optionalCellTag, class FString& ValueToFind);
	bool GetCollectionValue(const struct FName& FieldName, int32_t ValueIndex, bool optionalBPersistent, const struct FName& optionalCellTag, class FString& out_Value);
	bool ClearCollectionValueArray(const struct FName& FieldName, bool optionalBPersistent, const struct FName& optionalCellTag);
	bool ReplaceCollectionValueByIndex(const struct FName& FieldName, int32_t ValueIndex, bool optionalBPersistent, const struct FName& optionalCellTag, class FString& NewValue);
	bool ReplaceCollectionValue(const struct FName& FieldName, bool optionalBPersistent, const struct FName& optionalCellTag, class FString& CurrentValue, class FString& NewValue);
	bool RemoveCollectionValueByIndex(const struct FName& FieldName, int32_t ValueIndex, bool optionalBPersistent, const struct FName& optionalCellTag);
	bool RemoveCollectionValue(const struct FName& FieldName, bool optionalBPersistent, const struct FName& optionalCellTag, class FString& ValueToRemove);
	bool InsertCollectionValue(const struct FName& FieldName, int32_t optionalInsertIndex, bool optionalBPersistent, bool optionalBAllowDuplicateValues, const struct FName& optionalCellTag, class FString& NewValue);
	bool SetCollectionValueArray(const struct FName& FieldName, bool optionalBClearExisting, int32_t optionalInsertIndex, bool optionalBPersistent, const struct FName& optionalCellTag, class TArray<class FString>& CollectionValues);
	bool GetCollectionValueArray(const struct FName& FieldName, bool optionalBPersistent, const struct FName& optionalCellTag, class TArray<class FString>& out_DataValueArray);
	bool GetCollectionValueSchema(const struct FName& FieldName, bool optionalBPersistent, class TArray<struct FName>& out_CellTagArray);
	void SavePersistentProviderData();
	bool SetField(const struct FName& FieldName, bool optionalBChangeExistingOnly, struct FUIProviderScriptFieldValue& FieldValue);
	bool GetField(const struct FName& FieldName, struct FUIProviderScriptFieldValue& out_Field);
	bool ClearFields(bool optionalBReinitializeRuntimeFields);
	int32_t FindFieldIndex(const struct FName& FieldName, bool optionalBSearchPersistentFields);
	bool RemoveField(const struct FName& FieldName);
	bool AddField(const struct FName& FieldName, EUIDataProviderFieldType optionalFieldType, bool optionalBPersistent, int32_t& out_InsertPosition);
	void InitializeRuntimeFields();
};

// Class Engine.UIPropertyDataProvider
// 0x0020 (0x0090 - 0x00B0)
class UUIPropertyDataProvider : public UUIDataProvider
{
public:
	class TArray<class UClass*>                        ComplexPropertyTypes;                          // 0x0090 (0x0010) [0x0000000000400002] (CPF_Const | CPF_NeedCtorLink)
	struct FScriptDelegate                             __CanSupportComplexPropertyType__Delegate;     // 0x00A0 (0x0010) [0x0000000000400000] (CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIPropertyDataProvider");
		}

		return uClassPointer;
	};

	bool eventGetCustomPropertyValue(int32_t optionalArrayIndex, struct FUIProviderScriptFieldValue& PropertyValue);
	bool CanSupportComplexPropertyType(class UProperty* UnsupportedProperty);
};

// Class Engine.UIDynamicDataProvider
// 0x0018 (0x00B0 - 0x00C8)
class UUIDynamicDataProvider : public UUIPropertyDataProvider
{
public:
	struct FPointer                                    VfTable_IUIListElementCellProvider;            // 0x00B0 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class UClass*                                      DataClass;                                     // 0x00B8 (0x0008) [0x0000000000000002] (CPF_Const)   
	class UObject*                                     DataSource;                                    // 0x00C0 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDynamicDataProvider");
		}

		return uClassPointer;
	};

	bool CleanupDataProvider();
	class UObject* GetDataSource();
	bool eventIsValidDataSourceClass(class UClass* PotentialDataSourceClass);
	void eventProviderInstanceUnbound(class UObject* DataSourceInstance);
	void eventProviderInstanceBound(class UObject* DataSourceInstance);
	bool UnbindProviderInstance();
	bool BindProviderInstance(class UObject* DataSourceInstance);
};

// Class Engine.UIResourceDataProvider
// 0x0018 (0x00B0 - 0x00C8)
class UUIResourceDataProvider : public UUIPropertyDataProvider
{
public:
	struct FPointer                                    VfTable_IUIListElementProvider;                // 0x00B0 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IUIListElementCellProvider;            // 0x00B8 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	uint32_t                                           bDataBindingPropertiesOnly : 1;                // 0x00C0 (0x0004) [0x0000000000000000] [0x00000001] 
	uint32_t                                           bSkipDuringEnumeration : 1;                    // 0x00C0 (0x0004) [0x0000000000004000] [0x00000002] (CPF_Config)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIResourceDataProvider");
		}

		return uClassPointer;
	};

	void eventInitializeProvider(bool bIsEditor);
};

// Class Engine.UIResourceCombinationProvider
// 0x0018 (0x0090 - 0x00A8)
class UUIResourceCombinationProvider : public UUIDataProvider
{
public:
	struct FPointer                                    VfTable_IUIListElementProvider;                // 0x0090 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    VfTable_IUIListElementCellProvider;            // 0x0098 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	class UUIResourceDataProvider*                     StaticDataProvider;                            // 0x00A0 (0x0008) [0x0000000000002000] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIResourceCombinationProvider");
		}

		return uClassPointer;
	};

	bool ReplaceProviderCollection(const struct FName& TargetFieldTag, class TArray<struct FUIDataProviderField>& out_Fields, class TArray<class UUIDataProvider*>& ReplacementProviders);
	bool ReplaceProviderValue(const struct FName& TargetFieldTag, class UUIDataProvider* ReplacementProvider, class TArray<struct FUIDataProviderField>& out_Fields);
	void ClearProviderReferences();
	bool eventGetCellFieldValue(const struct FName& FieldName, const struct FName& CellTag, int32_t ListIndex, int32_t optionalArrayIndex, struct FUIProviderFieldValue& out_FieldValue);
	bool eventGetCellFieldType(const struct FName& FieldName, const struct FName& CellTag, EUIDataProviderFieldType& FieldType);
	void eventGetElementCellTags(const struct FName& FieldName, class TArray<struct FName>& CellFieldTags, class TArray<class FString>& ColumnHeaderDisplayText);
	bool eventGetElementCellValueProvider(const struct FName& FieldName, int32_t ListIndex, class UUIListElementCellProvider*& out_ValueProvider);
	bool eventGetElementCellSchemaProvider(const struct FName& FieldName, class UUIListElementCellProvider*& out_SchemaProvider);
	bool eventIsElementEnabled(const struct FName& FieldName, int32_t CollectionIndex);
	bool eventGetListElements(const struct FName& FieldName, class TArray<int32_t>& out_Elements);
	int32_t eventGetElementCount(const struct FName& FieldName);
	class TArray<struct FName> eventGetElementProviderTags();
	void eventInitializeProvider(bool bIsEditor, class UUIResourceDataProvider* InStaticResourceProvider);
};

// Class Engine.UISceneClient
// 0x00B8 (0x0068 - 0x0120)
class UUISceneClient : public UUIRoot
{
public:
	struct FPointer                                    VfTable_FExec;                                 // 0x0068 (0x0008) [0x0000000000801002] (CPF_Const | CPF_Native | CPF_NoExport)
	struct FPointer                                    RenderViewport;                                // 0x0070 (0x0008) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	struct FIntPoint                                   MousePosition;                                 // 0x0078 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class UDataStoreClient*                            DataStoreManager;                              // 0x0080 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	uint8_t                                           UnknownData00[0x8];                            // 0x0088 (0x0008) MISSED OFFSET
	struct FMatrix                                     CanvasToScreen;                                // 0x0090 (0x0040) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FMatrix                                     InvCanvasToScreen;                             // 0x00D0 (0x0040) [0x0000000000002002] (CPF_Const | CPF_Transient)
	class UPostProcessChain*                           UIScenePostProcess;                            // 0x0110 (0x0008) [0x0000000000002000] (CPF_Transient)
	uint32_t                                           bEnablePostProcess : 1;                        // 0x0118 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UISceneClient");
		}

		return uClassPointer;
	};

	void eventInitializeSceneClient();
	struct FMatrix GetInverseCanvasToScreen();
	struct FMatrix GetCanvasToScreen();
	bool IsUIActive(int32_t optionalFlags);
};

// Class Engine.GameUISceneClient
// 0x0090 (0x0120 - 0x01B0)
class UGameUISceneClient : public UUISceneClient
{
public:
	float                                              LatestDeltaTime;                               // 0x0120 (0x0004) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FDouble                                     DoubleClickStartTime;                          // 0x0128 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FIntPoint                                   DoubleClickStartPosition;                      // 0x0130 (0x0008) [0x0000000000002002] (CPF_Const | CPF_Transient)
	struct FMap_Mirror                                 InitialPressedKeys;                            // 0x0138 (0x0050) [0x0000000000003002] (CPF_Const | CPF_Native | CPF_Transient)
	uint32_t                                           bUpdateSceneViewportSizes : 1;                 // 0x0188 (0x0004) [0x0000000000002000] [0x00000001] (CPF_Transient)
	uint32_t                                           bEnableDebugInput : 1;                         // 0x0188 (0x0004) [0x0000000000004000] [0x00000002] (CPF_Config)
	uint32_t                                           bRenderDebugInfo : 1;                          // 0x0188 (0x0004) [0x0000000000004000] [0x00000004] (CPF_Config)
	uint32_t                                           bCaptureUnprocessedInput : 1;                  // 0x0188 (0x0004) [0x0000000000004002] [0x00000008] (CPF_Const | CPF_Config)
	class TArray<struct FName>                         NavAliases;                                    // 0x0190 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)
	class TArray<struct FName>                         AxisInputKeys;                                 // 0x01A0 (0x0010) [0x0000000000402002] (CPF_Const | CPF_Transient | CPF_NeedCtorLink)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GameUISceneClient");
		}

		return uClassPointer;
	};

	int32_t FindLocalPlayerIndex(class UPlayer* P);
	void NotifyPlayerRemoved(int32_t PlayerIndex, class ULocalPlayer* RemovedPlayer);
	void NotifyPlayerAdded(int32_t PlayerIndex, class ULocalPlayer* AddedPlayer);
	void NotifyGameSessionEnded();
	void NotifyClientTravel(class APlayerController* TravellingPlayer, const class FString& TravelURL, ETravelType TravelType, bool bIsSeamlessTravel);
	void eventPauseGame(bool bDesiredPauseState, int32_t optionalPlayerIndex);
	bool CanUnpauseInternalUI();
	static ENetMode GetCurrentNetMode();
};

// Class Engine.Vertex
// 0x0030 (0x0058 - 0x0088)
class UVertex : public UObject
{
public:
	class ULine*                                       ParentLine;                                    // 0x0058 (0x0008) [0x0000000000000000]               
	struct FVector                                     Position;                                      // 0x0060 (0x000C) [0x0000000000000000]               
	class UMaterial*                                   Material;                                      // 0x0070 (0x0008) [0x0000000000000000]               
	class UMaterial*                                   Material_Selected;                             // 0x0078 (0x0008) [0x0000000000000000]               
	uint32_t                                           bIsSelected : 1;                               // 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FColor                                      cColor;                                        // 0x0084 (0x0004) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Vertex");
		}

		return uClassPointer;
	};

};

// Class Engine.WaveFormBase
// 0x0008 (0x0058 - 0x0060)
class UWaveFormBase : public UObject
{
public:
	class UForceFeedbackWaveform*                      TheWaveForm;                                   // 0x0058 (0x0008) [0x0000000000000000]               

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WaveFormBase");
		}

		return uClassPointer;
	};

};

// Class Engine.World
// 0x1378 (0x0058 - 0x13D0)
class UWorld : public UObject
{
public:
	uint8_t											  UnknownData00[0xD0];
	UNetDriver*										  NetDriver;
	uint8_t                                           UnknownData01[0x12A0];                         // 0x0058 (0x1378) MISSED OFFSET

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.World");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryFracturedStaticMesh
// 0x0000 (0x00C0 - 0x00C0)
class UActorFactoryFracturedStaticMesh : public UActorFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryFracturedStaticMesh");
		}

		return uClassPointer;
	};

};

// Class Engine.ActorFactoryPathNode
// 0x0000 (0x00C0 - 0x00C0)
class UActorFactoryPathNode : public UActorFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ActorFactoryPathNode");
		}

		return uClassPointer;
	};

};

// Class Engine.ReachSpec
// 0x0000 (0x0058 - 0x0058)
class UReachSpec : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.AdvancedReachSpec
// 0x0000 (0x0058 - 0x0058)
class UAdvancedReachSpec : public UReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AdvancedReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.AISwitchablePylon
// 0x0000 (0x02A0 - 0x02A0)
class AAISwitchablePylon : public APylon
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AISwitchablePylon");
		}

		return uClassPointer;
	};

};

// Class Engine.AkBaseSoundObject
// 0x0000 (0x0058 - 0x0058)
class UAkBaseSoundObject : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AkBaseSoundObject");
		}

		return uClassPointer;
	};

};

// Class Engine.Ladder
// 0x0000 (0x0260 - 0x0260)
class ALadder : public ANavigationPoint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Ladder");
		}

		return uClassPointer;
	};

};

// Class Engine.AutoLadder
// 0x0000 (0x0260 - 0x0260)
class AAutoLadder : public ALadder
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AutoLadder");
		}

		return uClassPointer;
	};

};

// Class Engine.AutoNavMeshPathObstacleUnregister
// 0x0000 (0x0058 - 0x0058)
class UAutoNavMeshPathObstacleUnregister : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.AutoNavMeshPathObstacleUnregister");
		}

		return uClassPointer;
	};

};

// Class Engine.CeilingReachSpec
// 0x0000 (0x0058 - 0x0058)
class UCeilingReachSpec : public UReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CeilingReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.CoverReplicator
// 0x0000 (0x0240 - 0x0240)
class ACoverReplicator : public AReplicationInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CoverReplicator");
		}

		return uClassPointer;
	};

};

// Class Engine.ForcedReachSpec
// 0x0000 (0x0058 - 0x0058)
class UForcedReachSpec : public UReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ForcedReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.CoverSlipReachSpec
// 0x0000 (0x0058 - 0x0058)
class UCoverSlipReachSpec : public UForcedReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.CoverSlipReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.DoorMarker
// 0x0000 (0x0260 - 0x0260)
class ADoorMarker : public ANavigationPoint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DoorMarker");
		}

		return uClassPointer;
	};

};

// Class Engine.DroppedPickup
// 0x0000 (0x0240 - 0x0240)
class ADroppedPickup : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DroppedPickup");
		}

		return uClassPointer;
	};

};

// Class Engine.DynamicAnchor
// 0x0000 (0x0260 - 0x0260)
class ADynamicAnchor : public ANavigationPoint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.DynamicAnchor");
		}

		return uClassPointer;
	};

};

// Class Engine.EnvironmentVolume
// 0x0000 (0x0288 - 0x0288)
class AEnvironmentVolume : public AVolume
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.EnvironmentVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.FloorToCeilingReachSpec
// 0x0000 (0x0058 - 0x0058)
class UFloorToCeilingReachSpec : public UForcedReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FloorToCeilingReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.FluidInfluenceActor
// 0x0000 (0x0240 - 0x0240)
class AFluidInfluenceActor : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FluidInfluenceActor");
		}

		return uClassPointer;
	};

};

// Class Engine.FluidInfluenceComponent
// 0x0000 (0x0360 - 0x0360)
class UFluidInfluenceComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FluidInfluenceComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.FluidSurfaceActor
// 0x0000 (0x0240 - 0x0240)
class AFluidSurfaceActor : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FluidSurfaceActor");
		}

		return uClassPointer;
	};

};

// Class Engine.FluidSurfaceActorMovable
// 0x0000 (0x0240 - 0x0240)
class AFluidSurfaceActorMovable : public AFluidSurfaceActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FluidSurfaceActorMovable");
		}

		return uClassPointer;
	};

};

// Class Engine.FracturedSkinnedMeshComponent
// 0x0000 (0x0410 - 0x0410)
class UFracturedSkinnedMeshComponent : public UFracturedBaseComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FracturedSkinnedMeshComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.FracturedStaticMeshActor
// 0x0000 (0x0240 - 0x0240)
class AFracturedStaticMeshActor : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FracturedStaticMeshActor");
		}

		return uClassPointer;
	};

};

// Class Engine.FracturedSMActorSpawnable
// 0x0000 (0x0240 - 0x0240)
class AFracturedSMActorSpawnable : public AFracturedStaticMeshActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FracturedSMActorSpawnable");
		}

		return uClassPointer;
	};

};

// Class Engine.FracturedStaticMeshPart
// 0x0000 (0x0240 - 0x0240)
class AFracturedStaticMeshPart : public AFracturedStaticMeshActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FracturedStaticMeshPart");
		}

		return uClassPointer;
	};

};

// Class Engine.FractureManager
// 0x0000 (0x0240 - 0x0240)
class AFractureManager : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.FractureManager");
		}

		return uClassPointer;
	};

};

// Class Engine.WorldMusicManager
// 0x0000 (0x0240 - 0x0240)
class AWorldMusicManager : public AInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WorldMusicManager");
		}

		return uClassPointer;
	};

};

// Class Engine.GBXNavMeshPathModifier
// 0x0000 (0x0058 - 0x0058)
class UGBXNavMeshPathModifier : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXNavMeshPathModifier");
		}

		return uClassPointer;
	};

};

// Class Engine.GBXNavMeshPathModifier_Simplify
// 0x0000 (0x0058 - 0x0058)
class UGBXNavMeshPathModifier_Simplify : public UGBXNavMeshPathModifier
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXNavMeshPathModifier_Simplify");
		}

		return uClassPointer;
	};

};

// Class Engine.GBXNavMeshPathModifier_SmoothTurns
// 0x0000 (0x0058 - 0x0058)
class UGBXNavMeshPathModifier_SmoothTurns : public UGBXNavMeshPathModifier
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.GBXNavMeshPathModifier_SmoothTurns");
		}

		return uClassPointer;
	};

};

// Class Engine.PathGoalEvaluator
// 0x0000 (0x0058 - 0x0058)
class UPathGoalEvaluator : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PathGoalEvaluator");
		}

		return uClassPointer;
	};

};

// Class Engine.Goal_AtActor
// 0x0000 (0x0058 - 0x0058)
class UGoal_AtActor : public UPathGoalEvaluator
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Goal_AtActor");
		}

		return uClassPointer;
	};

};

// Class Engine.Goal_Null
// 0x0000 (0x0058 - 0x0058)
class UGoal_Null : public UPathGoalEvaluator
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Goal_Null");
		}

		return uClassPointer;
	};

};

// Class Engine.HybridNavigationArea
// 0x0000 (0x0240 - 0x0240)
class AHybridNavigationArea : public AInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.HybridNavigationArea");
		}

		return uClassPointer;
	};

};

// Class Engine.HybridNavigationAreaDebugRenderingComponent
// 0x0000 (0x0360 - 0x0360)
class UHybridNavigationAreaDebugRenderingComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.HybridNavigationAreaDebugRenderingComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.HybridNavigationVisualizationComponent
// 0x0000 (0x0360 - 0x0360)
class UHybridNavigationVisualizationComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.HybridNavigationVisualizationComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.IniLocPatcher
// 0x0000 (0x0058 - 0x0058)
class UIniLocPatcher : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.IniLocPatcher");
		}

		return uClassPointer;
	};

};

// Class Engine.InteractiveFoliageComponent
// 0x0000 (0x0410 - 0x0410)
class UInteractiveFoliageComponent : public UStaticMeshComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.InteractiveFoliageComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.LadderReachSpec
// 0x0000 (0x0058 - 0x0058)
class ULadderReachSpec : public UReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LadderReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.LandscapeProxy
// 0x0000 (0x0240 - 0x0240)
class ALandscapeProxy : public AInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LandscapeProxy");
		}

		return uClassPointer;
	};

};

// Class Engine.Landscape
// 0x0000 (0x0240 - 0x0240)
class ALandscape : public ALandscapeProxy
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Landscape");
		}

		return uClassPointer;
	};

};

// Class Engine.LiftCenter
// 0x0000 (0x0260 - 0x0260)
class ALiftCenter : public ANavigationPoint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LiftCenter");
		}

		return uClassPointer;
	};

};

// Class Engine.LiftExit
// 0x0000 (0x0260 - 0x0260)
class ALiftExit : public ANavigationPoint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.LiftExit");
		}

		return uClassPointer;
	};

};

// Class Engine.MantleReachSpec
// 0x0000 (0x0058 - 0x0058)
class UMantleReachSpec : public UForcedReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MantleReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.MassiveLODOverrideVolume
// 0x0000 (0x0288 - 0x0288)
class AMassiveLODOverrideVolume : public AVolume
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.MassiveLODOverrideVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshPathGoalEvaluator
// 0x0000 (0x0058 - 0x0058)
class UNavMeshPathGoalEvaluator : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshPathGoalEvaluator");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoal_At
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoal_At : public UNavMeshPathGoalEvaluator
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoal_At");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoal_ClosestActorInList
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoal_ClosestActorInList : public UNavMeshPathGoalEvaluator
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoal_ClosestActorInList");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoal_Filter
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoal_Filter : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoal_Filter");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoal_GenericFilterContainer
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoal_GenericFilterContainer : public UNavMeshPathGoalEvaluator
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoal_GenericFilterContainer");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoal_Null
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoal_Null : public UNavMeshPathGoalEvaluator
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoal_Null");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoal_PolyEncompassesAI
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoal_PolyEncompassesAI : public UNavMeshPathGoalEvaluator
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoal_PolyEncompassesAI");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoal_Random
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoal_Random : public UNavMeshPathGoalEvaluator
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoal_Random");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoal_WithinDistanceEnvelope
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoal_WithinDistanceEnvelope : public UNavMeshPathGoalEvaluator
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoal_WithinDistanceEnvelope");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoalFilter_MinPathDistance
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoalFilter_MinPathDistance : public UNavMeshGoal_Filter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoalFilter_MinPathDistance");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoalFilter_NotNearOtherAI
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoalFilter_NotNearOtherAI : public UNavMeshGoal_Filter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoalFilter_NotNearOtherAI");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoalFilter_OutOfViewFrom
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoalFilter_OutOfViewFrom : public UNavMeshGoal_Filter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoalFilter_OutOfViewFrom");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoalFilter_OutSideOfDotProductWedge
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoalFilter_OutSideOfDotProductWedge : public UNavMeshGoal_Filter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoalFilter_OutSideOfDotProductWedge");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshGoalFilter_PolyEncompassesAI
// 0x0000 (0x0058 - 0x0058)
class UNavMeshGoalFilter_PolyEncompassesAI : public UNavMeshGoal_Filter
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshGoalFilter_PolyEncompassesAI");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshObstacle
// 0x0000 (0x0240 - 0x0240)
class ANavMeshObstacle : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshObstacle");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshPathConstraint
// 0x0000 (0x0058 - 0x0058)
class UNavMeshPathConstraint : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshPathConstraint");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshPath_AlongLine
// 0x0000 (0x0058 - 0x0058)
class UNavMeshPath_AlongLine : public UNavMeshPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshPath_AlongLine");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshPath_EnforceTwoWayEdges
// 0x0000 (0x0058 - 0x0058)
class UNavMeshPath_EnforceTwoWayEdges : public UNavMeshPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshPath_EnforceTwoWayEdges");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshPath_MinDistBetweenSpecsOfType
// 0x0000 (0x0058 - 0x0058)
class UNavMeshPath_MinDistBetweenSpecsOfType : public UNavMeshPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshPath_MinDistBetweenSpecsOfType");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshPath_SameCoverLink
// 0x0000 (0x0058 - 0x0058)
class UNavMeshPath_SameCoverLink : public UNavMeshPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshPath_SameCoverLink");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshPath_Toward
// 0x0000 (0x0058 - 0x0058)
class UNavMeshPath_Toward : public UNavMeshPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshPath_Toward");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshPath_WithinDistanceEnvelope
// 0x0000 (0x0058 - 0x0058)
class UNavMeshPath_WithinDistanceEnvelope : public UNavMeshPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshPath_WithinDistanceEnvelope");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshPath_WithinTraversalDist
// 0x0000 (0x0058 - 0x0058)
class UNavMeshPath_WithinTraversalDist : public UNavMeshPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshPath_WithinTraversalDist");
		}

		return uClassPointer;
	};

};

// Class Engine.NavMeshRenderingComponent
// 0x0000 (0x0360 - 0x0360)
class UNavMeshRenderingComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.NavMeshRenderingComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.OnlinePlaylistGameTypeProvider
// 0x0000 (0x00C8 - 0x00C8)
class UOnlinePlaylistGameTypeProvider : public UUIResourceDataProvider
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlinePlaylistGameTypeProvider");
		}

		return uClassPointer;
	};

};

// Class Engine.OnlineRecentPlayersList
// 0x0000 (0x0058 - 0x0058)
class UOnlineRecentPlayersList : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.OnlineRecentPlayersList");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleBeamModifier
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleBeamModifier : public UParticleModuleBeamBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleBeamModifier");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTypeDataAnimTrail
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleTypeDataAnimTrail : public UParticleModuleTypeDataBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTypeDataAnimTrail");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTypeDataBeam
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleTypeDataBeam : public UParticleModuleTypeDataBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTypeDataBeam");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTypeDataTrail
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleTypeDataTrail : public UParticleModuleTypeDataBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTypeDataTrail");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleTypeDataTrail2
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleTypeDataTrail2 : public UParticleModuleTypeDataBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleTypeDataTrail2");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleUberBase
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleUberBase : public UParticleModule
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleUberBase");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleUberLTISIVCL
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleUberLTISIVCL : public UParticleModuleUberBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleUberLTISIVCL");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleUberLTISIVCLIL
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleUberLTISIVCLIL : public UParticleModuleUberBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleUberLTISIVCLIL");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleUberLTISIVCLILIRSSBLIRR
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleUberLTISIVCLILIRSSBLIRR : public UParticleModuleUberBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleUberLTISIVCLILIRSSBLIRR");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleUberRainDrops
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleUberRainDrops : public UParticleModuleUberBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleUberRainDrops");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleUberRainImpacts
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleUberRainImpacts : public UParticleModuleUberBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleUberRainImpacts");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleUberRainSplashA
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleUberRainSplashA : public UParticleModuleUberBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleUberRainSplashA");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleModuleUberRainSplashB
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleUberRainSplashB : public UParticleModuleUberBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleModuleUberRainSplashB");
		}

		return uClassPointer;
	};

};

// Class Engine.ParticleSystemReplay
// 0x0000 (0x0058 - 0x0058)
class UParticleSystemReplay : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ParticleSystemReplay");
		}

		return uClassPointer;
	};

};

// Class Engine.PathConstraint
// 0x0000 (0x0058 - 0x0058)
class UPathConstraint : public UObject
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PathConstraint");
		}

		return uClassPointer;
	};

};

// Class Engine.Path_AlongLine
// 0x0000 (0x0058 - 0x0058)
class UPath_AlongLine : public UPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Path_AlongLine");
		}

		return uClassPointer;
	};

};

// Class Engine.Path_AvoidInEscapableNodes
// 0x0000 (0x0058 - 0x0058)
class UPath_AvoidInEscapableNodes : public UPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Path_AvoidInEscapableNodes");
		}

		return uClassPointer;
	};

};

// Class Engine.Path_MinDistBetweenSpecsOfType
// 0x0000 (0x0058 - 0x0058)
class UPath_MinDistBetweenSpecsOfType : public UPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Path_MinDistBetweenSpecsOfType");
		}

		return uClassPointer;
	};

};

// Class Engine.Path_TowardGoal
// 0x0000 (0x0058 - 0x0058)
class UPath_TowardGoal : public UPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Path_TowardGoal");
		}

		return uClassPointer;
	};

};

// Class Engine.Path_TowardPoint
// 0x0000 (0x0058 - 0x0058)
class UPath_TowardPoint : public UPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Path_TowardPoint");
		}

		return uClassPointer;
	};

};

// Class Engine.Path_WithinDistanceEnvelope
// 0x0000 (0x0058 - 0x0058)
class UPath_WithinDistanceEnvelope : public UPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Path_WithinDistanceEnvelope");
		}

		return uClassPointer;
	};

};

// Class Engine.Path_WithinTraversalDist
// 0x0000 (0x0058 - 0x0058)
class UPath_WithinTraversalDist : public UPathConstraint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Path_WithinTraversalDist");
		}

		return uClassPointer;
	};

};

// Class Engine.PathNode
// 0x0000 (0x0260 - 0x0260)
class APathNode : public ANavigationPoint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PathNode");
		}

		return uClassPointer;
	};

};

// Class Engine.PathNode_Dynamic
// 0x0000 (0x0260 - 0x0260)
class APathNode_Dynamic : public APathNode
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PathNode_Dynamic");
		}

		return uClassPointer;
	};

};

// Class Engine.PathRenderingComponent
// 0x0000 (0x0360 - 0x0360)
class UPathRenderingComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PathRenderingComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.PickupFactory
// 0x0000 (0x0260 - 0x0260)
class APickupFactory : public ANavigationPoint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.PickupFactory");
		}

		return uClassPointer;
	};

};

// Class Engine.ProscribedReachSpec
// 0x0000 (0x0058 - 0x0058)
class UProscribedReachSpec : public UReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.ProscribedReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.Route
// 0x0000 (0x0240 - 0x0240)
class ARoute : public AInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Route");
		}

		return uClassPointer;
	};

};

// Class Engine.RouteRenderingComponent
// 0x0000 (0x0360 - 0x0360)
class URouteRenderingComponent : public UPrimitiveComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.RouteRenderingComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.Scout
// 0x0000 (0x06B8 - 0x06B8)
class AScout : public APawn
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Scout");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_AddRemoveFaceFXAnimSet
// 0x0010 (0x00E8 - 0x00F8)
class USeqAct_AddRemoveFaceFXAnimSet : public USequenceAction
{
public:
	class TArray<class UFaceFXAnimSet*>                FaceFXAnimSets;                                // 0x00E8 (0x0010) [0x0000000020400000] (CPF_NeedCtorLink | CPF_Deprecated)

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_AddRemoveFaceFXAnimSet");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_AIAbortMoveToActor
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_AIAbortMoveToActor : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_AIAbortMoveToActor");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_MITV_Activate
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_MITV_Activate : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_MITV_Activate");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqAct_ModifyCover
// 0x0000 (0x00E8 - 0x00E8)
class USeqAct_ModifyCover : public USequenceAction
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqAct_ModifyCover");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqEvent_AIReachedRouteActor
// 0x0000 (0x0118 - 0x0118)
class USeqEvent_AIReachedRouteActor : public USequenceEvent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqEvent_AIReachedRouteActor");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_Byte
// 0x0000 (0x0088 - 0x0088)
class USeqVar_Byte : public USequenceVariable
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Byte");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_Name
// 0x0000 (0x0088 - 0x0088)
class USeqVar_Name : public USequenceVariable
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Name");
		}

		return uClassPointer;
	};

};

// Class Engine.SeqVar_Union
// 0x0000 (0x0088 - 0x0088)
class USeqVar_Union : public USequenceVariable
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SeqVar_Union");
		}

		return uClassPointer;
	};

};

// Class Engine.SlotToSlotReachSpec
// 0x0000 (0x0058 - 0x0058)
class USlotToSlotReachSpec : public UForcedReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SlotToSlotReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.SpeedTreeActor
// 0x0000 (0x0240 - 0x0240)
class ASpeedTreeActor : public AActor
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpeedTreeActor");
		}

		return uClassPointer;
	};

};

// Class Engine.SpeedTreeActorFactory
// 0x0000 (0x00C0 - 0x00C0)
class USpeedTreeActorFactory : public UActorFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpeedTreeActorFactory");
		}

		return uClassPointer;
	};

};

// Class Engine.SpeedTreeComponentFactory
// 0x0000 (0x0060 - 0x0060)
class USpeedTreeComponentFactory : public UPrimitiveComponentFactory
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SpeedTreeComponentFactory");
		}

		return uClassPointer;
	};

};

// Class Engine.SwatTurnReachSpec
// 0x0000 (0x0058 - 0x0058)
class USwatTurnReachSpec : public UForcedReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.SwatTurnReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.TeleportReachSpec
// 0x0000 (0x0058 - 0x0058)
class UTeleportReachSpec : public UReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TeleportReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.TestSplittingVolume
// 0x0000 (0x0288 - 0x0288)
class ATestSplittingVolume : public AVolume
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TestSplittingVolume");
		}

		return uClassPointer;
	};

};

// Class Engine.Trigger_LOS
// 0x0000 (0x0250 - 0x0250)
class ATrigger_LOS : public ATrigger
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.Trigger_LOS");
		}

		return uClassPointer;
	};

};

// Class Engine.TriggeredPath
// 0x0000 (0x0260 - 0x0260)
class ATriggeredPath : public ANavigationPoint
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.TriggeredPath");
		}

		return uClassPointer;
	};

};

// Class Engine.UICharacterSummary
// 0x0000 (0x00C8 - 0x00C8)
class UUICharacterSummary : public UUIResourceDataProvider
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UICharacterSummary");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataProvider_MenuItem
// 0x0000 (0x00C8 - 0x00C8)
class UUIDataProvider_MenuItem : public UUIResourceDataProvider
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataProvider_MenuItem");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataProvider_OnlinePlayerDataBase
// 0x0000 (0x0090 - 0x0090)
class UUIDataProvider_OnlinePlayerDataBase : public UUIDataProvider
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataProvider_OnlinePlayerDataBase");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataProvider_OnlineFriendMessages
// 0x0000 (0x0090 - 0x0090)
class UUIDataProvider_OnlineFriendMessages : public UUIDataProvider_OnlinePlayerDataBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataProvider_OnlineFriendMessages");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataProvider_OnlineFriends
// 0x0000 (0x0090 - 0x0090)
class UUIDataProvider_OnlineFriends : public UUIDataProvider_OnlinePlayerDataBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataProvider_OnlineFriends");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataProvider_OnlinePartyChatList
// 0x0000 (0x0090 - 0x0090)
class UUIDataProvider_OnlinePartyChatList : public UUIDataProvider_OnlinePlayerDataBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataProvider_OnlinePartyChatList");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataProvider_PlayerAchievements
// 0x0000 (0x0090 - 0x0090)
class UUIDataProvider_PlayerAchievements : public UUIDataProvider_OnlinePlayerDataBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataProvider_PlayerAchievements");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataProvider_Settings
// 0x0000 (0x00C8 - 0x00C8)
class UUIDataProvider_Settings : public UUIDynamicDataProvider
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataProvider_Settings");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataProvider_SettingsArray
// 0x0000 (0x0090 - 0x0090)
class UUIDataProvider_SettingsArray : public UUIDataProvider
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataProvider_SettingsArray");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_DynamicResource
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_DynamicResource : public UUIDataStore
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_DynamicResource");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_Fonts
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_Fonts : public UUIDataStore
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_Fonts");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_GameResource
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_GameResource : public UUIDataStore
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_GameResource");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_GameState
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_GameState : public UUIDataStore
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_GameState");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_InputAlias
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_InputAlias : public UUIDataStore_StringBase
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_InputAlias");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_MenuItems
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_MenuItems : public UUIDataStore_GameResource
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_MenuItems");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_Remote
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_Remote : public UUIDataStore
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_Remote");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_OnlineGameSearch
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_OnlineGameSearch : public UUIDataStore_Remote
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_OnlineGameSearch");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_Settings
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_Settings : public UUIDataStore
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_Settings");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_OnlineGameSettings
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_OnlineGameSettings : public UUIDataStore_Settings
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_OnlineGameSettings");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_OnlinePlayerData
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_OnlinePlayerData : public UUIDataStore_Remote
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_OnlinePlayerData");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_OnlineStats
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_OnlineStats : public UUIDataStore_Remote
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_OnlineStats");
		}

		return uClassPointer;
	};

};

// Class Engine.UIDataStore_Registry
// 0x0000 (0x00B8 - 0x00B8)
class UUIDataStore_Registry : public UUIDataStore
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIDataStore_Registry");
		}

		return uClassPointer;
	};

};

// Class Engine.UIGameInfoSummary
// 0x0000 (0x00C8 - 0x00C8)
class UUIGameInfoSummary : public UUIResourceDataProvider
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIGameInfoSummary");
		}

		return uClassPointer;
	};

};

// Class Engine.UIMapSummary
// 0x0000 (0x00C8 - 0x00C8)
class UUIMapSummary : public UUIResourceDataProvider
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIMapSummary");
		}

		return uClassPointer;
	};

};

// Class Engine.UIWeaponSummary
// 0x0000 (0x00C8 - 0x00C8)
class UUIWeaponSummary : public UUIResourceDataProvider
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.UIWeaponSummary");
		}

		return uClassPointer;
	};

};

// Class Engine.VolumePathNode
// 0x0000 (0x0260 - 0x0260)
class AVolumePathNode : public APathNode
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.VolumePathNode");
		}

		return uClassPointer;
	};

};

// Class Engine.WallTransReachSpec
// 0x0000 (0x0058 - 0x0058)
class UWallTransReachSpec : public UForcedReachSpec
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WallTransReachSpec");
		}

		return uClassPointer;
	};

};

// Class Engine.WindDirectionalSource
// 0x0000 (0x0240 - 0x0240)
class AWindDirectionalSource : public AInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WindDirectionalSource");
		}

		return uClassPointer;
	};

};

// Class Engine.WindDirectionalSourceComponent
// 0x0000 (0x0090 - 0x0090)
class UWindDirectionalSourceComponent : public UActorComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WindDirectionalSourceComponent");
		}

		return uClassPointer;
	};

};

// Class Engine.WindPointSource
// 0x0000 (0x0240 - 0x0240)
class AWindPointSource : public AInfo
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WindPointSource");
		}

		return uClassPointer;
	};

};

// Class Engine.WindPointSourceComponent
// 0x0000 (0x0090 - 0x0090)
class UWindPointSourceComponent : public UWindDirectionalSourceComponent
{
public:

public:
	static UClass* StaticClass()
	{
		static UClass* uClassPointer = nullptr;

		if (!uClassPointer)
		{
			uClassPointer = UObject::FindClass("Class Engine.WindPointSourceComponent");
		}

		return uClassPointer;
	};

};

/*
# ========================================================================================= #
#
# ========================================================================================= #
*/

#ifdef _MSC_VER
	#pragma pack(pop)
#endif
